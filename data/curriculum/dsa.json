[
    {
        "id": "dsa-l1",
        "title": "LEVEL 1: Programming & DSA Foundations (Beginner)",
        "description": "Goal: Build logical thinking & coding base",
        "lessons": [
            {
                "id": "d1",
                "title": "1. What is DSA? Why DSA?",
                "duration": "15 mins",
                "content": "# üß¨ Understanding DSA\n\n**Data Structures** are ways to organize data in a computer so that it can be used efficiently. **Algorithms** are step-by-step procedures for solving problems.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What is an Algorithm?",
                        "options": [
                            "A data container",
                            "A step-by-step procedure"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Algorithms are instructions for solving problems."
                    },
                    {
                        "id": 2,
                        "text": "Which is a Data Structure?",
                        "options": [
                            "Binary Search",
                            "Array"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Array is a way to organize data elements."
                    }
                ]
            },
            {
                "id": "d2",
                "title": "2. Time & Space Complexity",
                "duration": "20 mins",
                "content": "# ‚è≥ Complexity Analysis\n\nEfficiency is measured in two dimensions: **Time Complexity** (CPU time) and **Space Complexity** (Memory usage).",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Memory growth is called?",
                        "options": [
                            "Time complexity",
                            "Space complexity"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Space complexity focuses on memory usage."
                    }
                ]
            },
            {
                "id": "d3",
                "title": "3. Big-O, Big-Œ©, Big-Œò",
                "duration": "20 mins",
                "content": "# üî£ Asymptotic Notations\n\n1. **Big-O (O)**: Upper bound (Worst case).\n2. **Big-Omega (Œ©)**: Lower bound (Best case).\n3. **Big-Theta (Œò)**: Tight bound (Average case).",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Which notation represents the Worst Case?",
                        "options": [
                            "Big-O",
                            "Big-Omega"
                        ],
                        "correctAnswer": 0,
                        "explanation": "Big-O defines the upper limit of growth."
                    }
                ]
            },
            {
                "id": "d4",
                "title": "4. Best, Average & Worst Case",
                "duration": "15 mins",
                "content": "# üìä Case Scenarios\n\n- **Worst Case**: Maximum time.\n- **Best Case**: Minimum time.\n- **Average Case**: Performance over all possible inputs.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Sorting a reverse array is usually?",
                        "options": [
                            "Best case",
                            "Worst case"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Most algorithms reach peak complexity here."
                    }
                ]
            },
            {
                "id": "d5",
                "title": "5. Recursion Basics",
                "duration": "25 mins",
                "content": "# üîÅ Recursion\n\nA function calling itself. Requires a **Base Case** and a **Recursive Step**.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Missing base case causes?",
                        "options": [
                            "Infinite loop",
                            "StackOverflowError"
                        ],
                        "correctAnswer": 1,
                        "explanation": "The stack eventually runs out of memory."
                    }
                ]
            },
            {
                "id": "d6",
                "title": "6. Iterative vs Recursive Approach",
                "duration": "20 mins",
                "content": "# ‚öñÔ∏è Iteration vs Recursion\n\n- **Iteration**: Uses loops, constant space.\n- **Recursion**: Uses function calls, O(n) stack space.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Which is generally more memory-efficient?",
                        "options": [
                            "Recursion",
                            "Iteration"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Iteration doesn't add stack frames."
                    }
                ]
            }
        ]
    },
    {
        "id": "dsa-l2",
        "title": "LEVEL 2: Arrays & Strings",
        "description": "Goal: Master linear data structures",
        "lessons": [
            {
                "id": "d7",
                "title": "7. Arrays (1D & 2D)",
                "duration": "25 mins",
                "content": "# üß± Arrays\n\nFixed-size contiguous memory collection.\n- **1D**: `int[] arr`\n- **2D**: `int[][] matrix`",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Array search (linear) complexity?",
                        "options": [
                            "O(1)",
                            "O(n)"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Might need to check every element."
                    }
                ]
            },
            {
                "id": "d8",
                "title": "8. Array Operations",
                "duration": "20 mins",
                "content": "# üîß Operations\n\nInsertion and Deletion are O(n) due to shifting elements.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Delete at index 0?",
                        "options": [
                            "O(1)",
                            "O(n)"
                        ],
                        "correctAnswer": 1,
                        "explanation": "All elements must shift left."
                    }
                ]
            },
            {
                "id": "d9",
                "title": "9. Sliding Window Technique",
                "duration": "30 mins",
                "content": "# ü™ü Sliding Window\n\nOptimizes contiguous subarray problems from O(n¬≤) to O(n).",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Goal of sliding window?",
                        "options": [
                            "Sorting",
                            "Reduce nested loops"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Reuses calculation from previous window."
                    }
                ]
            },
            {
                "id": "d10",
                "title": "10. Prefix Sum Technique",
                "duration": "20 mins",
                "content": "# ‚ûï Prefix Sum\n\nAllows O(1) range sum queries after O(n) preprocessing.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Range query complexity after prefix sum?",
                        "options": [
                            "O(n)",
                            "O(1)"
                        ],
                        "correctAnswer": 1,
                        "explanation": "It's just one subtraction."
                    }
                ]
            },
            {
                "id": "d11",
                "title": "11. Strings Basics",
                "duration": "15 mins",
                "content": "# üßµ Strings\n\nArrays of characters, often immutable in high-level languages.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What is an immutable string?",
                        "options": [
                            "Cannot be used",
                            "Cannot be modified"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Modifications create new objects."
                    }
                ]
            },
            {
                "id": "d12",
                "title": "12. String Matching Basics",
                "duration": "25 mins",
                "content": "# üîç String Search\n\nBrute force pattern matching runs in O(N*M).",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Naive matching worst case?",
                        "options": [
                            "O(N)",
                            "O(N*M)"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Where M is pattern length."
                    }
                ]
            },
            {
                "id": "d13",
                "title": "13. Two Pointer Technique",
                "duration": "30 mins",
                "content": "# ‚úåÔ∏è Two Pointers\n\nUsed on sorted arrays to find pairs/triplets in O(n).",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Two pointers on sorted array complexity?",
                        "options": [
                            "O(n)",
                            "O(n^2)"
                        ],
                        "correctAnswer": 0,
                        "explanation": "Each element is visited at most once."
                    }
                ]
            }
        ]
    },
    {
        "id": "dsa-l3",
        "title": "LEVEL 3: Searching & Sorting",
        "description": "Goal: Fundamental algorithms",
        "lessons": [
            {
                "id": "d14",
                "title": "14. Linear Search",
                "duration": "10 mins",
                "content": "# üîç Linear Search\n\nO(n) worst case search by visiting elements one by one.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Linear search complexity?",
                        "options": [
                            "O(log n)",
                            "O(n)"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Checks each element sequentially."
                    }
                ]
            },
            {
                "id": "d15",
                "title": "15. Binary Search",
                "duration": "20 mins",
                "content": "# ‚úÇÔ∏è Binary Search\n\nO(log n) search on sorted data by halving the interval.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Requirement for Binary Search?",
                        "options": [
                            "Non-empty array",
                            "Sorted array"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Efficiency depends on the range property."
                    }
                ]
            },
            {
                "id": "d16",
                "title": "16. Search in Rotated Array",
                "duration": "25 mins",
                "content": "# üé° Rotated Array Search\n\nModified binary search to find an element in a sorted-then-rotated array.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Complexity?",
                        "options": [
                            "O(n)",
                            "O(log n)"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Still uses the binary search mechanism."
                    }
                ]
            },
            {
                "id": "d17",
                "title": "17. Bubble Sort",
                "duration": "15 mins",
                "content": "# ü´ß Bubble Sort\n\nO(n¬≤) sorting by repeatedly swapping adjacent elements.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Bubble sort stability?",
                        "options": [
                            "Stable",
                            "Unstable"
                        ],
                        "correctAnswer": 0,
                        "explanation": "Doesn't swap equal elements."
                    }
                ]
            },
            {
                "id": "d18",
                "title": "18. Selection Sort",
                "duration": "15 mins",
                "content": "# üéØ Selection Sort\n\nO(n¬≤) sorting by repeatedly picking the minimum element.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Complexity?",
                        "options": [
                            "Always O(n^2)",
                            "O(n)"
                        ],
                        "correctAnswer": 0,
                        "explanation": "It always scans the entire remaining list."
                    }
                ]
            },
            {
                "id": "d19",
                "title": "19. Insertion Sort",
                "duration": "15 mins",
                "content": "# üÉè Insertion Sort\n\nO(n¬≤) sorting by inserting one element at a time into a sorted sub-part.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Is it adaptive?",
                        "options": [
                            "Yes",
                            "No"
                        ],
                        "correctAnswer": 0,
                        "explanation": "Fast on nearly-sorted data."
                    }
                ]
            },
            {
                "id": "d20",
                "title": "20. Merge Sort",
                "duration": "30 mins",
                "content": "# üß© Merge Sort\n\nO(n log n) Divide and Conquer sorting using O(n) extra space.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Merge sort strategy?",
                        "options": [
                            "Greedy",
                            "Divide & Conquer"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Splits problem into sub-problems."
                    }
                ]
            },
            {
                "id": "d21",
                "title": "21. Quick Sort",
                "duration": "30 mins",
                "content": "# ‚ö° Quick Sort\n\nIn-place Divide and Conquer sorting using a pivot. O(n log n) average.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Worst case occurs when?",
                        "options": [
                            "Bad pivot",
                            "Merge step"
                        ],
                        "correctAnswer": 0,
                        "explanation": "Usually with sorted data and end pivots."
                    }
                ]
            },
            {
                "id": "d22",
                "title": "22. Counting Sort",
                "duration": "20 mins",
                "content": "# üî¢ Counting Sort\n\nO(n + k) non-comparison sorting for limited ranges.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Is it comparison-based?",
                        "options": [
                            "Yes",
                            "No"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Uses frequency counts."
                    }
                ]
            },
            {
                "id": "d23",
                "title": "23. Radix Sort",
                "duration": "25 mins",
                "content": "# üîü Radix Sort\n\nSorting numbers digit by digit. Effective for large datasets with small digits.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Stable sort needed?",
                        "options": [
                            "Yes",
                            "No"
                        ],
                        "correctAnswer": 0,
                        "explanation": "Crucial for correct ordering across digits."
                    }
                ]
            }
        ]
    },
    {
        "id": "dsa-l4",
        "title": "LEVEL 4: Linked List",
        "description": "Goal: Dynamic memory structures",
        "lessons": [
            {
                "id": "d24",
                "title": "24. Singly Linked List",
                "duration": "20 mins",
                "content": "# üß¨ Singly Linked List\n\nForward-only collection of nodes with data and next pointers.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Accessing 5th element complexity?",
                        "options": [
                            "O(1)",
                            "O(n)"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Must traverse from the head."
                    }
                ]
            },
            {
                "id": "d25",
                "title": "25. Doubly Linked List",
                "duration": "20 mins",
                "content": "# ‚ÜîÔ∏è Doubly Linked List\n\nNodes with next and previous pointers for bidirectional travel.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Benefit of Doubly LL?",
                        "options": [
                            "Less memory",
                            "Bidirectional traversal"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Can move head-to-tail and tail-to-head."
                    }
                ]
            },
            {
                "id": "d26",
                "title": "26. Circular Linked List",
                "duration": "20 mins",
                "content": "# ‚≠ï Circular Linked List\n\nLast node points back to the head, creating a circle.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Last node points to?",
                        "options": [
                            "Null",
                            "Head"
                        ],
                        "correctAnswer": 1,
                        "explanation": "This creates the circle."
                    }
                ]
            },
            {
                "id": "d27",
                "title": "27. Insertion & Deletion",
                "duration": "25 mins",
                "content": "# üõ†Ô∏è Operations\n\nInserting at head is O(1). Inserting at middle/tail is O(n).",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Insert at head?",
                        "options": [
                            "O(1)",
                            "O(n)"
                        ],
                        "correctAnswer": 0,
                        "explanation": "Just update head pointer."
                    }
                ]
            },
            {
                "id": "d28",
                "title": "28. Reverse Linked List",
                "duration": "25 mins",
                "content": "# ‚Ü©Ô∏è Reversing a List\n\nFlipping pointer directions. O(n) time and O(1) space iteratively.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Reverse complexity?",
                        "options": [
                            "O(n)",
                            "O(n^2)"
                        ],
                        "correctAnswer": 0,
                        "explanation": "Single pass over the list."
                    }
                ]
            },
            {
                "id": "d29",
                "title": "29. Detect Cycle",
                "duration": "25 mins",
                "content": "# üïµÔ∏è Detect Cycle\n\nFloyd's Tortoise and Hare algorithm detects loops in O(n).",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Fast pointer speed?",
                        "options": [
                            "1 step",
                            "2 steps"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Moves double speed to catch slow pointer."
                    }
                ]
            },
            {
                "id": "d30",
                "title": "30. Merge Two Sorted Lists",
                "duration": "20 mins",
                "content": "# ü§ù Merging sorted lists\n\nCombining two sorted lists into one in O(N+M) time.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Merge complexity?",
                        "options": [
                            "O(N+M)",
                            "O(N*M)"
                        ],
                        "correctAnswer": 0,
                        "explanation": "Visits each node once."
                    }
                ]
            }
        ]
    },
    {
        "id": "dsa-l5",
        "title": "LEVEL 5: Stack & Queue",
        "description": "Goal: LIFO & FIFO structures",
        "lessons": [
            {
                "id": "d31",
                "title": "31. Stack Implementation",
                "duration": "20 mins",
                "content": "# ü•û Stack\n\nLIFO (Last-In First-Out) data structure. \n- **Push**: Add element.\n- **Pop**: Remove top element.\n- **Peek**: See top element.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "LIFO stands for?",
                        "options": [
                            "Last-In First-Out",
                            "Linear Input Fast Output"
                        ],
                        "correctAnswer": 0,
                        "explanation": "The last item added is the first one removed."
                    }
                ]
            },
            {
                "id": "d32",
                "title": "32. Stack Applications",
                "duration": "20 mins",
                "content": "# üõ†Ô∏è Use Cases\n\n- Undo/Redo operations.\n- Expression evaluation (Postfix/Infix).\n- Backtracking problems.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Function calls use which structure?",
                        "options": [
                            "Queue",
                            "Stack"
                        ],
                        "correctAnswer": 1,
                        "explanation": "The Call Stack manages active function calls."
                    }
                ]
            },
            {
                "id": "d33",
                "title": "33. Queue Implementation",
                "duration": "20 mins",
                "content": "# üéüÔ∏è Queue\n\nFIFO (First-In First-Out) data structure.\n- **Enqueue**: Add to rear.\n- **Dequeue**: Remove from front.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "FIFO stands for?",
                        "options": [
                            "First-In First-Out",
                            "Fast Input Fast Output"
                        ],
                        "correctAnswer": 0,
                        "explanation": "The first item added is the first one removed (like a line)."
                    }
                ]
            },
            {
                "id": "d34",
                "title": "34. Circular Queue",
                "duration": "20 mins",
                "content": "# ‚≠ï Circular Queue\n\nConnecting the end back to the front to avoid wasting space in array-based implementations.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Goal of Circular Queue?",
                        "options": [
                            "Faster access",
                            "Reuse empty slots"
                        ],
                        "correctAnswer": 1,
                        "explanation": "The rear wraps around to the beginning once it reachers capacity."
                    }
                ]
            },
            {
                "id": "d35",
                "title": "35. Deque",
                "duration": "20 mins",
                "content": "# ‚ÜîÔ∏è Double-Ended Queue\n\nElements can be added or removed from either the front or the rear.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Deque stands for?",
                        "options": [
                            "Decrease Queue",
                            "Double-Ended Queue"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Supports both stack and queue operations."
                    }
                ]
            },
            {
                "id": "d36",
                "title": "36. Priority Queue",
                "duration": "20 mins",
                "content": "# üèÜ Priority Queue\n\nEach element has a priority. Higher priority elements are dequeued first.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Core characteristic?",
                        "options": [
                            "Sorted data",
                            "Priority-based removal"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Not strictly FIFO; depends on priority values."
                    }
                ]
            },
            {
                "id": "d37",
                "title": "37. Stack using Queue & Vice Versa",
                "duration": "25 mins",
                "content": "# üîÑ Cross Implementation\n\nImplementing a Stack using two Queues or a Queue using two Stacks.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Queue using 2 Stacks (Enqueue)?",
                        "options": [
                            "O(1)",
                            "O(n)"
                        ],
                        "correctAnswer": 0,
                        "explanation": "Standard implementation makes enqueue O(1) or O(n) depending on the variant."
                    }
                ]
            }
        ]
    },
    {
        "id": "dsa-l6",
        "title": "LEVEL 6: Hashing",
        "description": "Goal: Fast lookup & storage",
        "lessons": [
            {
                "id": "d38",
                "title": "38. Hash Tables",
                "duration": "20 mins",
                "content": "# üîç Hash Table\n\nStores key-value pairs using a hash function to compute an index in an array.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Average search time?",
                        "options": [
                            "O(1)",
                            "O(n)"
                        ],
                        "correctAnswer": 0,
                        "explanation": "Hashing allows nearly constant-time access."
                    }
                ]
            },
            {
                "id": "d39",
                "title": "39. Hash Functions",
                "duration": "20 mins",
                "content": "# ‚öôÔ∏è Hash Functions\n\nMapping a key to a specific integer. Must be **Deterministic**.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Deterministic means?",
                        "options": [
                            "Random result",
                            "Same input always gives same output"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Essential for retrieving stored values."
                    }
                ]
            },
            {
                "id": "d40",
                "title": "40. Collision Handling",
                "duration": "20 mins",
                "content": "# üí• Collisions\n\nWhen two different keys map to the same hash index. Handled by Seperate Chaining or Open Addressing.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Collision happens when?",
                        "options": [
                            "Keys are unique",
                            "Multiple keys map to same index"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Pigeonhole principle applied to hashing."
                    }
                ]
            },
            {
                "id": "d41",
                "title": "41. Open Addressing",
                "duration": "25 mins",
                "content": "# üè† Open Addressing\n\nFinding another slot in the array when a collision occurs (Linear probing, Quadratic probing, Double hashing).",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Linear probing check?",
                        "options": [
                            "Next available slot",
                            "Rehash to another table"
                        ],
                        "correctAnswer": 0,
                        "explanation": "Searches slots sequentially (i+1, i+2...)."
                    }
                ]
            },
            {
                "id": "d42",
                "title": "42. Separate Chaining",
                "duration": "25 mins",
                "content": "# ‚õìÔ∏è Separate Chaining\n\nEach array slot point to a linked list of records that share the same hash index.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Data structure used in slots?",
                        "options": [
                            "Arrays",
                            "Linked Lists"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Standard chaining uses linked nodes."
                    }
                ]
            },
            {
                "id": "d43",
                "title": "43. HashMap / Dictionary",
                "duration": "20 mins",
                "content": "# üìò HashMap\n\nA high-level implementation of the Hash Table. Essential for modern programming.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Key property in Maps?",
                        "options": [
                            "Must be unique",
                            "Can be duplicate"
                        ],
                        "correctAnswer": 0,
                        "explanation": "Keys act as unique identifiers for values."
                    }
                ]
            }
        ]
    },
    {
        "id": "dsa-l7",
        "title": "LEVEL 7: Trees",
        "description": "Goal: Hierarchical data structures",
        "lessons": [
            {
                "id": "d44",
                "title": "44. Tree Terminologies",
                "duration": "15 mins",
                "content": "# üå≥ Tree Basics\n\nA non-linear data structure representing a hierarchy.\n- **Root**: Top node.\n- **Leaf**: Node with no children.\n- **Height**: Longest path to a leaf.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What is a Leaf node?",
                        "options": [
                            "The top node",
                            "A node with no children"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Leaves are the terminal nodes of a tree."
                    }
                ]
            },
            {
                "id": "d45",
                "title": "45. Binary Tree",
                "duration": "20 mins",
                "content": "# üåø Binary Tree\n\nEach node has at most **two** children (Left and Right).",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Max children in Binary Tree?",
                        "options": [
                            "1",
                            "2"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Binary means base 2."
                    }
                ]
            },
            {
                "id": "d46",
                "title": "46. Tree Traversals (DFS, BFS)",
                "duration": "25 mins",
                "content": "# üó∫Ô∏è Traversals\n\n- **DFS**: Pre-order, In-order, Post-order.\n- **BFS**: Level-order traversal using a Queue.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "BFS uses which structure?",
                        "options": [
                            "Stack",
                            "Queue"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Queue handles nodes level by level."
                    }
                ]
            },
            {
                "id": "d47",
                "title": "47. Binary Search Tree",
                "duration": "20 mins",
                "content": "# üîç BST\n\n- Left child < Parent\n- Right child > Parent\n- Efficiency: O(log n) for search.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Property of BST?",
                        "options": [
                            "Random order",
                            "Sorted relationship"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Left is smaller, Right is larger."
                    }
                ]
            },
            {
                "id": "d48",
                "title": "48. BST Operations",
                "duration": "25 mins",
                "content": "# üõ†Ô∏è BST Ops\n\nSearch, Insertion, and Deletion. Deletion has 3 cases: Leaf, 1 child, 2 children.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Worst case search in BST?",
                        "options": [
                            "O(log n)",
                            "O(n)"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Occurs if the tree is skewed (like a linked list)."
                    }
                ]
            },
            {
                "id": "d49",
                "title": "49. AVL Tree",
                "duration": "30 mins",
                "content": "# ‚öñÔ∏è AVL Tree\n\nA self-balancing BST where the height difference between left and right subtrees is at most 1.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "AVL is used for?",
                        "options": [
                            "Faster sorting",
                            "Maintaining balance"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Ensures O(log n) height always."
                    }
                ]
            },
            {
                "id": "d50",
                "title": "50. Red-Black Tree",
                "duration": "30 mins",
                "content": "# üî¥‚ö´ Red-Black Tree\n\nA balanced BST that uses color properties to ensure the tree remains approximately balanced.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Used in which Java class?",
                        "options": [
                            "ArrayList",
                            "TreeMap"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Java's TreeMap and TreeSet use Red-Black trees."
                    }
                ]
            },
            {
                "id": "d51",
                "title": "51. Heap (Min & Max)",
                "duration": "25 mins",
                "content": "# üèîÔ∏è Heap\n\nA complete binary tree that satisfies the **Heap Property**.\n- **Min-Heap**: Parent <= Children.\n- **Max-Heap**: Parent >= Children.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Max element in Max-Heap is at?",
                        "options": [
                            "Root",
                            "Any leaf"
                        ],
                        "correctAnswer": 0,
                        "explanation": "The root always holds the highest priority element."
                    }
                ]
            },
            {
                "id": "d52",
                "title": "52. Priority Queue using Heap",
                "duration": "20 mins",
                "content": "# ü•á Priority Queue\n\nUsing a Heap to implement a Priority Queue ensures O(log n) insertion and extraction.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Heap insert complexity?",
                        "options": [
                            "O(1)",
                            "O(log n)"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Requires 'bubbling up' the new element."
                    }
                ]
            }
        ]
    },
    {
        "id": "dsa-l8",
        "title": "LEVEL 8: Graphs",
        "description": "Goal: Network & relationship problems",
        "lessons": [
            {
                "id": "d53",
                "title": "53. Graph Representation",
                "duration": "20 mins",
                "content": "# üï∏Ô∏è Graphs\n\nNodes (Vertices) and Edges.\n- **Adjacency Matrix**: 2D array.\n- **Adjacency List**: Array of lists.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Space-efficient for sparse graphs?",
                        "options": [
                            "Matrix",
                            "List"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Adjacency List only stores present edges."
                    }
                ]
            },
            {
                "id": "d54",
                "title": "54. BFS & DFS",
                "duration": "30 mins",
                "content": "# üß≠ Graph Traversal\n\n- **BFS**: Breadth-First (Layer by layer).\n- **DFS**: Depth-First (Deeper first).",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "DFS uses which structure?",
                        "options": [
                            "Queue",
                            "Stack/Recursion"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Explores a path completely before backtracking."
                    }
                ]
            },
            {
                "id": "d55",
                "title": "55. Connected Components",
                "duration": "20 mins",
                "content": "# üîó Components\n\nIdentifying subgraphs where all vertices are connected to each other.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Algo to find components?",
                        "options": [
                            "Binary Search",
                            "DFS/BFS"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Each traversal identifies one component."
                    }
                ]
            },
            {
                "id": "d56",
                "title": "56. Cycle Detection",
                "duration": "25 mins",
                "content": "# üîÑ Graph Cycles\n\nDetecting if a path exists from a vertex back to itself.\n- Directed: Using recursion stack.\n- Undirected: Using parent pointers.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Cyclic graph property?",
                        "options": [
                            "No loops",
                            "Has at least one cycle"
                        ],
                        "correctAnswer": 1,
                        "explanation": "A path returns to the starting node."
                    }
                ]
            },
            {
                "id": "d57",
                "title": "57. Topological Sorting",
                "duration": "25 mins",
                "content": "# üìâ Topological Sort\n\nLinear ordering of vertices in a Directed Acyclic Graph (DAG) such that for every edge u -> v, u comes before v.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Requires a?",
                        "options": [
                            "Cycle",
                            "DAG (No Cycles)"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Cycles make topological sorting impossible."
                    }
                ]
            },
            {
                "id": "d58",
                "title": "58. Shortest Path (Dijkstra)",
                "duration": "30 mins",
                "content": "# üõ£Ô∏è Dijkstra's Algorithm\n\nFinding the shortest path from a source to all other vertices in a weighted graph (no negative weights).",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Type of strategy?",
                        "options": [
                            "Greedy",
                            "DP"
                        ],
                        "correctAnswer": 0,
                        "explanation": "Always picks the nearest unvisited node."
                    }
                ]
            },
            {
                "id": "d59",
                "title": "59. Bellman-Ford Algorithm",
                "duration": "30 mins",
                "content": "# üìâ Bellman-Ford\n\nFinds shortest paths and **detects negative cycles** in a weighted graph.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Works with negative weights?",
                        "options": [
                            "Yes",
                            "No"
                        ],
                        "correctAnswer": 0,
                        "explanation": "Handles negative edge weights but not negative cycles."
                    }
                ]
            },
            {
                "id": "d60",
                "title": "60. Floyd-Warshall Algorithm",
                "duration": "30 mins",
                "content": "# üåê Floyd-Warshall\n\nFinds shortest paths between **all pairs** of vertices.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Complexity?",
                        "options": [
                            "O(V^2)",
                            "O(V^3)"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Triple nested loop over all vertices."
                    }
                ]
            },
            {
                "id": "d61",
                "title": "61. Minimum Spanning Tree (Kruskal, Prim)",
                "duration": "35 mins",
                "content": "# üå≤ MST\n\nA subset of edges connecting all vertices with the minimum total weight.\n- **Kruskal**: Edge-based.\n- **Prim**: Vertex-based.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "MST property?",
                        "options": [
                            "Contains cycles",
                            "Connects all nodes with min weight"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Forms a tree covering all vertices."
                    }
                ]
            }
        ]
    },
    {
        "id": "dsa-l9",
        "title": "LEVEL 9: Advanced Algorithms",
        "description": "Goal: Interview & competitive programming mastery",
        "lessons": [
            {
                "id": "d62",
                "title": "62. Greedy Algorithms",
                "duration": "25 mins",
                "content": "# üçï Greedy Algorithms\n\nMaking the locally optimal choice at each step with the hope of finding a global optimum.\n- Examples: Fractional Knapsack, Activity Selection.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Greedy always finds global optimum?",
                        "options": [
                            "Yes",
                            "No, not always"
                        ],
                        "correctAnswer": 1,
                        "explanation": "It depends on the problem property (Greedy Choice Property)."
                    }
                ]
            },
            {
                "id": "d63",
                "title": "63. Divide & Conquer",
                "duration": "20 mins",
                "content": "# ‚úÇÔ∏è Divide & Conquer\n\nBreaking a problem into smaller subproblems, solving them, and combining the results.\n- Examples: Binary Search, Quick Sort.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Strategy name?",
                        "options": [
                            "Greedy",
                            "Divide & Conquer"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Recursive splitting and merging."
                    }
                ]
            },
            {
                "id": "d64",
                "title": "64. Backtracking",
                "duration": "30 mins",
                "content": "# ‚Ü©Ô∏è Backtracking\n\nA refinement of brute force that prunes paths that cannot lead to a solution.\n- Examples: N-Queens, Sudoku Solver.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Core mechanism?",
                        "options": [
                            "Looping",
                            "Recursion + Pruning"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Goes deep and retreats on failure."
                    }
                ]
            },
            {
                "id": "d65",
                "title": "65. Dynamic Programming (DP)",
                "duration": "35 mins",
                "content": "# üß† Dynamic Programming\n\nSolving complex problems by breaking them into overlapping subproblems and storing results (memoization/tabulation).",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "DP requirement?",
                        "options": [
                            "Unique subproblems",
                            "Overlapping subproblems"
                        ],
                        "correctAnswer": 1,
                        "explanation": "DP avoids re-calculating the same state twice."
                    }
                ]
            },
            {
                "id": "d66",
                "title": "66. 0/1 Knapsack",
                "duration": "30 mins",
                "content": "# üéí 0/1 Knapsack\n\nA classic DP problem: Choose items with weight and value to maximize value without exceeding capacity. Each item is either picked (1) or not (0).",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Can we take half an item?",
                        "options": [
                            "Yes (Fractional)",
                            "No (0/1)"
                        ],
                        "correctAnswer": 1,
                        "explanation": "In 0/1, items are discrete units."
                    }
                ]
            },
            {
                "id": "d67",
                "title": "67. Longest Common Subsequence",
                "duration": "30 mins",
                "content": "# üß¨ LCS\n\nFinding the longest sequence of characters that appears in the same relative order in two strings.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Complexity?",
                        "options": [
                            "O(N+M)",
                            "O(N*M)"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Standard DP approach uses a 2D table."
                    }
                ]
            },
            {
                "id": "d68",
                "title": "68. Longest Increasing Subsequence",
                "duration": "30 mins",
                "content": "# üìà LIS\n\nFinding the length of the longest subsequence of a given sequence such that all elements are sorted in increasing order.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "DP complexity?",
                        "options": [
                            "O(N^2)",
                            "O(N log N)"
                        ],
                        "correctAnswer": 0,
                        "explanation": "Simple DP is N^2; optimized version is N log N."
                    }
                ]
            },
            {
                "id": "d69",
                "title": "69. Matrix DP",
                "duration": "30 mins",
                "content": "# üî≥ Matrix DP\n\nPath-finding and optimization problems on grids (e.g., Minimum Path Sum).",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Movement usually?",
                        "options": [
                            "Right or Down",
                            "Any direction"
                        ],
                        "correctAnswer": 0,
                        "explanation": "Usually restricted to maintain a DAG of states."
                    }
                ]
            },
            {
                "id": "d70",
                "title": "70. Bit Manipulation",
                "duration": "25 mins",
                "content": "# üî¢ Bitwise Ops\n\nUsing low-level bits (`&`, `|`, `^`, `~`, `<<`, `>>`) to solve problems efficiently.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Check if number is even?",
                        "options": [
                            "(n % 2 == 0)",
                            "(n & 1 == 0)"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Bitwise check is often faster."
                    }
                ]
            }
        ]
    },
    {
        "id": "dsa-l10",
        "title": "LEVEL 10: Advanced DSA & Interview Prep",
        "description": "Goal: Job-ready DSA mastery",
        "lessons": [
            {
                "id": "d71",
                "title": "71. Tries",
                "duration": "25 mins",
                "content": "# üìí Trie (Prefix Tree)\n\nEfficient information retrieval. Used for autocompletion and dictionary searches.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Best use case?",
                        "options": [
                            "Sorting integers",
                            "Dictionary/Prefix search"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Stores characters at edges for fast string lookup."
                    }
                ]
            },
            {
                "id": "d72",
                "title": "72. Segment Trees",
                "duration": "35 mins",
                "content": "# üìä Segment Tree\n\nA tree data structure for storing information about intervals or segments. Allows O(log n) range queries and updates.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Update complexity?",
                        "options": [
                            "O(1)",
                            "O(log n)"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Must update parents up to the root."
                    }
                ]
            },
            {
                "id": "d73",
                "title": "73. Fenwick Tree (BIT)",
                "duration": "30 mins",
                "content": "# üìâ Fenwick Tree\n\nBinary Indexed Tree. Efficiently updates elements and calculates prefix sums in O(log n).",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Space compared to Segment Tree?",
                        "options": [
                            "More",
                            "Less"
                        ],
                        "correctAnswer": 1,
                        "explanation": "BIT uses O(N) space, less than Segment Tree."
                    }
                ]
            },
            {
                "id": "d74",
                "title": "74. Disjoint Set Union (Union-Find)",
                "duration": "30 mins",
                "content": "# ü§ù DSU\n\nTracks a set of elements partitioned into a number of disjoint (non-overlapping) subsets.\n- **Find**: Find representative.\n- **Union**: Merge two sets.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Path compression benefit?",
                        "options": [
                            "Uses less memory",
                            "Flattens tree for O(alpha) time"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Picks every node's parent as the root during find."
                    }
                ]
            },
            {
                "id": "d75",
                "title": "75. Mo‚Äôs Algorithm (Basics)",
                "duration": "20 mins",
                "content": "# üì¶ Mo's Algorithm\n\nAn offline algorithm to process range queries in O((N+Q) * sqrt(N)) by sorting queries in blocks.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Type of algorithm?",
                        "options": [
                            "Online",
                            "Offline (All queries known)"
                        ],
                        "correctAnswer": 1,
                        "explanation": "You must sort all queries before processing."
                    }
                ]
            },
            {
                "id": "d76",
                "title": "76. String Algorithms (KMP, Z-Algorithm)",
                "duration": "35 mins",
                "content": "# üßµ Advanced String Search\n\n- **KMP**: O(N+M) using LPS array.\n- **Z-Algo**: Preprocesses all occurrences in O(N+M).",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "KMP benefit?",
                        "options": [
                            "Simple logic",
                            "No backtracking in text pointers"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Only the pattern pointer resets based on prefix knowledge."
                    }
                ]
            },
            {
                "id": "d77",
                "title": "77. Computational Geometry (Basics)",
                "duration": "25 mins",
                "content": "# üìê Geometry\n\nAlgorithms involving points, lines, and polygons (e.g., Convex Hull).",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Convex Hull algorithm?",
                        "options": [
                            "Graham Scan",
                            "Bubble Sort"
                        ],
                        "correctAnswer": 0,
                        "explanation": "Finds the smallest convex polygon containing all points."
                    }
                ]
            },
            {
                "id": "d78",
                "title": "78. Randomized Algorithms",
                "duration": "20 mins",
                "content": "# üé≤ Randomization\n\nAlgorithms that use a degree of randomness to achieve good average-case performance (e.g., Randomized QuickSort).",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Randomized pivot benefit?",
                        "options": [
                            "Always O(n)",
                            "Avoids O(n^2) worst case on sorted data"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Makes worst cases extremely unlikely."
                    }
                ]
            },
            {
                "id": "d79",
                "title": "79. Amortized Analysis",
                "duration": "25 mins",
                "content": "# üìà Amortized Analysis\n\nFinding the average time per operation over a sequence of operations (e.g., dynamic array resizing).",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Dynamic array push (average)?",
                        "options": [
                            "O(1)",
                            "O(n)"
                        ],
                        "correctAnswer": 0,
                        "explanation": "Individual O(n) resizes are averaged over many O(1) ops."
                    }
                ]
            },
            {
                "id": "d80",
                "title": "80. DSA Interview Patterns",
                "duration": "40 mins",
                "content": "# üéì The Master Map\n\nReviewing high-level patterns:\n1. Sliding Window\n2. Two Pointers\n3. Fast/Slow Pointers\n4. Merge Intervals\n5. Cyclic Sort\n6. Tree/Graph BFS/DFS\n7. DP (Knapsack, LCS)\n8. Bitwise common patterns.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Consistency is key?",
                        "options": [
                            "Yes",
                            "Maybe"
                        ],
                        "correctAnswer": 0,
                        "explanation": "Practicing these 80 lessons will make you job-ready!"
                    }
                ]
            }
        ]
    }
]