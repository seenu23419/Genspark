[
    {
        "id": "dsa-l1",
        "title": "LEVEL 1: Foundations & Complexity",
        "subtitle": "Master the fundamentals of efficiency.",
        "lessons": [
            {
                "id": "d1",
                "title": "1. Introduction to DSA",
                "duration": "15 mins",
                "content": "### What is DSA?\r\nData Structures and Algorithms (DSA) are the building blocks of efficient software. A **Data Structure** is a way of organizing and storing data so it can be accessed and modified efficiently. An **Algorithm** is a step-by-step procedure to solve a problem.\r\n\r\n### Why Study DSA?\r\n- **Efficiency:** Solve complex problems with minimal time and memory.\r\n- **Problem Solving:** Develop a logical mindset for engineering.\r\n- **Interviews:** Core topic for top-tier tech companies like Google and Meta.\r\n\r\n--- \r\n### Example: Searching for a Number\r\nImagine you have a phone book. A simple algorithm would be to check every page (**Linear Search**). A more efficient one would be to open the middle and eliminate half the pages (**Binary Search**).",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What is a Data Structure?",
                        "options": [
                            "A way to organize and store data",
                            "A programming language",
                            "A hardware component",
                            "An operating system"
                        ],
                        "correctAnswer": 0,
                        "explanation": "Data structures are specialized formats for organizing, processing, retrieving and storing data."
                    }
                ]
            },
            {
                "id": "d2",
                "title": "2. Big O Notation",
                "duration": "25 mins",
                "content": "### Understanding Efficiency\r\nIn DSA, we don't measure time in seconds (as different hardware varies). Instead, we use **Big O Notation** to describe how the runtime grows as the input size (n) grows.\r\n\r\n### Common Time Complexities\r\n- **O(1):** Constant time (fastest)\r\n- **O(log n):** Logarithmic time (very efficient)\r\n- **O(n):** Linear time (proportional to input)\r\n- **O(n^2):** Quadratic time (nested loops, slow for large n)",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Which notation is used to describe the worst-case time complexity?",
                        "options": [
                            "Big Omega",
                            "Big O",
                            "Big Theta"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Big O notation specifically describes the upper bound or worst-case scenario of an algorithm."
                    }
                ]
            }
        ],
        "problems": [
            {
                "id": "dsa_p1",
                "title": "Complexity Analysis Quiz",
                "description": "Calculate the Big O of various code snippets.",
                "difficulty": "easy"
            }
        ]
    },
    {
        "id": "dsa-l2",
        "title": "LEVEL 2: Linear Data Structures",
        "subtitle": "Arrays, Stacks, and Queues.",
        "lessons": [
            {
                "id": "d3",
                "title": "3. Array Operations",
                "duration": "20 mins",
                "content": "### Arrays in Memory\r\nArrays are contiguous blocks of memory. Accessing an element by index is **O(1)**.\r\n\r\n### Common Operations\r\n- **Insertion:** O(n) (may require shifting)\r\n- **Deletion:** O(n)\r\n- **Search:** O(n) for unsorted, O(log n) for sorted.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What is the time complexity of accessing an element in an array by its index?",
                        "options": [
                            "O(1)",
                            "O(n)",
                            "O(log n)"
                        ],
                        "correctAnswer": 0,
                        "explanation": "Because arrays are contiguous, the memory address can be calculated instantly."
                    }
                ]
            }
        ],
        "problems": [
            {
                "id": "dsa_p2",
                "title": "Array Reversal",
                "description": "Reverse an array in-place with O(1) space.",
                "difficulty": "medium"
            }
        ]
    }
]