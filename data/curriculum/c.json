[
    {
        "id": "c-l1",
        "title": "LEVEL 1: Introduction",
        "lessons": [
            {
                "id": "c1",
                "title": "1. Introduction to C",
                "duration": "15 mins",
                "content": "# üöÄ Introduction to C\n\n> **Welcome to C Programming!** Your journey to becoming a powerful programmer starts here. C is the foundation of modern computing.\n\n---\n\n## What is C?\n\nC is a general-purpose, low-level programming language created to make computers do exactly what you want.\n\n- **General-purpose** ‚Üí Used for almost any type of software\n- **Low-level** ‚Üí Close to hardware, giving you control\n- **Fast & Efficient** ‚Üí Programs run at lightning speed\n- **Portable** ‚Üí Write once, run anywhere\n\n> C has been closely associated with the UNIX system where it was developed, since both the system and most of the programs that run on it are written in C.\n\n---\n\n## History of C Language\n\n- **Created by:** Dennis Ritchie at AT&T Bell Labs (1972)\n- **Purpose:** To overcome limitations of earlier languages (B, BCPL)\n- **First Use:** Building the UNIX operating system\n- **Legacy:** Still one of the most popular languages today\n\n> Dennis Ritchie is known as the founder of C language and his creation revolutionized computer science.\n\n---\n\n## Why Learn C?\n\n### C is a Core Language\nIn computing, C is the foundational language that teaches you how computers really work.\n\n### C is Small & Simple\n- Only 32 keywords (most languages have 50+)\n- Simple to learn, powerful to use\n- Easy to remember the basics\n\n### C is Fast\n- No \\\"middleman\\\" software slowing you down\n- Direct access to computer hardware\n- Perfect for performance-critical applications\n\n### C is Portable\n- Write code once on Windows\n- Run it unchanged on Mac or Linux\n- Works on phones, IoT devices, supercomputers\n\n---\n\n## Key Features of C\n\n- **Fast Execution** ‚Üí Runs at maximum speed\n- **Portable** ‚Üí Works across different systems\n- **Structured** ‚Üí Clean, organized code\n- **Low-level Access** ‚Üí Total control over memory\n- **Beginner Friendly** ‚Üí Simple syntax, powerful concepts\n\n---\n\n## Real-World Applications\n\n### Operating Systems\n- Linux Kernel\n- Windows Core\n- macOS Foundation\n\n*C powers the software on billions of devices*\n\n### Embedded Systems\n- Cars & Automobiles\n- Medical Devices\n- Smart Home Appliances\n\n*C runs the tiny computers inside everyday devices*\n\n### High-Performance Software\n- Databases (MySQL, Oracle)\n- Game Engines\n- Compilers & Interpreters\n\n*C handles millions of operations per second*\n\n### Software Development Tools\n- Compilers\n- Text Editors\n- Version Control Systems\n\n*Tools you use are often built with C*\n\n---\n\n## What You'll Learn\n\nIn this C journey, you'll master:\n\n- **Fundamentals** ‚Üí Variables, Data Types, Operators\n- **Control Flow** ‚Üí Decision Making, Loops\n- **Functions** ‚Üí Modular, Reusable Code\n- **Arrays & Strings** ‚Üí Handling Collections of Data\n- **Pointers** ‚Üí Advanced Memory Management\n- **Structures** ‚Üí Organizing Complex Data\n- **File Handling** ‚Üí Reading & Writing Files\n\n---\n\n## Your Next Steps\n\n**Start with:** Keywords and Identifiers\n**Master:** The building blocks of every C program\n**Then:** Build your first real program\n\n> *\\\"The way to get started is to quit talking and begin doing.\\\" ‚Äî Walt Disney*\n\nReady? Let's code!",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Who is the creator of the C programming language?",
                        "options": [
                            "James Gosling",
                            "Bjarne Stroustrup",
                            "Dennis Ritchie",
                            "Guido van Rossum"
                        ],
                        "correctAnswer": 2,
                        "explanation": "Dennis Ritchie created C in 1972 at AT&T Bell Labs as a successor to the B language."
                    },
                    {
                        "id": 2,
                        "text": "C is described as a \"low-level\" language. What does this mean?",
                        "options": [
                            "It is difficult to learn",
                            "It is close to computer hardware",
                            "It only runs on small devices",
                            "It has very few keywords"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Low-level languages are close to hardware and provide direct memory access and control, unlike high-level languages."
                    },
                    {
                        "id": 3,
                        "text": "Which operating system was originally developed using the C language?",
                        "options": [
                            "Windows",
                            "Linux",
                            "macOS",
                            "UNIX"
                        ],
                        "correctAnswer": 3,
                        "explanation": "UNIX was originally developed using C. Later, Linux (inspired by UNIX) was also written in C."
                    },
                    {
                        "id": 4,
                        "text": "How many keywords does the C programming language have?",
                        "options": [
                            "16",
                            "25",
                            "32",
                            "50"
                        ],
                        "correctAnswer": 2,
                        "explanation": "C has exactly 32 keywords, making it a small and simple language compared to other modern languages."
                    },
                    {
                        "id": 5,
                        "text": "Which of the following is NOT a real-world application of C?",
                        "options": [
                            "Embedded systems in cars",
                            "Game engines",
                            "Linux kernel",
                            "Web page styling (CSS)"
                        ],
                        "correctAnswer": 3,
                        "explanation": "CSS is a markup language used for web styling, not a C application. The other three are indeed built with C."
                    }
                ]
            },
            {
                "id": "c2",
                "title": "2. Keywords and Identifiers",
                "duration": "20 mins",
                "content": "# C Keywords\n\nKeywords in C are reserved words that have a fixed meaning defined by the language itself.\n\nYou cannot use them as variable names, function names, or identifiers. The compiler already understands exactly what each keyword represents and how it should behave.\n\n**Important:** All C keywords must be written in lowercase. Using uppercase or mixed case will not work and will be treated as normal identifiers.\n\n## What Keywords Do\n\nKeywords are used to:\n- Declare variables with specific data types\n- Control program flow (loops, conditions)\n- Manage memory and storage behavior\n- Organize code structure\n- Give special instructions to the compiler\n\nBecause their meanings are predefined, keywords cannot be redefined or repurposed by the programmer.\n\n---\n\n## Data Type Keywords (9 total)\n\nThese keywords specify what type of data a variable can hold:\n\n**Primitive Types:**\n- `char` ‚Üí Single character\n- `int` ‚Üí Whole number\n- `float` ‚Üí Decimal (fast)\n- `double` ‚Üí Decimal (precise)\n- `void` ‚Üí No value\n\n**Modifiers:**\n- `signed` ‚Üí Can be negative\n- `unsigned` ‚Üí No negative\n- `short` ‚Üí Small number\n- `long` ‚Üí Large number\n\n## Control Flow Keywords (12 total)\n\nThese keywords control how your program runs:\n\n**Decisions:**\n- `if` ‚Üí If true\n- `else` ‚Üí Otherwise\n- `switch` ‚Üí Multiple choice\n- `case` ‚Üí One choice\n- `default` ‚Üí Fallback choice\n\n**Loops:**\n- `for` ‚Üí Count-based\n- `while` ‚Üí Repeat while true\n- `do` ‚Üí Repeat once first\n\n**Jump:**\n- `break` ‚Üí Exit loop\n- `continue` ‚Üí Skip iteration\n- `goto` ‚Üí Jump to label\n- `return` ‚Üí Exit function\n\n## Storage & Scope Keywords (8 total)\n\nThese keywords manage memory and scope:\n\n- `auto` ‚Üí Automatic (default)\n- `static` ‚Üí Keep between calls\n- `extern` ‚Üí From other file\n- `register` ‚Üí In CPU memory\n- `const` ‚Üí Cannot change\n- `volatile` ‚Üí Changes outside\n- `restrict` ‚Üí Pointer hint\n- `inline` ‚Üí Inline function\n\n## Structure Keywords (5 total)\n\nThese keywords organize data:\n\n- `struct` ‚Üí Group types\n- `union` ‚Üí Shared memory\n- `enum` ‚Üí Named constants\n- `typedef` ‚Üí New type name\n- `sizeof` ‚Üí Size in bytes\n\n## All 32 Keywords Summary\n\n**Total:** 32 keywords\n\n**By Category:**\n- Data Types: 9\n- Control Flow: 12\n- Storage/Scope: 8\n- Structure: 5\n\n---\n\n# C Identifiers\n\nIdentifiers are the names you create to identify different elements in a C program.\n\nThey are used for variables, functions, arrays, or structures. These names are created by you (the programmer) and are always declared using C keywords.\n\n## Rules for Writing C Identifiers\n\nFollow these rules when creating identifiers:\n\n**1. Characters Allowed**\nAn identifier can only contain:\n- Letters: a‚Äìz, A‚ÄìZ\n- Digits: 0‚Äì9\n- Underscore: _\n\n**2. No Leading Digits**\nAn identifier must NOT start with a digit.\n- ‚úÖ Valid: `number`, `_count`, `var1`\n- ‚ùå Invalid: `9number`, `1stValue`\n\n**3. Case Sensitive**\nIdentifiers are case-sensitive. `number` and `Number` are two different names.\n\n**4. No Special Characters**\nDo NOT use special characters: `@`, `#`, `$`, `!`, or spaces.\n- ‚úÖ Valid: `myVar`, `count1`, `_value`\n- ‚ùå Invalid: `my var`, `my-count`, `value$`\n\n## Valid Identifier Examples\n\nThese are all valid identifiers:\n- `number`\n- `_money`\n- `_student_`\n- `car1234`\n- `home321_`\n\n## How Keywords and Identifiers Work Together\n\nWhen you declare a variable, you use:\n- A **keyword** to specify the data type\n- An **identifier** as the variable name\n\n**Example 1:**\n```c\nint number;\n```\nHere:\n- `int` is a keyword (data type)\n- `number` is an identifier (variable name)\n\n**Example 2:**\n```c\nlong value;\n```\nHere:\n- `long` is a keyword (data type)\n- `value` is an identifier (variable name)\n\n**Example 3:**\n```c\nchar ch10;\n```\nHere:\n- `char` is a keyword (data type)\n- `ch10` is an identifier (variable name)",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What are keywords in C?",
                        "options": [
                            "Names created by programmers",
                            "Reserved words with predefined meanings",
                            "User-defined variable names",
                            "File names used by the compiler"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Keywords are reserved words in C that have fixed meanings defined by the language. They cannot be used as variable or function names."
                    },
                    {
                        "id": 2,
                        "text": "Which rule is correct regarding C keywords?",
                        "options": [
                            "They can be written in uppercase",
                            "They can be used as variable names",
                            "They must be written in lowercase",
                            "They can be redefined by the programmer"
                        ],
                        "correctAnswer": 2,
                        "explanation": "All C keywords must be written in lowercase. Using uppercase or mixed case will not work and will be treated as normal identifiers by the compiler."
                    },
                    {
                        "id": 3,
                        "text": "Which of the following is a data type keyword in C?",
                        "options": [
                            "for",
                            "struct",
                            "int",
                            "return"
                        ],
                        "correctAnswer": 2,
                        "explanation": "int is a data type keyword used to declare integer variables. for and return are control flow keywords, struct is a structure keyword."
                    },
                    {
                        "id": 4,
                        "text": "Which of the following identifiers is INVALID in C?",
                        "options": [
                            "value",
                            "car123",
                            "9number",
                            "home321"
                        ],
                        "correctAnswer": 2,
                        "explanation": "Identifiers cannot start with a digit. '9number' is invalid because it begins with the digit 9. Identifiers must start with a letter or underscore."
                    },
                    {
                        "id": 5,
                        "text": "In the declaration char ch10;, which statement is correct?",
                        "options": [
                            "char is an identifier and ch10 is a keyword",
                            "char is a keyword and ch10 is an identifier",
                            "Both are keywords",
                            "Both are identifiers"
                        ],
                        "correctAnswer": 1,
                        "explanation": "char is a keyword (data type), and ch10 is an identifier (variable name). Keywords define what type of data the variable will hold, while identifiers are the names we create."
                    }
                ]
            },
            {
                "id": "c3",
                "title": "3. Variables and Constants",
                "duration": "25 mins",
                "content": "# C Variables\n\nA variable is a named memory location used to store a value. When you need to save a value and use it again later in the program, you store it in a variable.\n\nIn short: variables hold data that your program works with.\n\n---\n\n## Syntax for Declaring Variables\n\n```c\n<datatype> <variable1>, <variable2>, <variable3>, ..., <variableN>;\n```\n\nint a, b;\n\nThe datatype tells the compiler what kind of data the variable will store, and the variable name identifies that storage location.\n\n---\n\n## Rules for Variable Names\n\nSince a variable name is an identifier, all identifier rules apply:\n1.  **Characters Allowed**: A variable name can contain only letters (a‚Äìz, A‚ÄìZ), digits (0‚Äì9), and underscore (_).\n2.  **No Leading Digits**: A variable name cannot begin with a digit. (Example: `9mark` is invalid).\n3.  **Case Sensitivity**: Variable names are case-sensitive, so `number` and `Number` are considered different variables.\n4.  **No Special Characters**: Special characters and spaces are not allowed.\n\n---\n\n## Example Declarations\n\n```c\nint number;\n```\nHere, `int` is the datatype, and `number` is a variable that stores integer values.\n\n```c\nlong marks, total;\n```\n`long` declares two variables, `marks` and `total`.\n\n```c\nchar ch10;\n```\n`char` declares a variable `ch10` for storing a single character.\n\n**Bottom line**: datatype defines the data, variable name identifies where it is stored.\n\n---\n\n# C Constants\n\nConstants are fixed values whose value cannot be changed during program execution. Once a constant is defined, its value remains the same throughout the program.\n\nUse constants when a value should stay unchanged, such as limits, fixed numbers, or configuration values.\n\n---\n\n## Ways to Define Constants in C\n\nThere are two main ways to define constants in C.\n\n### 1. Using const Keyword\n\nWhen a variable is declared using `const`, its value cannot be modified later.\n\n**Syntax:**\n```c\nconst <datatype> <constant_name> = value;\n```\n\n**Example:**\n```c\nconst int max = 100;\n```\nHere, `max` is a constant integer. Any attempt to change its value will cause a compiler error.\n\n```c\nconst float pi = 3.14;\n```\nHere, `pi` is a constant of type float.\n\n### 2. Using #define Preprocessor Directive\n\n`#define` is used to create symbolic constants. It does not allocate memory; it simply replaces the name with the value during compilation.\n\n**Syntax:**\n```c\n#define CONSTANT_NAME value\n```\n\n**Example:**\n```c\n#define SIZE 50\n#define PI 3.14159\n```\n\n---\n\n## Rules for Constant Names\n\n- Constant names follow identifier rules.\n- By convention, constants defined using `#define` are written in uppercase (not mandatory, but recommended).\n- Constant values cannot be modified after definition.\n\n---\n\n## Example Program\n\n```c\n#include <stdio.h>\n\n#define LIMIT 10\n\nint main() {\n    const int max = 100;\n    printf(\"%d %d\", LIMIT, max);\n    return 0;\n}\n```\n\n### üí° How it Works?\n\n> **Line 1 & 3**: We include `stdio.h` and define a Macro `LIMIT` as 10 via `#define`.\n> **Line 6**: `const int max` creates a constant variable that cannot be changed later.\n> **Line 7**: `printf` uses `%d` placeholders to display the values of `LIMIT` and `max` on screen.\n\n### üíª Expected Output\n\n```text\n10 100\n```",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What is a variable in C?",
                        "options": [
                            "A fixed value that cannot change",
                            "A named memory location used to store data",
                            "A keyword used to control loops",
                            "A compiler instruction"
                        ],
                        "correctAnswer": 1,
                        "explanation": "A variable is a named memory location that holds data which can change during program execution."
                    },
                    {
                        "id": 2,
                        "text": "Which of the following variable names is INVALID in C?",
                        "options": [
                            "total_marks",
                            "number1",
                            "9count",
                            "_value"
                        ],
                        "correctAnswer": 2,
                        "explanation": "Identifiers cannot begin with a digit; '9count' is invalid."
                    },
                    {
                        "id": 3,
                        "text": "Which statement correctly declares multiple variables of type long?",
                        "options": [
                            "long = marks, total;",
                            "long marks total;",
                            "long marks, total;",
                            "marks, total long;"
                        ],
                        "correctAnswer": 2,
                        "explanation": "Use 'long marks, total;' to declare multiple variables of type long."
                    },
                    {
                        "id": 4,
                        "text": "What happens if you try to modify a variable declared using the const keyword?",
                        "options": [
                            "The value changes successfully",
                            "The program runs but gives wrong output",
                            "The compiler produces an error",
                            "The value changes only once"
                        ],
                        "correctAnswer": 2,
                        "explanation": "A 'const' variable is read-only; attempting to change it leads to a compile-time error."
                    },
                    {
                        "id": 5,
                        "text": "Which statement about #define is TRUE?",
                        "options": [
                            "It allocates memory for the constant",
                            "It replaces the name with the value during compilation",
                            "It works only with integer values",
                            "It must always be written in lowercase"
                        ],
                        "correctAnswer": 1,
                        "explanation": "#define is a preprocessor directive that replaces the name with its value during compilation; it does not allocate memory."
                    }
                ]
            },
            {
                "id": "c4",
                "title": "4. C Data Types",
                "duration": "30 mins",
                "content": "# C Data Types\n\nA data type is a C keyword that tells the compiler what kind of data a variable will store.\nWithout a data type, the compiler has no idea how much memory to allocate or how to interpret the stored value.\n\nA data type gives the compiler two critical pieces of information:\n1. **Size of the data** (how much memory is required)\n2. **Type of the data** (integer, decimal, character, etc.)\n\nBased on this, the compiler knows how to store, read, and modify the data.\n\n---\n\n## Categories of Data Types in C\n\nC data types are mainly divided into two categories:\n1. **Basic (Primitive) Data Types**\n2. **User-Defined Data Types**\n\n---\n\n## 1. Basic / Primitive Data Types\n\nThese are the fundamental data types provided by C.\n\n### üî• int (Integer)\n\n‚Ä¢ **Size**: 4 bytes (32 bits)\n\n‚Ä¢ **Range**: -2,147,483,648 to 2,147,483,647\n\n‚Ä¢ **Purpose**: Used to store whole numbers (no decimal part)\n\n‚Ä¢ **Examples**: `-10, 0, 25, 1000, 45000`\n\n**Example code:**\n```c\nint age = 21;\nint score = -5;\nint max_value = 2147483647;\n```\n\n---\n\n### ‚ö° float (Single Precision Decimal)\n\n‚Ä¢ **Size**: 4 bytes (32 bits)\n\n‚Ä¢ **Range**: Approximately ¬±3.4e-38 to ¬±3.4e+38\n\n‚Ä¢ **Precision**: 6-7 significant digits\n\n‚Ä¢ **Purpose**: Used to store decimal numbers with lower precision\n\n‚Ä¢ **Examples**: `3.14f, -0.5f, 99.99f`\n\n**Example code:**\n```c\nfloat temperature = 36.5;\nfloat price = 19.99f;\nfloat pi = 3.14f;\n```\n\n---\n\n### üí† double (Double Precision Decimal)\n\n‚Ä¢ **Size**: 8 bytes (64 bits)\n\n‚Ä¢ **Range**: Approximately ¬±1.7e-308 to ¬±1.7e+308\n\n‚Ä¢ **Precision**: 15-17 significant digits\n\n‚Ä¢ **Purpose**: Used to store decimal numbers with HIGH precision\n\n‚Ä¢ **Examples**: `3.1415926535, 12345.678912, 9.99999`\n\n**Example code:**\n```c\ndouble distance = 12345.6789;\ndouble pi = 3.14159265;\ndouble scientific_value = 1.23e-5;\n```\n\n---\n\n### üìù char (Single Character)\n\n‚Ä¢ **Size**: 1 byte (8 bits)\n\n‚Ä¢ **Range**: -128 to 127 (ASCII characters)\n\n‚Ä¢ **Purpose**: Used to store single characters or small integer values\n\n‚Ä¢ **Examples**: `'A', 'z', '@', '9', '\\n'`\n\n**Example code:**\n```c\nchar grade = 'A';\nchar symbol = '@';\nchar digit = '5';\nchar newline = '\\n';\n```\n\n---\n\n### üî≥ void (No Value)\n\n‚Ä¢ **Size**: No size (represents absence of value)\n\n‚Ä¢ **Purpose**: Used to specify that a function does not return any value\n\n‚Ä¢ **Usage**: Common in function return types\n\n**Example code:**\n```c\nvoid displayMessage() {\n    printf(\"Hello\");\n}\n```\n\n---\n\n## Size of Data Types\n\nYou can check the size using the `sizeof()` operator:\n\n```c\nprintf(\"int size: %d bytes\\n\", sizeof(int));\nprintf(\"float size: %d bytes\\n\", sizeof(float));\nprintf(\"double size: %d bytes\\n\", sizeof(double));\nprintf(\"char size: %d byte\\n\", sizeof(char));\n```\n\n### üíª Expected Output\n\n```text\nint size: 4 bytes\nfloat size: 4 bytes\ndouble size: 8 bytes\nchar size: 1 byte\n```\n\n---\n\n## Data Types Summary Table\n\n| Type | Size | Range | Purpose | Examples |\n|------|------|-------|---------|----------|\n| **int** | 4 bytes | -2,147,483,648 to 2,147,483,647 | Whole numbers | -10, 0, 25, 1000 |\n| **float** | 4 bytes | ¬±3.4e-38 to ¬±3.4e+38 | Decimal (6-7 digits) | 3.14f, 99.99f |\n| **double** | 8 bytes | ¬±1.7e-308 to ¬±1.7e+308 | Decimal (15-17 digits) | 3.14159, 12345.6789 |\n| **char** | 1 byte | -128 to 127 (ASCII) | Single character | 'A', '@', '9' |\n| **void** | N/A | No value | Function return type | N/A |\n\n---\n\n## 2. User-Defined & Derived Data Types\n\nThese types are created using basic data types to organize and manage data more effectively.\n\n### üìä Array\nAn array stores multiple values of the same data type in continuous memory locations.\n\n**Example:**\n```c\nint scores[5] = {90, 85, 88, 92, 76};\n```\nHere, `scores` stores 5 integer values.\n\n```c\nchar city[15] = \"Hyderabad\";\n```\nHere, `city` stores multiple characters as a string.\n\n### üèóÔ∏è Structure\nA structure allows grouping different data types under one name.\n\n**Example:**\n```c\nstruct Student {\n    int roll_no;\n    char grade;\n    float percentage;\n};\n\nstruct Student s1;\n```\n\n### ü§ù Union\nA union is similar to a structure, but all members share the same memory location. At any time, only one member can store a value.\n\n**Example:**\n```c\nunion Data {\n    int number;\n    float value;\n    char symbol;\n};\n\nunion Data d;\n```\n\n### üñãÔ∏è Pointer\nA pointer is a variable that stores the memory address of another variable rather than a direct value.\n\n**Example:**\n```c\nint a = 10;\nint *p = &a;  // p stores the memory address of a\n```\n\n### üé® Enum (Enumeration)\nEnums are used to define a set of named integer constants, making code more readable.\n\n**Example:**\n```c\nenum Level { LOW, MEDIUM, HIGH };\nenum Level myLevel = MEDIUM; // stores value 1\n```",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What is the main purpose of a data type in C?",
                        "options": [
                            "To name a variable",
                            "To decide program speed",
                            "To tell the compiler the size and type of data",
                            "To control program flow"
                        ],
                        "correctAnswer": 2,
                        "explanation": "Data types inform the compiler how much memory to allocate (size) and how to interpret the stored bits (type, e.g., integer vs float)."
                    },
                    {
                        "id": 2,
                        "text": "Which data type is used to store decimal values with HIGH precision?",
                        "options": [
                            "int",
                            "float",
                            "double",
                            "char"
                        ],
                        "correctAnswer": 2,
                        "explanation": "The 'double' type provides 15-17 significant digits of precision, making it more accurate than 'float' for complex calculations."
                    },
                    {
                        "id": 3,
                        "text": "What is the size of the char data type in C?",
                        "options": [
                            "2 bytes",
                            "4 bytes",
                            "8 bytes",
                            "1 byte"
                        ],
                        "correctAnswer": 3,
                        "explanation": "In C, a character (char) always occupies exactly 1 byte (8 bits) of memory."
                    },
                    {
                        "id": 4,
                        "text": "Which of the following correctly describes a union in C?",
                        "options": [
                            "Stores multiple values in separate memory locations",
                            "Stores only integer values",
                            "All members share the same memory location",
                            "Used only for loops"
                        ],
                        "correctAnswer": 2,
                        "explanation": "A union is a special data type where all members share the same memory space, allowing only one member to store a value at any given time."
                    },
                    {
                        "id": 5,
                        "text": "In the code int *p = &a;, what does the pointer p store?",
                        "options": [
                            "The value of a",
                            "The data type of a",
                            "The memory address of a",
                            "The size of a"
                        ],
                        "correctAnswer": 2,
                        "explanation": "A pointer is a variable that stores the memory address (&operator) of another variable."
                    }
                ]
            },
            {
                "id": "c5",
                "title": "5. C Input/Output",
                "duration": "25 mins",
                "content": "# C Input / Output (I/O)\n\nIn C, input and output refer to how a program receives data and produces results.\n\n## Input\n\nData can be given to a program in multiple ways:\n- From the keyboard (console input)\n- From a file\n- From other sources (advanced cases)\n\n## Output\n\nProgram results can be sent to:\n- The screen (console output)\n- A file\n- Other devices\n\nFor beginners, the most common and basic method is:\n- **Read input from the keyboard**\n- **Display output on the screen**\n\nThat's what we'll focus on here.\n\n---\n\n## Displaying Output on the Screen\n\nC provides library functions to print data on the console, such as:\n- `printf()`\n- `putchar()`\n- `putc()`\n\nIn real programs, `printf()` is used most of the time.\n\n### printf() Function\n\n**Syntax:**\n```c\nprintf(format_string, variable_list);\n```\n\n- `format_string` specifies how the output should appear\n- `variable_list` contains the variables whose values will be printed\n\n**Common format specifiers:**\n- `%d` ‚Üí integer\n- `%f` ‚Üí float\n- `%c` ‚Üí character\n- `%s` ‚Üí string\n\n### Examples of printf()\n\n**Example 1: Print an integer**\n```c\nint count = 5;\nprintf(\"Count = %d\", count);\n```\n\n**Example 2: Print a floating value**\n```c\nfloat price = 99.50;\nprintf(\"Price = %f\", price);\n```\n\n**Example 3: Print a character**\n```c\nchar grade = 'A';\nprintf(\"Grade = %c\", grade);\n```\n\n**Example 4: Print multiple values**\n```c\nint id = 10;\nfloat salary = 25000.75;\nprintf(\"ID: %d Salary: %f\", id, salary);\n```\n\n---\n\n## Reading Input from Keyboard\n\nC also provides functions to read input from the keyboard:\n- `scanf()`\n- `getchar()`\n- `getc()`\n\nFor general input, `scanf()` is the most commonly used function.\n\n### scanf() Function\n\n**Syntax:**\n```c\nscanf(format_string, address_list);\n```\n\n**Key point:**\n`scanf()` needs the address of variables, so `&` (address operator) is used.\n\n### Examples of scanf()\n\n**Example 1: Read an integer**\n```c\nint age;\nscanf(\"%d\", &age);\n```\n\n**Example 2: Read a float**\n```c\nfloat marks;\nscanf(\"%f\", &marks);\n```\n\n**Example 3: Read a character**\n```c\nchar choice;\nscanf(\" %c\", &choice);   // space avoids newline issue\n```\n\n**Example 4: Read a string**\n```c\nchar name[20];\nscanf(\"%s\", name);\n```\n\n---\n\n## Complete Example Program\n\n```c\n#include <stdio.h>\n\nint main() {\n    int roll;\n    float percentage;\n\n    printf(\"Enter roll number: \");\n    scanf(\"%d\", &roll);\n\n    printf(\"Enter percentage: \");\n    scanf(\"%f\", &percentage);\n\n    printf(\"Roll: %d Percentage: %f\", roll, percentage);\n\n    return 0;\n}\n```\n\n### üí° How it Works?\n\n> **Line 4-5**: We declare an integer `roll` and a float `percentage` variable.\n> **Line 7-11**: `printf` displays a prompt to the user, and `scanf` reads the input from the keyboard. The `&` symbol is required in `scanf` to tell the computer where to store the data.\n> **Line 13**: The program prints the final results using format specifiers (`%d` and `%f`).\n\n### üíª Expected Output\n\n```text\nEnter roll number: 101\nEnter percentage: 85.5\nRoll: 101 Percentage: 85.500000\n```",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What does 'input' in C refer to?",
                        "options": [
                            "Displaying data on the screen",
                            "Saving data in memory",
                            "Receiving data into a program",
                            "Printing error messages"
                        ],
                        "correctAnswer": 2,
                        "explanation": "Input refers to the process of providing external data (e.g., from a keyboard) to a program for processing."
                    },
                    {
                        "id": 2,
                        "text": "Which function is most commonly used to display output on the screen in C?",
                        "options": [
                            "getchar()",
                            "scanf()",
                            "printf()",
                            "getc()"
                        ],
                        "correctAnswer": 2,
                        "explanation": "printf() is the standard formatted output function in C used to display data on the console."
                    },
                    {
                        "id": 3,
                        "text": "Which format specifier is used to print a floating-point value using printf()?",
                        "options": [
                            "%d",
                            "%c",
                            "%s",
                            "%f"
                        ],
                        "correctAnswer": 3,
                        "explanation": "%f is the standard format specifier used for floating-point values (float and double)."
                    },
                    {
                        "id": 4,
                        "text": "Why is the & (address operator) used with variables in scanf()?",
                        "options": [
                            "To print the variable",
                            "To increase speed",
                            "To pass the memory address of the variable",
                            "To format the output"
                        ],
                        "correctAnswer": 2,
                        "explanation": "The & operator provides the memory address of the variable, allowing scanf() to store the user input directly into that location."
                    },
                    {
                        "id": 5,
                        "text": "Which function is commonly used to read input from the keyboard in C?",
                        "options": [
                            "printf()",
                            "putchar()",
                            "scanf()",
                            "putc()"
                        ],
                        "correctAnswer": 2,
                        "explanation": "scanf() is the primary function in C for reading formatted input from the standard input (keyboard)."
                    }
                ]
            },
            {
                "id": "c6",
                "title": "6. C Operators",
                "duration": "35 mins",
                "content": "# C Operators\n\nOperators are special symbols used to perform operations on variables and values. In C, operators allow you to calculate numbers, compare values, and control logic.\n\n---\n\n## 1. Arithmetic Operators\n\nThese are used for basic mathematical operations.\n\n### üî• Addition (+)\n\n‚Ä¢ **Purpose**: Add two numbers\n\n‚Ä¢ **Syntax**: `a + b`\n\n‚Ä¢ **Example**: `10 + 5 = 15`\n\n```c\nint sum = 20 + 30;  // sum = 50\n```\n\n### ‚ö° Subtraction (-)\n\n‚Ä¢ **Purpose**: Subtract second from first\n\n‚Ä¢ **Syntax**: `a - b`\n\n‚Ä¢ **Example**: `10 - 5 = 5`\n\n```c\nint diff = 20 - 8;  // diff = 12\n```\n\n### üí† Multiplication (*)\n\n‚Ä¢ **Purpose**: Multiply two numbers\n\n‚Ä¢ **Syntax**: `a * b`\n\n‚Ä¢ **Example**: `10 * 5 = 50`\n\n```c\nint prod = 7 * 6;   // prod = 42\n```\n\n### üìù Division (/)\n\n‚Ä¢ **Purpose**: Divide first by second\n\n‚Ä¢ **Syntax**: `a / b`\n\n‚Ä¢ **Note**: Integer division truncates decimals\n\n‚Ä¢ **Example**: `10 / 3 = 3` (not 3.33)\n\n```c\nint div = 20 / 4;   // div = 5\nfloat div2 = 20.0 / 4;  // div2 = 5.0\n```\n\n### ‚úÖ Modulus (%)\n\n‚Ä¢ **Purpose**: Get remainder after division\n\n‚Ä¢ **Syntax**: `a % b`\n\n‚Ä¢ **Example**: `10 % 3 = 1`\n\n```c\nint rem = 10 % 3;   // rem = 1\nint rem2 = 15 % 4;  // rem2 = 3\n```\n\n**Arithmetic Example:**\n```c\nint a = 20, b = 6;\nprintf(\"Addition: %d\\n\", a + b);      // 26\nprintf(\"Subtraction: %d\\n\", a - b);  // 14\nprintf(\"Multiplication: %d\\n\", a * b); // 120\nprintf(\"Division: %d\\n\", a / b);     // 3\nprintf(\"Modulus: %d\\n\", a % b);      // 2\n```\n\n### üíª Expected Output\n\n```text\nAddition: 26\nSubtraction: 14\nMultiplication: 120\nDivision: 3\nModulus: 2\n```\n\n---\n\n## 2. Relational (Comparison) Operators\n\nThese compare two values and return **1** (true) or **0** (false).\n\n### üî• Equal to (==)\n\n‚Ä¢ **Purpose**: Check if two values are equal\n\n‚Ä¢ **Syntax**: `a == b`\n\n‚Ä¢ **Example**: `5 == 5` returns 1 (true)\n\n```c\nint result = (10 == 10);  // result = 1\nint result2 = (10 == 5);  // result2 = 0\n```\n\n### ‚ö° Not Equal to (!=)\n\n‚Ä¢ **Purpose**: Check if two values are different\n\n‚Ä¢ **Syntax**: `a != b`\n\n‚Ä¢ **Example**: `5 != 10` returns 1 (true)\n\n```c\nint result = (10 != 5);   // result = 1\nint result2 = (10 != 10); // result2 = 0\n```\n\n### üí† Greater than (>)\n\n‚Ä¢ **Purpose**: Check if first is greater than second\n\n‚Ä¢ **Syntax**: `a > b`\n\n‚Ä¢ **Example**: `10 > 5` returns 1 (true)\n\n```c\nint result = (10 > 5);    // result = 1\nint result2 = (3 > 8);    // result2 = 0\n```\n\n### üìù Less than (<)\n\n‚Ä¢ **Purpose**: Check if first is less than second\n\n‚Ä¢ **Syntax**: `a < b`\n\n‚Ä¢ **Example**: `5 < 10` returns 1 (true)\n\n```c\nint result = (5 < 10);    // result = 1\nint result2 = (10 < 3);   // result2 = 0\n```\n\n### üì¶ Greater than or Equal to (>=)\n\n‚Ä¢ **Purpose**: Check if first >= second\n\n‚Ä¢ **Syntax**: `a >= b`\n\n‚Ä¢ **Example**: `10 >= 10` returns 1 (true)\n\n```c\nint result = (10 >= 10);  // result = 1\nint result2 = (8 >= 10);  // result2 = 0\n```\n\n### ‚úÖ Less than or Equal to (<=)\n\n‚Ä¢ **Purpose**: Check if first <= second\n\n‚Ä¢ **Syntax**: `a <= b`\n\n‚Ä¢ **Example**: `5 <= 10` returns 1 (true)\n\n```c\nint result = (5 <= 10);   // result = 1\nint result2 = (15 <= 10); // result2 = 0\n```\n\n**Relational Example:**\n```c\nint x = 5, y = 10;\nprintf(\"%d\\n\", x > y);   // 0\nprintf(\"%d\\n\", x < y);   // 1\n```\n\n### üíª Expected Output\n\n```text\n0\n1\n```\n\n---\n\n## 3. Logical Operators\n\nThese combine multiple conditions. Return **1** (true) or **0** (false).\n\n### üî• AND (&&)\n\n‚Ä¢ **Purpose**: Both conditions must be true\n\n‚Ä¢ **Syntax**: `condition1 && condition2`\n\n‚Ä¢ **Returns 1 if**: Both are true\n\n```c\nint a = 5, b = 10;\nif (a < b && b < 20) {    // true && true = true\n    printf(\"Both conditions met\");\n}\n```\n\n### ‚ö° OR (||)\n\n‚Ä¢ **Purpose**: At least one condition must be true\n\n‚Ä¢ **Syntax**: `condition1 || condition2`\n\n‚Ä¢ **Returns 1 if**: Any one is true\n\n```c\nint age = 16;\nif (age < 13 || age > 60) {  // false || false = false\n    printf(\"Special category\");\n}\n```\n\n### üí† NOT (!)\n\n‚Ä¢ **Purpose**: Reverse the condition\n\n‚Ä¢ **Syntax**: `!condition`\n\n‚Ä¢ **Returns 1 if**: Condition is false\n\n```c\nint isProgrammer = 1;\nif (!isProgrammer) {      // !1 = 0, so block won't execute\n    printf(\"Not a programmer\");\n}\n```\n\n### üíª Expected Output\n\n```text\nBoth conditions met\n```\n\n**Truth Table:**\n```\nA     B     A && B    A || B    !A\n1     1       1         1       0\n1     0       0         1       0\n0     1       0         1       1\n0     0       0         0       1\n```\n\n---\n\n## 4. Assignment Operators\n\nThese assign values to variables.\n\n### üî• Simple Assignment (=)\n\n‚Ä¢ **Purpose**: Assign value to variable\n\n‚Ä¢ **Syntax**: `a = value`\n\n```c\nint x = 10;   // x gets value 10\n```\n\n### ‚ö° Add & Assign (+=)\n\n‚Ä¢ **Purpose**: Add and store result\n\n‚Ä¢ **Syntax**: `a += b` (same as `a = a + b`)\n\n```c\nint x = 10;\nx += 5;       // x = 10 + 5 = 15\n```\n\n### üí† Subtract & Assign (-=)\n\n‚Ä¢ **Purpose**: Subtract and store result\n\n‚Ä¢ **Syntax**: `a -= b` (same as `a = a - b`)\n\n```c\nint x = 20;\nx -= 5;       // x = 20 - 5 = 15\n```\n\n### üìù Multiply & Assign (*=)\n\n‚Ä¢ **Purpose**: Multiply and store result\n\n‚Ä¢ **Syntax**: `a *= b` (same as `a = a * b`)\n\n```c\nint x = 10;\nx *= 3;       // x = 10 * 3 = 30\n```\n\n### üì¶ Divide & Assign (/=)\n\n‚Ä¢ **Purpose**: Divide and store result\n\n‚Ä¢ **Syntax**: `a /= b` (same as `a = a / b`)\n\n```c\nint x = 20;\nx /= 4;       // x = 20 / 4 = 5\n```\n\n### ‚úÖ Modulus & Assign (%=)\n\n‚Ä¢ **Purpose**: Modulus and store result\n\n‚Ä¢ **Syntax**: `a %= b` (same as `a = a % b`)\n\n```c\nint x = 20;\nx %= 6;       // x = 20 % 6 = 2\n```\n\n**Assignment Example:**\n```c\nint a = 10, b = 2;\na += b;   // a = 12\nb *= a;   // b = 24\nprintf(\"a: %d, b: %d\", a, b);\n```\n\n### üíª Expected Output\n\n```text\na: 12, b: 24\n```\n\n---\n\n## 5. Increment & Decrement Operators\n\nThese change variable by 1.\n\n### üî• Pre-Increment (++a)\n\n‚Ä¢ **Purpose**: Increase by 1, then use value\n\n‚Ä¢ **Syntax**: `++a`\n\n```c\nint a = 5;\nint b = ++a;  // a becomes 6, then b = 6\n```\n\n### ‚ö° Post-Increment (a++)\n\n‚Ä¢ **Purpose**: Use value, then increase by 1\n\n‚Ä¢ **Syntax**: `a++`\n\n```c\nint a = 5;\nint b = a++;  // b = 5, then a becomes 6\n```\n\n### üí† Pre-Decrement (--a)\n\n‚Ä¢ **Purpose**: Decrease by 1, then use value\n\n‚Ä¢ **Syntax**: `--a`\n\n```c\nint a = 5;\nint b = --a;  // a becomes 4, then b = 4\n```\n\n### üìù Post-Decrement (a--)\n\n‚Ä¢ **Purpose**: Use value, then decrease by 1\n\n‚Ä¢ **Syntax**: `a--`\n\n```c\nint a = 5;\nint b = a--;  // b = 5, then a becomes 4\n```\n\n**Increment Example:**\n```c\nint i = 5;\nprintf(\"%d \", ++i);  // 6\nprintf(\"%d\", i++);   // 6\n```\n\n### üíª Expected Output\n\n```text\n6 6\n```\n\n---\n\n## 6. Bitwise Operators\n\nThese work on binary representations of numbers.\n\n### üî• AND (&)\n\n‚Ä¢ **Purpose**: Bitwise AND\n\n‚Ä¢ **Example**: `5 & 3 = 1` (0101 & 0011 = 0001)\n\n```c\nint result = 5 & 3;  // result = 1\n```\n\n### ‚ö° OR (|)\n\n‚Ä¢ **Purpose**: Bitwise OR\n\n‚Ä¢ **Example**: `5 | 3 = 7` (0101 | 0011 = 0111)\n\n```c\nint result = 5 | 3;  // result = 7\n```\n\n### üí† XOR (^)\n\n‚Ä¢ **Purpose**: Bitwise XOR\n\n‚Ä¢ **Example**: `5 ^ 3 = 6` (0101 ^ 0011 = 0110)\n\n```c\nint result = 5 ^ 3;  // result = 6\n```\n\n### üìù NOT (~)\n\n‚Ä¢ **Purpose**: Bitwise NOT (complement)\n\n‚Ä¢ **Example**: `~5 = -6`\n\n```c\nint result = ~5;     // result = -6\n```\n\n### üì¶ Left Shift (<<)\n\n‚Ä¢ **Purpose**: Shift bits left\n\n‚Ä¢ **Example**: `5 << 1 = 10` (shift left by 1 = multiply by 2)\n\n```c\nint result = 5 << 1; // result = 10\n```\n\n### ‚úÖ Right Shift (>>)\n\n‚Ä¢ **Purpose**: Shift bits right\n\n‚Ä¢ **Example**: `5 >> 1 = 2` (shift right by 1 = divide by 2)\n\n```c\nint result = 5 >> 1; // result = 2\n```\n\n**Bitwise Example:**\n```c\nint x = 5, y = 3;\nprintf(\"Result: %d\", x & y);\n```\n\n### üíª Expected Output\n\n```text\nResult: 1\n```\n\n---\n\n## 7. Ternary Conditional Operator\n\n### üî• ? : Operator\n\n‚Ä¢ **Purpose**: Choose between two values based on condition\n\n‚Ä¢ **Syntax**: `condition ? valueIfTrue : valueIfFalse`\n\n‚Ä¢ **Returns**: First value if true, second if false\n\n```c\nint age = 20;\nchar* status = (age >= 18) ? \"Adult\" : \"Minor\";\nprintf(\"%s\", status);  // Prints: Adult\n```\n\n### üíª Expected Output\n\n```text\nAdult\n```\n\n---\n\n## üöÄ Complete Operator Example\n\n```c\n#include <stdio.h>\n\nint main() {\n    int a = 15, b = 10;\n    \n    // Arithmetic\n    printf(\"Addition: %d\\n\", a + b);        // 25\n    printf(\"Modulus: %d\\n\", a % b);        // 5\n    \n    // Relational\n    printf(\"Greater: %d\\n\", a > b);        // 1 (true)\n    printf(\"Equal: %d\\n\", a == b);         // 0 (false)\n    \n    // Logical\n    printf(\"AND: %d\\n\", (a > b) && (b > 0)); // 1\n    printf(\"OR: %d\\n\", (a < b) || (b > 0)); // 1\n    printf(\"NOT: %d\\n\", !(a < b));          // 1\n    \n    // Ternary\n    int max = (a > b) ? a : b;\n    printf(\"Maximum: %d\\n\", max);          // 15\n    \n    return 0;\n}\n```\n\n### üí° How it Works?\n\n> **Arithmetic**: `a + b` calculates 25, while `a % b` finds the remainder (5).\n> **Relational**: Comparing `a > b` returns `1` because 15 is greater than 10.\n> **Logical**: `&&` combines conditions. Since both `a > b` and `b > 0` are true, it returns `1`.\n> **Ternary**: The `? :` operator efficiently picks the larger number between `a` and `b`.\n\n### üíª Expected Output\n\n```text\nAddition: 25\nModulus: 5\nGreater: 1\nEqual: 0\nAND: 1\nOR: 1\nNOT: 1\nMaximum: 15\n```\n\n---\n\n## Operator Precedence (Order of Execution)\n\n1. **Parentheses** `()`\n2. **Increment/Decrement** `++ --`\n3. **Multiplication, Division, Modulus** `* / %`\n4. **Addition, Subtraction** `+ -`\n5. **Relational** `< > <= >=`\n6. **Equality** `== !=`\n7. **Logical AND** `&&`\n8. **Logical OR** `||`\n9. **Ternary** `? :`\n10. **Assignment** `= += -= *= /= %=`",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What will be the output of the following C code?\n\n```c\nint a = 10, b = 3;\nprintf(\"%d, %d\", a / b, a % b);\n```",
                        "options": [
                            "3, 1",
                            "3.33, 1",
                            "3, 0",
                            "3.33, 0"
                        ],
                        "correctAnswer": 0,
                        "explanation": "In C, integer division 10/3 results in 3, and the modulus operator 10%3 returns the remainder 1. The output matches the format string \"%d, %d\"."
                    },
                    {
                        "id": 2,
                        "text": "What is the output of this expression?\n\n```c\nint a = 5, b = 10;\nprintf(\"%d\", a <= b);\n```",
                        "options": [
                            "0",
                            "5",
                            "10",
                            "1"
                        ],
                        "correctAnswer": 3,
                        "explanation": "The relational operator <= checks if a is less than or equal to b. Since 5 is less than 10, the result is 1 (true)."
                    },
                    {
                        "id": 3,
                        "text": "What will be the output?\n\n```c\nint a = 1, b = 0;\nprintf(\"%d\", a && b);\n```",
                        "options": [
                            "1",
                            "0",
                            "-1",
                            "Compilation Error"
                        ],
                        "correctAnswer": 1,
                        "explanation": "The logical AND (&&) returns 1 (true) only if BOTH operands are non-zero. Since b is 0, the result is 0."
                    },
                    {
                        "id": 4,
                        "text": "What will be printed?\n\n```c\nint a = 5;\nprintf(\"%d\", a++);\n```",
                        "options": [
                            "6",
                            "5",
                            "4",
                            "Error"
                        ],
                        "correctAnswer": 1,
                        "explanation": "The post-increment operator (a++) uses the current value (5) for the expression first, and then increments the variable to 6."
                    },
                    {
                        "id": 5,
                        "text": "What is the output of the following code?\n\n```c\nint a = 15, b = 10;\nint max = (a > b) ? a : b;\nprintf(\"%d\", max);\n```",
                        "options": [
                            "10",
                            "15",
                            "1",
                            "0"
                        ],
                        "correctAnswer": 1,
                        "explanation": "The ternary operator checks (15 > 10). Since it is true, it assigns the first value (a = 15) to max."
                    }
                ]
            }
        ]
    },
    {
        "id": "c-l2",
        "title": "LEVEL 2: Flow Control",
        "lessons": [
            {
                "id": "c7",
                "title": "7. if-else Statements",
                "duration": "30 mins",
                "content": "# C Decision Making (if-else)\n\nIn programming, we often need to execute different code based on specific conditions. This is called **Decision Making** or **Conditional Branching**.\n\nIn C, decisions are made using `if` and `else` statements. A condition always results in either **1 (True)** or **0 (False)**.\n\n---\n\n## 1. Simple if Statement\n\n### üî• Purpose\nExecutes a block of code **only if** the condition is true. If the condition is false, the block is skipped.\n\n### ‚ö° Syntax\n```c\nif (condition) {\n    // code executes ONLY if condition is true\n}\n```\n\n### üí† Example\n```c\nint age = 20;\n\nif (age >= 18) {\n    printf(\"Eligible to vote\\n\");\n}\n```\n\n### üíª Expected Output\n```text\nEligible to vote\n```\n\n**How it Works?**\n> Since `age` is 20, the condition `20 >= 18` is true. Therefore, the program enters the `if` block and prints the message.\n\n---\n\n## 2. if-else Statement\n\n### üî• Purpose\nUsed to choose between two options. If the condition is true, the `if` block runs; otherwise, the `else` block runs.\n\n### ‚ö° Syntax\n```c\nif (condition) {\n    // runs if true\n} else {\n    // runs if false\n}\n```\n\n### üí† Example\n```c\nint num = 5;\n\nif (num % 2 == 0) {\n    printf(\"Even number\\n\");\n} else {\n    printf(\"Odd number\\n\");\n}\n```\n\n### üíª Expected Output\n```text\nOdd number\n```\n\n**How it Works?**\n> The modulus operator (`%`) finds the remainder of `5 / 2`, which is 1. Since `1 == 0` is false, the program skips the `if` block and executes the `else` block.\n\n---\n\n## 3. else if Ladder\n\n### üî• Purpose\nUsed when you have multiple conditions to check. Once a true condition is found, its block executes and the rest are skipped.\n\n### ‚ö° Syntax\n```c\nif (condition1) {\n    // block 1\n} else if (condition2) {\n    // block 2\n} else {\n    // default block (if none match)\n}\n```\n\n### üí† Example\n```c\nint marks = 72;\n\nif (marks >= 90) {\n    printf(\"Grade A\\n\");\n} else if (marks >= 75) {\n    printf(\"Grade B\\n\");\n} else if (marks >= 50) {\n    printf(\"Grade C\\n\");\n} else {\n    printf(\"Fail\\n\");\n}\n```\n\n### üíª Expected Output\n```text\nGrade C\n```\n\n**How it Works?**\n> 1. `72 >= 90` is false.\n> 2. `72 >= 75` is false.\n> 3. `72 >= 50` is true! It prints \"Grade C\" and skips the final `else`.\n\n---\n\n## 4. Nested if-else\n\n### üî• Purpose\nAn `if` statement inside another `if` statement. Used for dependent conditions (e.g., check age, then check ID).\n\n### ‚ö° Example\n```c\nint age = 25;\nint has_id = 1;\n\nif (age >= 18) {\n    if (has_id == 1) {\n        printf(\"Entry allowed\\n\");\n    } else {\n        printf(\"ID required\\n\");\n    }\n} else {\n    printf(\"Underage\\n\");\n}\n```\n\n### üíª Expected Output\n```text\nEntry allowed\n```\n\n**How it Works?**\n> 1. The outer `if` checks `age >= 18` (true).\n> 2. The inner `if` checks `has_id == 1` (true).\n> 3. Since both are true, \"Entry allowed\" is printed.\n\n---\n\n## üöÄ Complete decision Making Example\n\n```c\n#include <stdio.h>\n\nint main() {\n    int number = -5;\n\n    if (number > 0) {\n        printf(\"Positive\\n\");\n    } else if (number < 0) {\n        printf(\"Negative\\n\");\n    } else {\n        printf(\"Zero\\n\");\n    }\n\n    return 0;\n}\n```\n\n### üíª Expected Output\n```text\nNegative\n```\n\n---\n\n## ‚ö†Ô∏è Important Rules\n\n1.  **Parentheses**: Always wrap conditions in `()`. \n2.  **Assignment vs Comparison**: Never use `=` (assign) inside an `if`. Always use `==` (compare).\n3.  **Indentation**: Always indent code inside `{}` so it's readable.\n4.  **Semicolons**: Do **NOT** put a semicolon after `if(condition)`. It will terminate the statement early!",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What will be the output of the following code?\n\n```c\nint age = 17;\nif(age >= 18)\n{\n    printf(\"Eligible\");\n}\n```",
                        "options": [
                            "Eligible",
                            "No output",
                            "17",
                            "Error"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Since age (17) is not greater than or equal to 18, the condition is false and the printf() statement inside the if block is skipped."
                    },
                    {
                        "id": 2,
                        "text": "What is the output?\n\n```c\nint num = 5;\nif(num % 2 == 0)\n    printf(\"Even\");\nelse\n    printf(\"Odd\");\n```",
                        "options": [
                            "Even",
                            "Odd",
                            "0",
                            "Error"
                        ],
                        "correctAnswer": 1,
                        "explanation": "5 % 2 is 1. Since 1 is not equal to 0, the condition is false and the else block executes, printing 'Odd'."
                    },
                    {
                        "id": 3,
                        "text": "What will be printed?\n\n```c\nint marks = 72;\n\nif(marks >= 90)\n    printf(\"Grade A\");\nelse if(marks >= 75)\n    printf(\"Grade B\");\nelse if(marks >= 50)\n    printf(\"Grade C\");\nelse\n    printf(\"Fail\");\n```",
                        "options": [
                            "Grade A",
                            "Grade B",
                            "Grade C",
                            "Fail"
                        ],
                        "correctAnswer": 2,
                        "explanation": "The program checks conditions top-to-bottom. 72 >= 90 (F), 72 >= 75 (F), 72 >= 50 (T). So 'Grade C' is printed and the rest are skipped."
                    },
                    {
                        "id": 4,
                        "text": "What is the output?\n\n```c\nint age = 20;\nint has_id = 1;\n\nif(age >= 18)\n{\n    if(has_id == 1)\n        printf(\"Entry allowed\");\n    else\n        printf(\"ID required\");\n}\n```",
                        "options": [
                            "Entry allowed",
                            "ID required",
                            "No output",
                            "Error"
                        ],
                        "correctAnswer": 0,
                        "explanation": "The outer if (20 >= 18) is true, and the inner if (1 == 1) is also true, so 'Entry allowed' is printed."
                    },
                    {
                        "id": 5,
                        "text": "Which of the following is correct for checking equality in an if condition?",
                        "options": [
                            "if(a = b)",
                            "if(a == b)",
                            "if(a === b)",
                            "if(a => b)"
                        ],
                        "correctAnswer": 1,
                        "explanation": "In C, == is the equality comparison operator. Single = is the assignment operator."
                    }
                ]
            },
            {
                "id": "c8",
                "title": "8. switch Statement",
                "duration": "25 mins",
                "content": "# C Switch-Case Statement\n\nThe `switch` statement is a multi-way selection statement. It's a cleaner way to handle multiple conditions compared to a long `if-else if` ladder.\n\nIt allows you to test a variable against a list of values called **cases**.\n\n---\n\n## ‚ö° Key Keywords\n\n- **switch**: Starts the block and evaluates the variable.\n- **case**: A specific value to check against.\n- **break**: Exits the switch block (very important!).\n- **default**: Runs if no case matches (optional but recommended).\n\n---\n\n## üí† Syntax\n\n```c\nswitch (expression) {\n    case value1:\n        // code\n        break;\n    case value2:\n        // code\n        break;\n    default:\n        // code if no match\n}\n```\n\n---\n\n## üìù Example 1: Menu Program\n\n```c\n#include <stdio.h>\n\nint main() {\n    int choice = 2;\n\n    printf(\"1. Coffee\\n2. Tea\\n3. Juice\\n\");\n    printf(\"Enter choice: \");\n\n    switch(choice) {\n        case 1:\n            printf(\"You selected Coffee\\n\");\n            break;\n        case 2:\n            printf(\"You selected Tea\\n\");\n            break;\n        case 3:\n            printf(\"You selected Juice\\n\");\n            break;\n        default:\n            printf(\"Invalid choice\\n\");\n    }\n\n    return 0;\n}\n```\n\n### üíª Expected Output\n```text\n1. Coffee\n2. Tea\n3. Juice\nEnter choice: \nYou selected Tea\n```\n\n**üí° How it Works?**\n> **Step 1**: The `switch` evaluates the variable `choice` (which is 2).\n> **Step 2**: It jumps directly to `case 2`.\n> **Step 3**: It prints \"You selected Tea\".\n> **Step 4**: The `break` statement tells the program to exit the switch completely and stop checking other cases.\n\n---\n\n## üî• Example 2: Fall-through (No break)\n\nIf you forget the `break`, C will execute **all** subsequent cases until it hits a break or the end of the switch. This is called **Fall-through**.\n\n```c\nchar grade = 'B';\n\nswitch(grade) {\n    case 'A': printf(\"Excellent \");\n    case 'B': printf(\"Good \");\n    case 'C': printf(\"Average \");\n    break;\n}\n```\n\n### üíª Expected Output\n```text\nGood Average\n```\n\n**üí° How it Works?**\n> Since `grade` is 'B', the program starts at `case 'B'`. Because there is no `break` after \"Good\", it \"falls through\" and also executes `case 'C'`, printing \"Average\". It finally stops at the `break` in case 'C'.\n\n---\n\n## ‚ö†Ô∏è Important Rules\n\n1.  **Data Types**: Switch only works with **Integers** (`int`) and **Characters** (`char`). You cannot use `float` or `double`.\n2.  **Break**: Always use `break` unless you intentionally want a fall-through effect.\n3.  **Default**: Place `default` at the end to handle unexpected inputs.\n4.  **Constants**: Case values must be constants (like 1, 10, or 'A'), not variables.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What happens if a `break` statement is missing in a switch case?",
                        "options": [
                            "The program crashes",
                            "Execution falls through to the next case",
                            "The switch immediately exits",
                            "A compilation error occurs"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Without a break, C continues executing the next cases sequentially until it encounters a break or the end of the block."
                    },
                    {
                        "id": 2,
                        "text": "Which of these data types is NOT allowed in a switch expression?",
                        "options": [
                            "int",
                            "char",
                            "float",
                            "short"
                        ],
                        "correctAnswer": 2,
                        "explanation": "Switch statements in C do not support floating-point numbers (float/double) because they require exact comparisons."
                    },
                    {
                        "id": 3,
                        "text": "What is the output of this code?\n\n```c\nint x = 2;\nswitch(x) {\n    case 1: printf(\"One \");\n    case 2: printf(\"Two \");\n    case 3: printf(\"Three \");\n    break;\n}\n```",
                        "options": [
                            "Two",
                            "Two Three",
                            "One Two Three",
                            "Three"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Since there is no break after case 2, it prints 'Two' and then 'falls through' to case 3 and prints 'Three' before hitting a break."
                    },
                    {
                        "id": 4,
                        "text": "The `default` case in a switch statement is:",
                        "options": [
                            "Mandatory",
                            "Optional",
                            "Only for errors",
                            "Used for the first case"
                        ],
                        "correctAnswer": 1,
                        "explanation": "The default case is optional. It executes only when none of the specified cases match the expression."
                    },
                    {
                        "id": 5,
                        "text": "What value can follow the `case` keyword?",
                        "options": [
                            "A variable",
                            "A constant value",
                            "An expression like x > 5",
                            "A string like \"Hello\""
                        ],
                        "correctAnswer": 1,
                        "explanation": "Case labels must be constant expressions (like 5, 'B', or an enum). They cannot be variables or logical comparisons."
                    }
                ]
            },
            {
                "id": "c9",
                "title": "9. for Loop",
                "duration": "30 mins",
                "content": "# C for Loop Statement\n\nThe `for` loop is used when you want to repeat a block of code a **fixed number of times**. It is the most commonly used loop in C because it keeps initialization, condition, and increment all in one line.\n\n---\n\n## ‚ö° Syntax of for Loop\n\n```c\nfor (initialization; condition; increment) {\n    // code to repeat\n}\n```\n\n### Parts Explained:\n1.  **initialization**: Runs only once at the start (e.g., `int i = 1`).\n2.  **condition**: Checked before every loop. If true, the loop continues (e.g., `i <= 5`).\n3.  **increment**: Runs after the code block to update the variable (e.g., `i++`).\n\n---\n\n## üìù Example 1: Print Numbers 1 to 5\n\n```c\n#include <stdio.h>\n\nint main() {\n    int i;\n\n    for (i = 1; i <= 5; i++) {\n        printf(\"%d \", i);\n    }\n\n    return 0;\n}\n```\n\n### üíª Expected Output\n```text\n1 2 3 4 5\n```\n\n**üí° How it Works?**\n> **Step 1**: `i` starts at 1.\n> **Step 2**: Is `1 <= 5`? Yes, so it prints `1`.\n> **Step 3**: `i++` makes it 2.\n> **Step 4**: Is `2 <= 5`? Yes, so it prints `2`.\n> **...**\n> **Step 5**: When `i` becomes 6, `6 <= 5` is false, and the loop stops.\n\n---\n\n## üî• Example 2: Count Down from 5 to 1\n\n```c\n#include <stdio.h>\n\nint main() {\n    for (int i = 5; i >= 1; i--) {\n        printf(\"%d \", i);\n    }\n    return 0;\n}\n```\n\n### üíª Expected Output\n```text\n5 4 3 2 1\n```\n\n**üí° How it Works?**\n> We start at `5`. Each time, `i--` reduces the value by 1. The loop continues as long as `i` is greater than or equal to `1`.\n\n---\n\n## üí† Example 3: Infinite Loop (Avoid This!)\n\nIf the condition never becomes false, the loop runs forever.\n\n```c\nfor (int i = 1; i > 0; i++) {\n    // This will run forever because i is always > 0\n}\n```\n\n---\n\n## ‚ö†Ô∏è Important Rules\n\n1.  **Multiple Statements**: You can initialize multiple variables using commas (e.g., `for(int i=0, j=10; ...)`).\n2.  **Optional Parts**: Any part of the `for` loop can be left empty, but the semicolons `;` are **required** (e.g., `for(;;)` is an infinite loop).\n3.  **Scope**: Variables declared inside the `for` loop are only available inside that loop.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What are the three parts of a `for` loop called?",
                        "options": [
                            "Start, Middle, End",
                            "Input, Logic, Output",
                            "Initialization, Condition, Increment",
                            "Setup, Loop, Final"
                        ],
                        "correctAnswer": 2,
                        "explanation": "A for loop consists of initialization, condition checking, and an increment/decrement statement."
                    },
                    {
                        "id": 2,
                        "text": "How many times does the initialization part of a `for` loop run?",
                        "options": [
                            "Every iteration",
                            "Only once at the start",
                            "Never",
                            "Twice"
                        ],
                        "correctAnswer": 1,
                        "explanation": "The initialization part (e.g., i = 0) runs only once when the loop first begins."
                    },
                    {
                        "id": 3,
                        "text": "What is the output of this code?\n\n```c\nfor (int i = 1; i < 3; i++)\n    printf(\"%d \", i);\n```",
                        "options": [
                            "1 2 3",
                            "1 2",
                            "2 3",
                            "1"
                        ],
                        "correctAnswer": 1,
                        "explanation": "The loop runs for i=1 and i=2. When i becomes 3, '3 < 3' is false, so it stops before printing 3."
                    },
                    {
                        "id": 4,
                        "text": "What happens if you use `for(;;)` in C?",
                        "options": [
                            "Compilation Error",
                            "The loop runs once",
                            "It creates an infinite loop",
                            "The loop never runs"
                        ],
                        "correctAnswer": 2,
                        "explanation": "Empty for-loop parts are allowed, but the result is a loop that never terminates on its own."
                    },
                    {
                        "id": 5,
                        "text": "Which part of the `for` loop is executed after the loop body finishing its execution?",
                        "options": [
                            "Initialization",
                            "Condition",
                            "Increment/Decrement",
                            "Nothing"
                        ],
                        "correctAnswer": 2,
                        "explanation": "After the code inside the loop runs, the increment/decrement statement is executed before checking the condition again."
                    }
                ]
            },
            {
                "id": "c10",
                "title": "10. while Loop",
                "duration": "25 mins",
                "content": "# C while Loop Statement\n\nThe `while` loop is used to repeat a block of code as long as a specific **condition is true**. \n\n**Use while when:**\n- You don't know exactly how many times the loop will run (e.g., until a user enters 0).\n- The loop depends on a value that changes during execution.\n\n---\n\n## ‚ö° Syntax of while Loop\n\n```c\nwhile (condition) {\n    // code executes as long as condition is true\n}\n```\n\n### How it Works:\n1.  **Check Condition**: C checks the condition inside `()`. If true, the loop body executes.\n2.  **Repeat**: After finishing the body, it goes back and checks the condition again.\n3.  **Exit**: If the condition results in **0 (false)**, the loop stops immediately.\n\n---\n\n## üìù Example 1: Print Numbers 1 to 5\n\n```c\n#include <stdio.h>\n\nint main() {\n    int i = 1;\n\n    while (i <= 5) {\n        printf(\"%d \", i);\n        i++;  // incrementing is vital\n    }\n\n    return 0;\n}\n```\n\n### üíª Expected Output\n```text\n1 2 3 4 5\n```\n\n**üí° How it Works?**\n> **Step 1**: `i` starts at 1. `1 <= 5` is true, so it prints `1`.\n> **Step 2**: `i++` makes it 2. `2 <= 5` is true, so it prints `2`.\n> **...**\n> **Step 3**: When `i` becomes 6, `6 <= 5` is false, and the loop terminates.\n\n---\n\n## üî• Example 2: Sum of Digits\n\n```c\n#include <stdio.h>\n\nint main() {\n    int num = 123, sum = 0;\n\n    while (num != 0) {\n        sum = sum + (num % 10); // Extract last digit\n        num = num / 10;        // Remove last digit\n    }\n    printf(\"Sum: %d\", sum);\n    return 0;\n}\n```\n\n### üíª Expected Output\n```text\nSum: 6\n```\n\n**üí° How it Works?**\n> 1. `123 % 10 = 3`. So, `sum = 3`. `num` becomes 12.\n> 2. `12 % 10 = 2`. So, `sum = 5`. `num` becomes 1.\n> 3. `1 % 10 = 1`. So, `sum = 6`. `num` becomes 0.\n> 4. `num != 0` is now false, so the loop exits.\n\n---\n\n## ‚ö†Ô∏è Important Rules\n\n1.  **Infinite Loop**: If you forget to update your variable (like `i++`), the condition will stays true forever, causing an infinite loop.\n2.  **Semicolon**: Never put a `;` after `while(condition)`. If you do: `while(n < 5);`, the loop will just spin infinitely on that line and do nothing else!\n3.  **False Start**: If the condition is false at the very beginning, the code inside the loop will be **never** run.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "When is the condition in a `while` loop evaluated?",
                        "options": [
                            "After the loop body executes",
                            "Before every iteration of the loop",
                            "Only once at the very start",
                            "Only once at the very end"
                        ],
                        "correctAnswer": 1,
                        "explanation": "The while loop is an 'entry-controlled' loop, meaning it checks the condition *before* running any code in the body."
                    },
                    {
                        "id": 2,
                        "text": "What is the minimum number of times a `while` loop can execute?",
                        "options": [
                            "One time",
                            "Infinity",
                            "Zero times",
                            "Depends on the variable type"
                        ],
                        "correctAnswer": 2,
                        "explanation": "If the condition is false initially, the while loop will skip the body entirely and run 0 times."
                    },
                    {
                        "id": 3,
                        "text": "What will be the output of this code?\n\n```c\nint k = 1;\nwhile (k < 3) {\n    printf(\"%d \", k);\n    k++;\n}\n```",
                        "options": [
                            "1 2 3",
                            "1 2",
                            "2 3",
                            "1"
                        ],
                        "correctAnswer": 1,
                        "explanation": "The loop runs for k=1 and k=2. When k becomes 3, the condition 3 < 3 is false, and it stops."
                    },
                    {
                        "id": 4,
                        "text": "What happens if you accidentally write `while(1)` in C?",
                        "options": [
                            "The loop runs once",
                            "The loop creates an infinite loop",
                            "A compilation error occurs",
                            "The loop is skipped"
                        ],
                        "correctAnswer": 1,
                        "explanation": "In C, any non-zero value like 1 is considered 'True'. Since '1' always remains 'True', the loop will never stop."
                    },
                    {
                        "id": 5,
                        "text": "Which part of the `while` loop determines how many times it repeats?",
                        "options": [
                            "The keyword 'while'",
                            "The update statement inside the body",
                            "The condition inside the parentheses ()",
                            "The default case"
                        ],
                        "correctAnswer": 2,
                        "explanation": "The condition expression evaluated at the start of each iteration controls whether the loop continues or exits."
                    }
                ]
            },
            {
                "id": "c11",
                "title": "11. do-while Loop",
                "duration": "25 mins",
                "content": "# C do-while Loop\n\nThe `do-while` loop is similar to the `while` loop, but with one major difference: the loop body is executed **at least once**, even if the condition is false.\n\nThis is because C checks the condition **after** running the code inside the loop.\n\n---\n\n## ‚ö° Syntax of do-while Loop\n\n```c\ndo {\n    // code to repeat\n} while (condition);\n```\n\n> [!IMPORTANT]\n> Always remember the semicolon `;` after the `while(condition)`! It is required in `do-while` but NOT in `while` loops.\n\n---\n\n## üìù Example 1: Print Numbers 1 to 3\n\n```c\n#include <stdio.h>\n\nint main() {\n    int i = 1;\n\n    do {\n        printf(\"%d \", i);\n        i++;\n    } while (i <= 3);\n\n    return 0;\n}\n```\n\n### üíª Expected Output\n```text\n1 2 3\n```\n\n**üí° How it Works?**\n> **Step 1**: `i` is 1. The code inside `do` runs first, printing `1` and making `i = 2`.\n> **Step 2**: Now C checks `2 <= 3`. It's true, so it loops back.\n> **Step 3**: Prints `2`, makes `i = 3`. Checks `3 <= 3` (True).\n> **Step 4**: Prints `3`, makes `i = 4`. Checks `4 <= 3` (False). Loop stops.\n\n---\n\n## üî• Example 2: The \"At Least Once\" Rule\n\nWatch what happens if the condition is false from the very start:\n\n```c\nint x = 100;\ndo {\n    printf(\"This will print!\");\n} while (x < 10);\n```\n\n### üíª Expected Output\n```text\nThis will print!\n```\n\n**üí° Why?**\n> Because C executes the code block **before** evaluating the condition `x < 10`. Even though the condition is false, the message appears once.\n\n---\n\n## üí† while vs do-while\n\n| Feature | while Loop | do-while Loop |\n| :--- | :--- | :--- |\n| **Check Type** | Entry-controlled (Check first) | Exit-controlled (Check last) |\n| **Min iterations** | 0 | 1 |\n| **Semicolon** | No semicolon after condition | Must end with `;` after while |\n\n---\n\n## üéØ Best Use Case\n\n`do-while` is perfect for **Menu-driven programs** where you want to show the options to the user at least once before asking if they want to exit.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What is the key difference between a `while` loop and a `do-while` loop?",
                        "options": [
                            "while runs at least once",
                            "do-while runs at least once",
                            "do-while is faster",
                            "while loops are more accurate"
                        ],
                        "correctAnswer": 1,
                        "explanation": "A do-while loop is 'exit-controlled', meaning it executes the body first and then checks the condition, guaranteeing at least one run."
                    },
                    {
                        "id": 2,
                        "text": "What is mandatory at the end of a `do-while` loop syntax?",
                        "options": [
                            "A colon (:)",
                            "A comma (,)",
                            "A semicolon (;)",
                            "Nothing"
                        ],
                        "correctAnswer": 2,
                        "explanation": "Unlike the while loop, the do-while loop must end with a semicolon (;) after the while (condition) part."
                    },
                    {
                        "id": 3,
                        "text": "What will be the output of this code?\n\n```c\nint i = 5;\ndo {\n    printf(\"%d \", i);\n    i++;\n} while (i < 5);\n```",
                        "options": [
                            "No output",
                            "5",
                            "5 6",
                            "Infinite loop"
                        ],
                        "correctAnswer": 1,
                        "explanation": "The code runs once (prints 5, i becomes 6). Then it checks 6 < 5. Since it's false, the loop stops after that single execution."
                    },
                    {
                        "id": 4,
                        "text": "The `do-while` loop is an example of an:",
                        "options": [
                            "Entry-controlled loop",
                            "Exit-controlled loop",
                            "Infinite-controlled loop",
                            "Selection statement"
                        ],
                        "correctAnswer": 1,
                        "explanation": "It is an exit-controlled loop because the condition is tested after the loop body has executed."
                    },
                    {
                        "id": 5,
                        "text": "When is the condition in a `do-while` loop evaluated?",
                        "options": [
                            "Before every iteration",
                            "After every iteration",
                            "Only if the loop body fails",
                            "At the start of the program"
                        ],
                        "correctAnswer": 1,
                        "explanation": "In a do-while loop, the condition is evaluated at the bottom of the loop, after each execution of the body."
                    }
                ]
            },
            {
                "id": "c12",
                "title": "12. break and continue",
                "duration": "25 mins",
                "content": "# break and continue Statements\n\nSometimes, you need to control a loop more precisely. C provides two powerful keywords for this: `break` and `continue`.\n\n---\n\n## 1. The break Statement\n\n### üî• Purpose\nThe `break` statement immediately **ends** the loop or switch-case. It jumps completely out of the block to the code below it.\n\n### ‚ö° Example: Stop at 5\n\n```c\n#include <stdio.h>\n\nint main() {\n    for (int i = 1; i <= 10; i++) {\n        if (i == 5) {\n            break; // stops immediately\n        }\n        printf(\"%d \", i);\n    }\n    printf(\"\\nLoop Stopped!\");\n    return 0;\n}\n```\n\n### üíª Expected Output\n```text\n1 2 3 4 \nLoop Stopped!\n```\n\n**üí° How it Works?**\n> When `i` reaches 5, the `break` command executes. C ignores the rest of the numbers (6, 7, 8, 9, 10) and exits the loop to print \"Loop Stopped!\".\n\n---\n\n## 2. The continue Statement\n\n### üî• Purpose\nThe `continue` statement skips the **current iteration** and jumps to the next check. It doesn't exit the loop; it just \"skips a turn.\"\n\n### ‚ö° Example: Skip the number 3\n\n```c\n#include <stdio.h>\n\nint main() {\n    for (int i = 1; i <= 5; i++) {\n        if (i == 3) {\n            continue; // skips printing 3\n        }\n        printf(\"%d \", i);\n    }\n    return 0;\n}\n```\n\n### üíª Expected Output\n```text\n1 2 4 5\n```\n\n**üí° How it Works?**\n> When `i` is 3, `continue` is triggered. C skips the `printf` command for that specific turn and jumps immediately back to the top for `i = 4`.\n\n---\n\n## üí† break vs continue\n\n| Feature | break | continue |\n| :--- | :--- | :--- |\n| **Action** | Terminates the loop entirely | Skips the current turn only |\n| **Next step** | Code after the loop | Next loop iteration |\n| **Usage** | Switch-case, While, For | While, For |\n\n---\n\n## ‚ö†Ô∏è Important Rules\n\n1.  **Usage**: You can use `break` in loops and `switch`. However, `continue` can **only** be used inside loops.\n2.  **Infinite Loops**: Be careful when using `continue` in `while` loops! If you skip the update statement (like `i++`), you might create an infinite loop accidentally.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What does the `break` statement do when it is executed inside a loop?",
                        "options": [
                            "Restarts the current iteration",
                            "Skips only the next iteration",
                            "Terminates the loop completely",
                            "Pauses the program"
                        ],
                        "correctAnswer": 2,
                        "explanation": "A break statement immediately exits the closest loop or switch block."
                    },
                    {
                        "id": 2,
                        "text": "What is the key difference between `break` and `continue`?",
                        "options": [
                            "continue exits the loop, break skips a turn",
                            "break exits the loop, continue skips a turn",
                            "They both do the same thing",
                            "break only works in for loops"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Break stops everything and leaves the loop; continue just ignores the rest of the current iteration and moves to the next turn."
                    },
                    {
                        "id": 3,
                        "text": "What is the output of this code?\n\n```c\nfor(int i=1; i<=3; i++) {\n    if(i == 2) continue;\n    printf(\"%d \", i);\n}\n```",
                        "options": [
                            "1 2 3",
                            "1 3",
                            "1 2",
                            "2 3"
                        ],
                        "correctAnswer": 1,
                        "explanation": "When i=2, the continue statement skips the printf command. So only 1 and 3 are printed."
                    },
                    {
                        "id": 4,
                        "text": "Where can the `continue` statement NOT be used?",
                        "options": [
                            "for loop",
                            "while loop",
                            "switch statement",
                            "do-while loop"
                        ],
                        "correctAnswer": 2,
                        "explanation": "The continue statement is designed only for loops. It cannot be used inside a switch-case block."
                    },
                    {
                        "id": 5,
                        "text": "What will happen in this `while` loop?\n\n```c\nint i = 1;\nwhile(i <= 5) {\n    if(i == 3) continue;\n    printf(\"%d \", i);\n    i++;\n}\n```",
                        "options": [
                            "It prints 1 2 4 5",
                            "It prints 1 2 and stops",
                            "It creates an infinite loop",
                            "It prints 1 2 3 4 5"
                        ],
                        "correctAnswer": 2,
                        "explanation": "Because i++ is skipped when i=3, the value of i stays 3 forever, and the condition 3 <= 5 remains true, causing an infinite loop."
                    }
                ]
            }
        ]
    },
    {
        "id": "c-l3",
        "title": "LEVEL 3: Functions",
        "lessons": [
            {
                "id": "c13",
                "title": "13. Functions in C",
                "duration": "35 mins",
                "content": "# Master the Three Pillars of C Functions\n\n## üìã Definition of a Function\nA **Function** is a self-contained block of code that performs a specific task. Think of it as a small \"sub-program\" within your main program that can be used whenever you need to perform that specific job. Instead of writing the same logic multiple times, you group it into one named block. This approach, called **Modular Programming**, makes your code organized, easy to debug, and highly reusable. It helps you focus on one small task at a time without getting lost in a giant program.\n\n### üåü Key Concept: The Recipe\nA function is like a **recipe**. You write it once, and anyone can use it to cook the same dish multiple times. In C, using a function requires three distinct steps: **Declaring** it, **Defining** it, and **Calling** it.\n\n---\n\n## 1Ô∏è‚É£ Part 1: Function Declaration (The Pre-Announcement)\n\n### üìù What is it?\nThe declaration (also called a **prototype**) tells the C compiler about the function's name and return type *before* you actually use it. It's like introducing a guest before they enter the party.\n\n### ‚ö° Syntax\n```c\nreturn_type function_name();\n```\n\n### üí° Why is it needed?\nC reads codes from top to bottom. If you call a function in `main()` but haven't declared it yet, the compiler gets confused! Writing the declaration at the top (above `main`) ensures the compiler knows the function exists.\n\n---\n\n## 2Ô∏è‚É£ Part 2: Function Definition (The Action)\n\n### üìù What is it?\nThis is where the actual \"work\" happens. You write the code block `{ }` that contains the instructions for the task.\n\n### ‚ö° Syntax\n```c\nreturn_type function_name() {\n    // Write your code here\n}\n```\n\n### üí° Why is it needed?\nWithout a definition, the function is just an empty name. The definition provides the logic needed to perform a specific task (like printing a message or calculating a value).\n\n---\n\n## 3Ô∏è‚É£ Part 3: Function Call (The Trigger)\n\n### üìù What is it?\nDeclaring and defining a function is not enough‚Äîit won't run by itself! You must \"call\" it to execute the code. Think of it as pushing a button to start a machine.\n\n### ‚ö° Syntax\n```c\nfunction_name();\n```\n\n### üí° Why is it needed?\nFunctions only execute when they are explicitly called. You can call the same function 100 times if you need to repeat the task.\n\n---\n\n## üöÄ Full Example: The Message Program\n\nHere is how these three pillars work together to display a message:\n\n```c\n#include <stdio.h>\n\n// Step 1: Declaration\nvoid showMsg(); \n\nint main() {\n    printf(\"Starting main...\\n\");\n\n    // Step 3: Function Call\n    showMsg(); \n\n    printf(\"Back in main!\");\n    return 0;\n}\n\n// Step 2: Function Definition\nvoid showMsg() {\n    printf(\"Hello! I am inside the function.\\n\");\n}\n```\n\n**Expected Output:**\n```text\nStarting main...\nHello! I am inside the function.\nBack in main!\n```\n\n---\n\n## üí° Step-by-Step Logic Tracing\n\n> **Turn 1**: The program enters `main()` and prints \"Starting main...\".\n> **Turn 2**: It hits `showMsg();`. C pauses `main()` and jumps down to the **Function Definition**.\n> **Turn 3**: Inside the function, it prints \"Hello! I am inside the function.\".\n> **Turn 4**: The function ends. C jumps back to `main()` exactly where it left off.\n> **Turn 5**: It prints \"Back in main!\" and finally reaches the end of the program.\n\n---\n\n## üí† Summary Table\n\n| Part | Role | Semicolon? |\n| :--- | :--- | :--- |\n| **Declaration** | Announces the function | **Yes** (Must end with `;`) |\n| **Definition** | Contains the actual code | **No** (Uses `{ }` instead) |\n| **Call** | Executes the function | **Yes** (Must end with `;`) |",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Which part of a function provides the actual logic and code to perform a task?",
                        "options": [
                            "Function Declaration",
                            "Function Call",
                            "Function Definition",
                            "Function Header"
                        ],
                        "correctAnswer": 2,
                        "explanation": "The function definition is the 'body' of the function where all the instructions are written."
                    },
                    {
                        "id": 2,
                        "text": "What is the primary purpose of a 'Function Declaration'?",
                        "options": [
                            "To run the function",
                            "To tell the compiler about the function's existence",
                            "To write the code logic",
                            "To include a library"
                        ],
                        "correctAnswer": 1,
                        "explanation": "A declaration (or prototype) serves as a pre-announcement to the compiler so it won't be confused when it sees the function call later."
                    },
                    {
                        "id": 3,
                        "text": "What happens if you define a function but never 'Call' it in `main()`?",
                        "options": [
                            "The code inside will never run",
                            "The program will crash",
                            "It will run automatically at the start",
                            "It will result in a compilation error"
                        ],
                        "correctAnswer": 0,
                        "explanation": "Functions are stagnant blocks of code; they only spring to life when they are explicitly 'called'."
                    },
                    {
                        "id": 4,
                        "text": "Identify the correct 'Function Call' syntax for a function named `play()`:",
                        "options": [
                            "void play();",
                            "play();",
                            "call play;",
                            "play { };"
                        ],
                        "correctAnswer": 1,
                        "explanation": "To call a function, you simply write its name followed by parentheses and a semicolon."
                    },
                    {
                        "id": 5,
                        "text": "Which of these does NOT end with a semicolon in C?",
                        "options": [
                            "The Function Declaration",
                            "The Function Call",
                            "The Function Definition header",
                            "The return 0; statement"
                        ],
                        "correctAnswer": 2,
                        "explanation": "A function definition header (e.g., void fun()) is immediately followed by a code block { }, so it does not use a semicolon."
                    }
                ]
            },
            {
                "id": "c14",
                "title": "14. User-Defined Functions",
                "duration": "30 mins",
                "content": "# Lesson 14: User-Defined Functions\n\nPreviously, we learned the basics of functions. Now, let's learn how to make them dynamic! A **User-Defined Function** is a custom tool you build to handle specific data. To do this, you must understand two key concepts: **Parameters** and **Return Values**.\n\n---\n\n## üîÑ The Data Flow: Input & Output\n\nTo make a function useful, it needs to receive information from `main()` and send a result back. \n\n### üì¶ 1. Parameters (Input)\nParameters are variables listed in the function's parentheses. They act like \"placeholders\" for the values you pass when calling the function.\n```c\nvoid showSquare(int n) { ... }\n```\nHere, `n` is a parameter that allows any number to be passed in to be squared.\n\n### üöö 2. The Return Value (Output)\nThe `return` keyword is used to send a value back to the place where the function was called. It's like a delivery person bringing a package to your door.\n```c\nreturn result;\n```\n\n---\n\n## üöÄ Example 1: The Adder (Args + Return)\n\nThis function takes two integers, adds them, and **returns** the sum back to `main()`.\n\n```c\n#include <stdio.h>\n\n// Step 1: Declaration (Above main)\nint add(int a, int b);\n\nint main() {\n    int sum;\n\n    // Step 3: Call (Passing 10 and 20)\n    sum = add(10, 20); \n\n    printf(\"The sum is: %d\\n\", sum);\n    return 0;\n}\n\n// Step 2: Definition (Below main)\nint add(int a, int b) {\n    int result = a + b;\n    return result; // Delivery back to main!\n}\n```\n\n**Expected Output:**\n```text\nThe sum is: 30\n```\n\n### üí° **How it Works (Example 1):**\n1. `int add(int a, int b);`: This tells C that a function named `add` exists, which takes two integers as input and gives an integer as output.\n2. `add(10, 20)`: When this is called, C copies the value **10** into the variable `a` and **20** into the variable `b` inside the function.\n3. `return result;`: This line exits the function and carries the number **30** back to `main()`, where it gets stored in the `sum` variable.\n\n---\n\n## ‚öñÔ∏è Example 2: Logic Checker (Decision Making)\n\nLet's follow the standard 3-part structure to check if a number is Even or Odd.\n\n```c\n#include <stdio.h>\n\n// 1. Declaration\nint isEven(int n);\n\nint main() {\n    int num = 7;\n\n    // 3. Call inside a condition\n    if (isEven(num))\n        printf(\"%d is Even\\n\", num);\n    else\n        printf(\"%d is Odd\\n\", num);\n\n    return 0;\n}\n\n// 2. Definition\nint isEven(int n) {\n    if (n % 2 == 0)\n        return 1; // 1 means True (Even)\n    else\n        return 0; // 0 means False (Odd)\n}\n```\n\n**Expected Output:**\n```text\n7 is Odd\n```\n\n### üí° **How it Works (Example 2):**\n1. `isEven(num)`: When this is called with the number **7**, the variable `n` inside the function becomes **7**.\n2. `n % 2 == 0`: The function checks if 7 is divisible by 2. Since it's not, it jumps to the `else` block.\n3. `return 0;`: The function returns **0** to the `if` statement in `main()`. Since 0 is considered \"False\" in C, the `else` part in `main()` executes, printing \"7 is Odd\".\n\n---\n\n## üí† How it Works: The Logic Flow\n\n1.  **Preparation**: C sets aside memory for the function's parameters (`a` and `b`).\n2.  **Passing**: When you call `add(10, 20)`, the value **10** is copied into `a`, and **20** is copied into `b`.\n3.  **Execution**: The function runs its code using these local variables.\n4.  **Terminating**: The `return` statement terminates the function and sends the result back to `main()`.\n\n---\n\n## üí° Summary of Terms\n\n| Term | Purpose |\n| :--- | :--- |\n| **Arguments** | The actual values you send (e.g., `10, 20`) |\n| **Parameters** | The variables that receive them (e.g., `int a, int b`) |\n| **Return Type** | The type of data the function sends back (e.g., `int`) |\n| **void** | Used if the function sends nothing back |",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What is the primary purpose of a 'return' statement in a function?",
                        "options": [
                            "To stop the program entirely",
                            "To send a result back to the caller and exit the function",
                            "To print a message to the console",
                            "To create a loop"
                        ],
                        "correctAnswer": 1,
                        "explanation": "The 'return' statement sends a specific value back to the function that called it and immediately terminates the current function."
                    },
                    {
                        "id": 2,
                        "text": "In the call `result = add(5, 8);`, the numbers 5 and 8 are technically known as:",
                        "options": [
                            "Parameters",
                            "Arguments",
                            "Constants",
                            "Returns"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Actual values passed during a call are 'Arguments'. The variables receiving them in the definition are 'Parameters'."
                    },
                    {
                        "id": 3,
                        "text": "Which keyword is used to indicate that a function does not return any value?",
                        "options": [
                            "int",
                            "null",
                            "void",
                            "empty"
                        ],
                        "correctAnswer": 2,
                        "explanation": "'void' in the return type position tells the compiler that this function performs a task but provides no output value."
                    },
                    {
                        "id": 4,
                        "text": "If a function is declared as `int getVal();`, what is mandatory inside its definition?",
                        "options": [
                            "A printf statement",
                            "A return statement with an integer value",
                            "At least two parameters",
                            "A call to main()"
                        ],
                        "correctAnswer": 1,
                        "explanation": "A function with an 'int' return type must return an integer value back to the caller."
                    },
                    {
                        "id": 5,
                        "text": "When are parameters assigned their values?",
                        "options": [
                            "When the program starts",
                            "When the function is declared",
                            "When the function is called",
                            "When the compiler runs"
                        ],
                        "correctAnswer": 2,
                        "explanation": "Parameters are assigned (or 'passed') the values of the arguments at the exact moment the function is called."
                    }
                ]
            },
            {
                "id": "c15",
                "title": "15. Types of Functions",
                "duration": "40 mins",
                "content": "# Types of Functions in C\n\nFunctions can be classified into four types based on whether they take **Arguments** (Input) and whether they send back a **Return Value** (Output). Understanding these differences helps you decide how to structure your code efficiently.\n\n---\n\n## 1. No Arguments and No Return Value\n\nThis type of function neither accepts data from the calling function nor sends any value back. It is typically used for simple tasks like printing a fixed message.\n\n### Syntax\n```c\nvoid function_name();\n```\n\n### Example\n```c\n#include <stdio.h>\n\nvoid greet(); // Declaration\n\nint main() {\n    greet(); // Call\n    return 0;\n}\n\n// Definition\nvoid greet() {\n    printf(\"Hello, Welcome to C Programming!\\n\");\n}\n```\n\n**Expected Output:**\n```text\nHello, Welcome to C Programming!\n```\n\n**üí° How it Works:**\n- `main()` calls `greet()`, but passes no data.\n- `greet()` executes its code (printing the message) and finishes.\n- Control returns to `main()` without carrying any value back.\n\n---\n\n## 2. No Arguments and With Return Value\n\nThis function doesn't take input but sends a result back to the caller. This is useful when a function generates a value internally (like reading a sensor or getting user input).\n\n### Syntax\n```c\nint function_name();\n```\n\n### Example\n```c\n#include <stdio.h>\n\nint getNumber();\n\nint main() {\n    int num = getNumber();\n    printf(\"Number received: %d\", num);\n    return 0;\n}\n\nint getNumber() {\n    return 100; // Returns 100 to the caller\n}\n```\n\n**Expected Output:**\n```text\nNumber received: 100\n```\n\n**üí° How it Works:**\n- `getNumber()` is called without arguments.\n- It executes and returns the integer `100`.\n- `main()` receives this value and stores it in the variable `num`.\n\n---\n\n## 3. With Arguments and No Return Value\n\nThis function accepts input data to perform a task but returns nothing. It allows you to pass data *into* the function.\n\n### Syntax\n```c\nvoid function_name(int arg);\n```\n\n### Example\n```c\n#include <stdio.h>\n\nvoid printSum(int a, int b);\n\nint main() {\n    printSum(10, 20);\n    return 0;\n}\n\nvoid printSum(int a, int b) {\n    printf(\"Sum: %d\", a + b);\n}\n```\n\n**Expected Output:**\n```text\nSum: 30\n```\n\n**üí° How it Works:**\n- `main()` passes the values `10` and `20` to `printSum`.\n- The function receives them as `a` and `b`.\n- It calculates `10 + 20` and prints `30` directly.\n- It returns nothing (`void`) to `main()`.\n\n---\n\n## 4. With Arguments and With Return Value\n\nThis is the most strictly \"functional\" type. It takes input, processes it, and returns the result. This is ideal for calculations.\n\n### Syntax\n```c\nint function_name(int arg);\n```\n\n### Example\n```c\n#include <stdio.h>\n\nint multiply(int a, int b);\n\nint main() {\n    int product = multiply(5, 4);\n    printf(\"Product: %d\", product);\n    return 0;\n}\n\nint multiply(int a, int b) {\n    return a * b;\n}\n```\n\n**Expected Output:**\n```text\nProduct: 20\n```\n\n**üí° How it Works:**\n- `main()` sends `5` and `4` to `multiply`.\n- `multiply()` calculates `5 * 4 = 20`.\n- It returns `20` back to `main()`, which is stored in `product`.\n\n---\n\n## üìä Summary Table\n\n| Type | Input (Args) | Output (Return) | Example Use Case |\n| :--- | :--- | :--- | :--- |\n| **1. No Arg / No Return** | ‚ùå No | ‚ùå No | Displaying a menu or welcome message |\n| **2. No Arg / With Return** | ‚ùå No | ‚úÖ Yes | Getting a random number or user input |\n| **3. With Arg / No Return** | ‚úÖ Yes | ‚ùå No | Displaying formatted data |\n| **4. With Arg / With Return** | ‚úÖ Yes | ‚úÖ Yes | Mathematical calculations |",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Which function type returns a value but takes no arguments?",
                        "options": [
                            "No Arguments, No Return",
                            "With Arguments, With Return",
                            "No Arguments, With Return",
                            "With Arguments, No Return"
                        ],
                        "correctAnswer": 2,
                        "explanation": "The 'No Arguments, With Return' type does not accept input but sends a result back to the caller."
                    },
                    {
                        "id": 2,
                        "text": "In the function declaration `void printSum(int a, int b);`, what does `void` indicate?",
                        "options": [
                            "The function takes no arguments",
                            "The function returns an integer",
                            "The function returns nothing",
                            "The function is empty"
                        ],
                        "correctAnswer": 2,
                        "explanation": "`void` as the return type specifies that the function does not return any value to the caller."
                    },
                    {
                        "id": 3,
                        "text": "Which type of function is `int square(int n);`?",
                        "options": [
                            "No Arguments, With Return",
                            "With Arguments, No Return",
                            "With Arguments, With Return",
                            "No Arguments, No Return"
                        ],
                        "correctAnswer": 2,
                        "explanation": "It takes an argument (`int n`) and returns a value (`int`), so it is 'With Arguments, With Return'."
                    },
                    {
                        "id": 4,
                        "text": "If a function is declared as `void greet();`, is `int x = greet();` valid?",
                        "options": [
                            "Yes, x will be 0",
                            "No, it will cause a compilation error",
                            "Yes, x will be undefined",
                            "Yes, if greet returns a number"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Since `greet` is `void` (returns nothing), you cannot assign its result to a variable. This causes a compilation error."
                    },
                    {
                        "id": 5,
                        "text": "What is the best function type for calculating the area of a circle where you provide the radius and need the area back?",
                        "options": [
                            "With Arguments, With Return",
                            "With Arguments, No Return",
                            "No Arguments, With Return",
                            "No Arguments, No Return"
                        ],
                        "correctAnswer": 0,
                        "explanation": "You need to provide input (radius) and receive output (area), so 'With Arguments, With Return' is the correct choice."
                    }
                ]
            },
            {
                "id": "c16",
                "title": "16. Call by Value vs. Call by Reference",
                "duration": "35 mins",
                "content": "# Call by Value vs. Call by Reference\n\nWhen you pass a variable to a function, C needs to know how to handle the data. There are two primary ways: **Call by Value** (the default) and **Call by Reference** (using pointers).\n\n---\n\n## 1. Call by Value (Copying)\n\nIn Call by Value, the function receives a **copy** of the variable's value. It does NOT get the original variable itself.\n\n### ‚ö° Key Facts\n-   **Safe**: The original variable in `main()` cannot be accidentally changed.\n-   **Memory**: Uses more memory for large data because it creates copies.\n-   **Default**: This is how C normally passes data (int, float, char).\n\n### üöÄ Example: The Failed Attempt\n\n```c\n#include <stdio.h>\n\nvoid changeValue(int x) {\n    x = 100;\n}\n\nint main() {\n    int num = 10;\n    changeValue(num);\n    printf(\"num is still: %d\", num);\n    return 0;\n}\n```\n\n### üíª Expected Output\n\n```text\nnum is still: 10\n```\n\n**üí° Why it failed?**\n> The function `changeValue` got a copy of `10`. It changed its local `x` to `100`, but the original `num` in `main()` remained untouched.\n\n---\n\n## 2. Call by Reference (Sharing)\n\nIn Call by Reference, you pass the **address** of the variable to the function using a pointer. The function now knows exactly where the original variable lives in memory.\n\n### ‚ö° Key Facts\n-   **Powerful**: Allows a function to modify the caller's variables.\n-   **Efficient**: No copying needed (great for large structures or arrays).\n-   **Pointers**: Requires using `*` (dereference) inside the function.\n\n### üöÄ Example: The Success\n\n```c\n#include <stdio.h>\n\nvoid actualChange(int *ptr) {\n    *ptr = 100; // Go to the address and change it\n}\n\nint main() {\n    int num = 10;\n    actualChange(&num); // Pass the address\n    printf(\"num is now: %d\", num);\n    return 0;\n}\n```\n\n### üíª Expected Output\n\n```text\nnum is now: 100\n```\n\n---\n\n## 3. The Classic Example: Swapping\n\nSwapping two numbers is the standard way to understand the difference. To swap two variables in `main()` from inside a function, you **MUST** use Call by Reference.\n\n```c\n#include <stdio.h>\n\n// Correct Swapping using Pointers\nvoid swap(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint main() {\n    int x = 10, y = 20;\n    swap(&x, &y);\n    printf(\"x: %d, y: %d\", x, y);\n    return 0;\n}\n```\n\n### üíª Expected Output\n\n```text\nx: 20, y: 10\n```\n\n---\n\n## üìä Quick Comparison\n\n| Feature | Call by Value | Call by Reference |\n| :--- | :--- | :--- |\n| **Arguments** | Copies are passed | Addresses are passed |\n| **Modification** | Original stays safe | Original is changed |\n| **Syntax** | Normal variables | Pointers (`*`) and Addresses (`&`) |\n| **Performance** | Slower for big data | Faster (no copying) |\n\n---\n\n## ‚ö° Key Takeaways\n- Use **Call by Value** when you just need to *read* data.\n- Use **Call by Reference** when you need to *modify* or return multiple values.\n- Arrays in C are always passed by reference (decay to pointers).",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What is the default way C passes integer arguments to a function?",
                        "options": [
                            "Call by Reference",
                            "Call by Value",
                            "Call by Address",
                            "Call by Global"
                        ],
                        "correctAnswer": 1,
                        "explanation": "C uses 'Call by Value' by default for all standard data types like int, float, and char, meaning it passes a copy of the data."
                    },
                    {
                        "id": 2,
                        "text": "To implement 'Call by Reference' in C, what must you pass to the function?",
                        "options": [
                            "The variable name",
                            "A copy of the value",
                            "The memory address of the variable",
                            "The variable type"
                        ],
                        "correctAnswer": 2,
                        "explanation": "Call by reference requires passing the address (using & operator) so the function can access the original memory location."
                    },
                    {
                        "id": 3,
                        "text": "In Call by Value, if you modify a parameter inside the function, what happens to the original variable in main()?",
                        "options": [
                            "It changes to the new value",
                            "It remains unchanged",
                            "It becomes zero",
                            "The program crashes"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Because the function is working on a separate copy, changes made inside the function do not affect the original variable."
                    },
                    {
                        "id": 4,
                        "text": "What does the `swap(int *a, int *b)` function header indicate?",
                        "options": [
                            "It swaps two values using Call by Value",
                            "It takes two pointers and uses Call by Reference",
                            "It is a recursive function",
                            "It returns an integer"
                        ],
                        "correctAnswer": 1,
                        "explanation": "The asterisks (*) indicate that the function accepts pointers, which is the mechanism for Call by Reference in C."
                    },
                    {
                        "id": 5,
                        "text": "Which of these is a benefit of using Call by Reference?",
                        "options": [
                            "It is always safer for calculations",
                            "It avoids creating large copies of data in memory",
                            "It makes variables global automatically",
                            "It doesn't require any special syntax"
                        ],
                        "correctAnswer": 1,
                        "explanation": "By passing only the address (usually 4 or 8 bytes), you avoid copying large amounts of data, making the program more memory-efficient."
                    }
                ]
            },
            {
                "id": "c17",
                "title": "17. Recursion in C",
                "duration": "60 mins",
                "content": "# Recursion in C: The Ultimate Guide\n\nRecursion is one of the most elegant and powerful concepts in computer science. It occurs when a function calls itself, directly or indirectly, to solve a complex problem by breaking it down into smaller, manageable sub-problems.\n\n---\n\n## 1. The Anatomy of Recursion\n\nEvery recursive function MUST have two essential parts. Without these, your program will either not work or crash.\n\n### üõë A. The Base Case (The Exit Strategy)\nThis is the stopping condition. It tells the function when to stop calling itself and start returning values. Without a base case, recursion continues forever, leading to a **Stack Overflow**.\n\n### üîÑ B. The Recursive Case (The Logic)\nThis is the part where the function calls itself, but with a **reduced** or modified input that brings it closer to the base case.\n\n```c\nvoid count(int n) {\n    if (n <= 0) {       // üõë Base Case\n        return;\n    }\n    printf(\"%d \", n);\n    count(n - 1);       // üîÑ Recursive Case\n}\n```\n\n---\n\n## 2. How it Works: The Call Stack\n\nTo understand recursion, you must understand the **Call Stack**. Each time a function is called, C creates an \"Activation Record\" (or Stack Frame) in memory to store its local variables and return address.\n\n### üèóÔ∏è Winding & Unwinding Phase\n1.  **Winding Phase**: The function keeps calling itself, pushing new frames onto the stack. No work is finished yet.\n2.  **Unwinding Phase**: Once the base case is hit, the stack begins to \"pop\" (remove) frames one by one, returning results back up the chain.\n\n> [!CAUTION]\n> **Stack Overflow**: If your recursion is too deep (e.g., calling a function 1 million times), the stack memory runs out, and your program crashes instantly.\n\n---\n\n## 3. Types of Recursion\n\nProfessionals distinguish between different \"flavors\" of recursion:\n\n### üéØ Direct vs Indirect\n- **Direct**: Function A calls Function A.\n- **Indirect**: Function A calls Function B, which then calls Function A. They form a circular chain.\n\n### ‚ö° Tail vs Non-Tail Recursion\n- **Tail Recursion**: The recursive call is the **very last** thing the function does. There is no pending work after the call. This is highly efficient because some compilers can optimize it into a simple loop.\n- **Non-Tail Recursion**: There is still code to execute (like a calculation or print) *after* the recursive call returns.\n\n---\n\n## 4. Iconic Examples\n\n### üöÄ Example 1: Calculating Factorial (Mathematical)\nFactorial of $n$ ($n!$) is $n \\times (n-1) \\times (n-2) \\dots \\times 1$.\n\n```c\nint factorial(int n) {\n    if (n == 0 || n == 1) return 1; // Base case\n    return n * factorial(n - 1);    // Recursive case\n}\n```\n\n### üåø Example 2: Fibonacci Sequence (Multiple Recursion)\nEach number is the sum of the two preceding ones: 0, 1, 1, 2, 3, 5, 8...\n\n```c\nint fib(int n) {\n    if (n <= 1) return n;         // Base cases (0 and 1)\n    return fib(n-1) + fib(n-2);   // Two recursive calls!\n}\n```\n\n---\n\n## 5. Recursion vs Iteration\n\n| Feature | Recursion | Iteration (Loops) |\n| :--- | :--- | :--- |\n| **Performance** | Slower (Function call overhead) | Faster (Direct execution) |\n| **Memory** | Higher (Uses Stack memory) | Lower (Uses fixed memory) |\n| **Readability** | Elegant for complex structures | Clear for simple counting |\n| **Failure** | Can cause Stack Overflow | Can cause Infinite Loops |\n\n---\n\n## ‚ö° Key Takeaways\n- Always ensure your input **progresses** towards the base case.\n- Use recursion for problems that are \"recursive by nature\" (like Tree traversal or Factorials).\n- For simple counting or linear tasks, prefer loops to save memory.\n",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What is the result of missing a base case in a recursive function?",
                        "options": [
                            "The program finishes faster",
                            "Stack Overflow error",
                            "Syntax error during compilation",
                            "The function returns 0 automatically"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Without a base case, the function calls itself infinitely, filling up the call stack until memory runs out, causing a stack overflow."
                    },
                    {
                        "id": 2,
                        "text": "In recursion, what is the 'Unwinding Phase'?",
                        "options": [
                            "The phase where new functions are pushed to the stack",
                            "The phase where functions reach the base case and start returning",
                            "The compiler optimizing the code",
                            "The initialization of local variables"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Unwinding is the process where functions finish their execution and return values back to their callers, 'popping' their records off the stack."
                    },
                    {
                        "id": 3,
                        "text": "Which type of recursion is generally easier for a compiler to optimize?",
                        "options": [
                            "Direct Recursion",
                            "Non-Tail Recursion",
                            "Tail Recursion",
                            "Indirect Recursion"
                        ],
                        "correctAnswer": 2,
                        "explanation": "Tail recursion is optimized by many compilers because the recursive call is the final action, allowing the compiler to reuse the current stack frame instead of creating a new one."
                    },
                    {
                        "id": 4,
                        "text": "What is the value of fib(4) in the Fibonacci sequence (starting 0, 1, 1, 2, 3...)?",
                        "options": [
                            "2",
                            "3",
                            "5",
                            "8"
                        ],
                        "correctAnswer": 1,
                        "explanation": "fib(0)=0, fib(1)=1, fib(2)=1, fib(3)=2, fib(4)=3."
                    },
                    {
                        "id": 5,
                        "text": "Which is a major disadvantage of recursion compared to iteration?",
                        "options": [
                            "It is always more complex to write",
                            "It uses more memory due to stack frames",
                            "It cannot be used with integers",
                            "It requires a 64-bit computer"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Each recursive call adds a new layer to the stack memory. For very deep recursion, this uses significantly more memory than a simple for/while loop."
                    }
                ]
            },
            {
                "id": "c18",
                "title": "18. Scope of Variables",
                "duration": "30 mins",
                "content": "# Scope of Variables in C\n\nScope refers to the region of the program where a specific variable is visible and can be used. If you try to access a variable outside its scope, the compiler will return an error because it \"doesn't exist\" there.\n\nIn C, there are two primary scopes you need to understand:\n1.  **Local Variables**\n2.  **Global Variables**\n\n---\n\n## 1. Local Variables\n\n### üìù Definition\nA variable declared **inside** a function or a block `{ }` is called a local variable.\n\n### ‚ö° Key Characteristics\n-   **Visibility**: Only visible inside the function/block where they are created.\n-   **Lifetime**: Created when the function starts, destroyed when it ends.\n-   **Safety**: Other functions cannot accidentally change them.\n\n### ‚ö° Syntax\n```c\nvoid function_name() {\n    int x; // x is local to this function\n}\n```\n\n### üöÄ Example: Local Scope\n\n```c\n#include <stdio.h>\n\nvoid fun() {\n    int x = 10; // Local variable\n    printf(\"Inside fun(): x = %d\\n\", x);\n}\n\nint main() {\n    fun();\n\n    // printf(\"%d\", x); // ‚ùå Error: x is not known here\n    return 0;\n}\n```\n\n**Expected Output:**\n```text\nInside fun(): x = 10\n```\n\n**üí° How it Works:**\n- `x` is created when `fun()` is called.\n- Inside `fun()`, we can print `x`.\n- Once `fun()` finishes, `x` is deleted from memory.\n- `main()` cannot see `x`, so trying to print it would cause an error.\n\n---\n\n## 2. Global Variables\n\n### üìù Definition\nA variable declared **outside** of all functions (usually at the top of the file) is called a global variable.\n\n### ‚ö° Key Characteristics\n-   **Visibility**: Visible to **all** functions in the program.\n-   **Lifetime**: Stays in memory as long as the program is running.\n-   **Risk**: Any function can change its value, which can lead to bugs.\n\n### ‚ö° Syntax\n```c\nint g; // Declared outside any function\n\nint main() {\n    // ...\n}\n```\n\n### üöÄ Example: Global Scope\n\n```c\n#include <stdio.h>\n\nint myScore = 100; // Global variable\n\nvoid displayScore() {\n    printf(\"Score inside function: %d\\n\", myScore);\n}\n\nint main() {\n    printf(\"Score inside main: %d\\n\", myScore);\n    displayScore();\n    return 0;\n}\n```\n\n**Expected Output:**\n```text\nScore inside main: 100\nScore inside function: 100\n```\n\n**üí° How it Works:**\n- `myScore` is declared at the top, so it is Global.\n- `main()` can access `myScore`.\n- `displayScore()` can also access the exact same `myScore`.\n\n---\n\n## 3. Local vs Global (Name Conflict)\n\n### ‚ö†Ô∏è What if they have the same name?\nIf a local variable has the same name as a global variable, the **Local Variable takes priority** (it \"shadows\" the global one).\n\n### üöÄ Example: Shadowing\n\n```c\n#include <stdio.h>\n\nint x = 50; // Global x\n\nint main() {\n    int x = 10; // Local x (Shadows global x)\n    printf(\"Value of x: %d\", x);\n    return 0;\n}\n```\n\n**Expected Output:**\n```text\nValue of x: 10\n```\n\n**üí° How it Works:**\n- Generally, the compiler looks for variables nearby first.\n- Inside `main()`, it sees a local `x` (10), so it uses that.\n- It completely ignores the global `x` (50) inside this specific function.\n\n---\n\n## üìä Comparison Summary\n\n| Feature | Local Variable | Global Variable |\n| :--- | :--- | :--- |\n| **Where to declare?** | Inside function/block | Outside all functions |\n| **Who can see it?** | Only that function | Everyone |\n| **When does it die?** | When function ends | When program ends |\n| **Default Value** | Garbage (random value) | Zero (0) |",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What happens if a local variable has the same name as a global variable?",
                        "options": [
                            "The program crashes",
                            "The global variable takes priority",
                            "The local variable takes priority",
                            "Both values are added together"
                        ],
                        "correctAnswer": 2,
                        "explanation": "When a local variable has the same name as a global variable, the local variable takes priority within its scope (shadowing the global variable)."
                    },
                    {
                        "id": 2,
                        "text": "Where can a global variable be accessed?",
                        "options": [
                            "Only inside main()",
                            "Only inside the function where it is declared",
                            "Anywhere in the program",
                            "Only inside loops"
                        ],
                        "correctAnswer": 2,
                        "explanation": "Global variables are declared outside of all functions and can be accessed from any function in the program."
                    },
                    {
                        "id": 3,
                        "text": "What is the lifetime of a local variable?",
                        "options": [
                            "The entire duration of the program",
                            "Only while the function it is in is executing",
                            "It is deleted immediately after declaration",
                            "It persists until the computer is turned off"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Local variables are created when the function enters and destroyed automatically when the function exits."
                    },
                    {
                        "id": 4,
                        "text": "Why is overuse of global variables generally discouraged?",
                        "options": [
                            "They take up too much memory",
                            "Any function can change them, leading to unpredictable bugs",
                            "They are slower to access",
                            "Compilers cannot handle them well"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Since any part of the program can modify a global variable, tracking who changed it becomes difficult, making debugging harder."
                    },
                    {
                        "id": 5,
                        "text": "If you declare `int x;` inside a function without initializing it, what is its value?",
                        "options": [
                            "0",
                            "1",
                            "Null",
                            "A garbage (random) value"
                        ],
                        "correctAnswer": 3,
                        "explanation": "In C, uninitialized local variables contain unpredictable 'garbage' values from memory."
                    }
                ]
            }
        ]
    },
    {
        "id": "c-l4",
        "title": "LEVEL 4: Arrays",
        "lessons": [
            {
                "id": "c19",
                "title": "19. Introduction to Arrays",
                "duration": "35 mins",
                "content": "# Arrays in C\n\nThink of an array as a *container* that can hold multiple items of the **same type** together. Instead of creating separate variables for each item (like `student1`, `student2`, `student3`), you create one container (array) to hold them all.\n\n---\n\n## 1. What is an Array?\n\nAn array is a collection of variables stored in a contiguous (side-by-side) memory location. It allows you to store multiple values under a single name.\n\n### ‚ö° Why use Arrays?\n- **Organization**: Keep related data together.\n- **Efficiency**: Write less code to handle many values.\n- **Access**: Easily access any item using its position (index).\n\n---\n\n## 2. Declaration (Creating an Array)\n\nDeclaring an array tells the compiler two things:\n1.  **Type** of data it will store (int, float, char).\n2.  **Size** (how many items it will hold).\n\n### Syntax\n```c\ndatatype name[size];\n```\n\n### Example\n```c\nint marks[5];\n```\n- This reserves memory for **5 integers**.\n- Since we haven't given them values yet, they currently hold **\"garbage\"** (random) values from memory.\n- **Note:** The size must be a positive integer.\n\n---\n\n## 3. Initialization (Filling an Array)\n\nInitialization means assigning values to the array at the time of declaration. You have three ways to do this.\n\n### Method 1: Sized & Full Initialization\nYou specify the size and provide all values.\n```c\nint numbers[5] = {10, 20, 30, 40, 50};\n```\n\n### Method 2: Unsized Initialization (Inferred)\nYou skip the size, and C counts the elements for you.\n```c\nint numbers[] = {1, 2, 3};\n// The compiler knows size is 3\n```\n\n### Method 3: Partial Initialization\nYou provide size but fewer values.\n```c\nint numbers[5] = {10, 20};\n```\n- `numbers[0]` becomes **10**\n- `numbers[1]` becomes **20**\n- **All remaining elements (2, 3, 4) automatically become 0.**\n\n### ‚ùå Common Mistake\nYou cannot assign values like this after declaration:\n```c\nint arr[3];\narr = {1, 2, 3}; // ‚ùå ERROR\n```\n\n---\n\n## 4. Accessing Elements (The Index)\n\nElements in an array are accessed using an **Index** number.\n\n### ‚ö†Ô∏è Crucial Rule\nArray indexing always starts at **0**, not 1.\n- First element: `arr[0]`\n- Second element: `arr[1]`\n- Last element: `arr[size - 1]`\n\n### Visualizing `int x[3] = {10, 20, 30};`\n\n| Index | 0 | 1 | 2 |\n| :--- | :---: | :---: | :---: |\n| **Value** | **10** | **20** | **30** |\n\n### Example: Reading & Writing\n```c\nint x[3] = {10, 20, 30};\n\nprintf(\"%d\", x[0]); // Prints 10 (First element)\nx[2] = 99;          // Changes the third element to 99\n```\n\n---\n\n## 5. Example: Array Input/Output\n\nHere is a complete program that asks the user for 5 numbers, stores them in an array, and then prints them back.\n\n```c\n#include <stdio.h>\n\nint main() {\n    int values[5];\n\n    // 1. INPUT LOOP\n    printf(\"Enter 5 integers: \");\n    for(int i = 0; i < 5; i++) {\n        scanf(\"%d\", &values[i]);\n    }\n\n    // 2. OUTPUT LOOP\n    printf(\"Displaying integers:\\n\");\n    for(int i = 0; i < 5; i++) {\n        printf(\"Element %d: %d\\n\", i, values[i]);\n    }\n    return 0;\n}\n```\n\n**Expected Output (if user enters 1 2 3 4 5):**\n```text\nEnter 5 integers: 1 2 3 4 5\nDisplaying integers:\nElement 0: 1\nElement 1: 2\nElement 2: 3\nElement 3: 4\nElement 4: 5\n```\n\n**üí° How it Works:**\n- `int values[5];` reserves memory for 5 integers.\n- The first loop (`for`) runs 5 times (i=0 to 4), taking input and storing it in `values[0]`, `values[1]`, etc.\n- The second loop runs 5 times again, printing the value stored at each index.\n\n---\n\n## ‚ö° Key Takeaways\n- Fixed size: Once created, the size of an array cannot change.\n- Same Type: You cannot mix types (e.g., storing a `float` in an `int` array).\n- Contiguous: elements are stored right next to each other in memory.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What is the index of the very first element in an array?",
                        "options": [
                            "1",
                            "0",
                            "-1",
                            "It depends on the array size"
                        ],
                        "correctAnswer": 1,
                        "explanation": "In C (and most programming languages), array indexing is 0-based, meaning the first element is always at index 0."
                    },
                    {
                        "id": 2,
                        "text": "If you declare `int arr[5];`, what is the index of the last element?",
                        "options": [
                            "5",
                            "4",
                            "0",
                            "Unknown"
                        ],
                        "correctAnswer": 1,
                        "explanation": "The indices are 0, 1, 2, 3, 4. So the last index is always (size - 1), which is 4."
                    },
                    {
                        "id": 3,
                        "text": "What happens if you try to access `arr[10]` in an array declared as `int arr[5];`?",
                        "options": [
                            "It returns 0",
                            "It automatically expands the array",
                            "It causes undefined behavior (often a crash or garbage value)",
                            "It prints an error message gracefully"
                        ],
                        "correctAnswer": 2,
                        "explanation": "Accessing an index outside the declared size is 'undefined behavior'. It might crash your program or read invalid memory."
                    },
                    {
                        "id": 4,
                        "text": "Which of these is a valid array declaration?",
                        "options": [
                            "array int marks[5];",
                            "int marks[];",
                            "int marks[5];",
                            "marks[5] int;"
                        ],
                        "correctAnswer": 2,
                        "explanation": "Correct syntax is `datatype name[size];`. `int marks[];` is invalid unless you initialize it immediately."
                    },
                    {
                        "id": 5,
                        "text": "Can an array store different data types (e.g., an int and a float) at the same time?",
                        "options": [
                            "Yes, always",
                            "No, never",
                            "Only if declared as 'mixed'",
                            "Yes, in newer versions of C"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Arrays are homogeneous collections, meaning all elements must be of the exact same data type."
                    }
                ]
            },
            {
                "id": "c20",
                "title": "20. Types of Arrays",
                "duration": "40 mins",
                "content": "# Types of Arrays in C\n\nArrays are classified based on the number of indices (dimensions) used to access their elements.\n\n---\n\n## 1. One-Dimensional Array (1-D)\n\n### üìù What is it?\nA 1-D array is the simplest form, often called a \"list\" or \"vector\". It stores elements in a single linear row.\n\n### ‚ö° Declaration & Memory\n```c\nint arr[5];\n```\n- **Visual:** `[ 10 | 20 | 30 | 40 | 50 ]`\n- **Memory:** Stored in contiguous blocks (e.g., address 1000, 1004, 1008...).\n\n### üöÄ Example: Sum of Elements\n```c\n#include <stdio.h>\n\nint main() {\n    int data[] = {10, 20, 30};\n    int sum = 0;\n\n    for(int i = 0; i < 3; i++) {\n        sum += data[i];\n    }\n    printf(\"Total Sum: %d\", sum);\n    return 0;\n}\n```\n**Expected Output:**\n```text\nTotal Sum: 60\n```\n\n**üí° How it Works:**\n- `data[]` holds 3 numbers: 10, 20, and 30.\n- The loop runs from `i=0` to `i=2`.\n- In each step, `data[i]` is added to `sum`.\n- Finally, the total sum (60) is printed.\n\n---\n\n## 2. Multi-Dimensional Arrays (2-D)\n\n### üìù What is it?\nA 2-D array is like a **Table** or **Matrix** with Rows and Columns. It is essentially an \"Array of Arrays\".\n\n### ‚ö° Declaration Syntax\n```c\ndatatype name[rows][columns];\n```\n\n### üß© Visualizing `int matrix[2][3];`\nThis creates a table with **2 Rows** (0 to 1) and **3 Columns** (0 to 2).\n\n| | Col 0 | Col 1 | Col 2 |\n| :--- | :---: | :---: | :---: |\n| **Row 0** | `[0][0]` | `[0][1]` | `[0][2]` |\n| **Row 1** | `[1][0]` | `[1][1]` | `[1][2]` |\n\n### ‚ö° Initialization Methods\n\n**Method 1: Nested Braces (Recommended)**\nThis clearly shows the structure (Row 0, then Row 1).\n```c\nint grid[2][3] = {\n    {1, 2, 3},  // Row 0 values\n    {4, 5, 6}   // Row 1 values\n};\n```\n\n**Method 2: Linear (Confusing)**\nC allows this, but it's harder to read.\n```c\nint grid[2][3] = {1, 2, 3, 4, 5, 6};\n```\n\n---\n\n## 3. How to Access 2-D Elements\n\nYou need **two loops**: one for rows, one for columns.\n\n### üöÄ Example: Printing a 2x3 Matrix\n\n```c\n#include <stdio.h>\n\nint main() {\n    // Declare and Initialize\n    int matrix[2][3] = {\n        {10, 20, 30},\n        {40, 50, 60}\n    };\n\n    printf(\"Matrix Contents:\\n\");\n\n    // Outer Loop: Iterates through ROWS (0 to 1)\n    for (int i = 0; i < 2; i++) {\n        // Inner Loop: Iterates through COLS (0 to 2)\n        for (int j = 0; j < 3; j++) {\n            printf(\"%d \", matrix[i][j]);\n        }\n        printf(\"\\n\"); // New line after each row\n    }\n    return 0;\n}\n```\n\n**Expected Output:**\n```text\nMatrix Contents:\n10 20 30 \n40 50 60 \n```\n\n**üí° How it Works:**\n- `i=0`: Variable starts at Row 0.\n    - `j=0,1,2`: Prints 10, 20, 30.\n    - `printf(\"\\n\")`: Moves to the next line.\n- `i=1`: Variable moves to Row 1.\n    - `j=0,1,2`: Prints 40, 50, 60.\n\n---\n\n## ‚ö° Key Takeaways\n- **1-D Array**: A simple list. One loop to access.\n- **2-D Array**: A table/grid. Two nested loops to access.\n- **Storage**: Even 2-D arrays are stored linearly in memory (Row-Major order).",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "How many total elements are in the array `int arr[3][4];`?",
                        "options": [
                            "7",
                            "12",
                            "3",
                            "4"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Total elements = Rows √ó Columns. Here, 3 √ó 4 = 12."
                    },
                    {
                        "id": 2,
                        "text": "Which declaration represents a standard 2-D array with 2 Rows and 3 Columns?",
                        "options": [
                            "int arr[2,3];",
                            "int arr[3][2];",
                            "int arr[2][3];",
                            "int arr{2}{3};"
                        ],
                        "correctAnswer": 2,
                        "explanation": "The syntax is `type name[rows][columns]`. So `[2][3]` is correct for 2 rows and 3 columns."
                    },
                    {
                        "id": 3,
                        "text": "If `int grid[2][2] = {{1, 2}, {3, 4}};`, what value is at `grid[1][0]`?",
                        "options": [
                            "1",
                            "2",
                            "3",
                            "4"
                        ],
                        "correctAnswer": 2,
                        "explanation": "`grid[1][0]` refers to the element at Row 1 (second row) and Column 0 (first column). That value is 3."
                    },
                    {
                        "id": 4,
                        "text": "Which dimension can be optional when initializing a 2-D array?",
                        "options": [
                            "Both dimensions",
                            "The second dimension (Columns)",
                            "The first dimension (Rows)",
                            "Neither, both are mandatory"
                        ],
                        "correctAnswer": 2,
                        "explanation": "In logical initialization (e.g., `int a[][3] = ...`), C can infer the number of rows based on the data, but it needs the column count to know where one row ends and the next begins."
                    },
                    {
                        "id": 5,
                        "text": "How are 2-D arrays actually stored in memory in C?",
                        "options": [
                            "Column-Major Order",
                            "Row-Major Order (Row by Row)",
                            "Randomly",
                            "As a linked list"
                        ],
                        "correctAnswer": 1,
                        "explanation": "C stores multi-dimensional arrays in continuous memory, strictly placing the first row, then the next row, and so on (Row-Major)."
                    }
                ]
            },
            {
                "id": "c21",
                "title": "21. Arrays and Functions",
                "duration": "45 mins",
                "content": "# Arrays and Functions in C\n\nA key feature of C is the ability to pass arrays to functions. However, unlike regular variables, arrays behave differently when passed.\n\n---\n\n## 1. The \"Pass by Pointer\" Rule\n\nWhen you pass an array to a function, you are NOT passing a copy of the entire array. Instead, you are passing the **address** (pointer) of the first element.\n\n### ‚ö° Implications\n1.  **Efficiency:** It saves memory (no copying of big data).\n2.  **Modifiable:** The function **CAN modify** the original array.\n3.  **Size Loss:** The function doesn't know the array's size, so you usually pass `size` as a separate argument.\n\n---\n\n## 2. Passing 1-D Arrays\n\n### Syntax\nBoth syntax styles below mean the same thing: \"I expect an integer address\".\n```c\nvoid func(int arr[], int size); // Style 1 (Preferred for readability)\nvoid func(int *arr, int size);  // Style 2 (Shows it's a pointer)\n```\n\n### üöÄ Example: Doubling Array Values\nThis example shows how a function can change the original array's data.\n\n```c\n#include <stdio.h>\n\n// Function to double every number\nvoid doubleValues(int arr[], int size) {\n    for(int i = 0; i < size; i++) {\n        arr[i] = arr[i] * 2;\n    }\n}\n\nint main() {\n    int numbers[] = {1, 2, 3, 4};\n    \n    printf(\"Before: %d %d\\n\", numbers[0], numbers[1]);\n    \n    doubleValues(numbers, 4); // Pass array + size\n    \n    printf(\"After:  %d %d\\n\", numbers[0], numbers[1]);\n    return 0;\n}\n```\n\n### üíª Expected Output\n```text\nBefore: 1 2\nAfter:  2 4\n```\n\n**üí° How it Works:**\n- `doubleValues` receives the address of `numbers`.\n- It loops through the memory, multiplying each value by 2.\n- Since it modified the original memory, `main` sees the changed values.\n\n---\n\n## 3. Protecting Arrays with `const`\n\nSometimes you want to pass an array to a function just to **read** it (e.g., printing), and you want to ensure the function doesn't accidentally change it. Use the `const` keyword.\n\n### Syntax\n```c\nvoid printArray(const int arr[], int size);\n```\n\n### Example\n```c\nvoid printArray(const int arr[], int size) {\n    // arr[0] = 100;  ‚ùå ERROR: Cannot modify a const array\n    printf(\"%d\", arr[0]); // ‚úÖ OK: Reading is allowed\n}\n```\n\n---\n\n## 4. Passing Single Elements (Pass by Value)\n\nIf you pass just one index (e.g., `arr[2]`), it behaves like a normal variable (Pass by Value). The function gets a **copy**, so the original stays unchanged.\n\n### Syntax\n```c\nvoid func(int value); // Receives a copy, not the array\n```\n\n### Example\n```c\nvoid tryToChange(int x) {\n    x = 999;\n}\n\nint main() {\n    int arr[] = {10, 20};\n    tryToChange(arr[0]);\n    printf(\"%d\", arr[0]);\n    return 0;\n}\n```\n\n### üíª Expected Output\n\n```text\n10\n```\n\n---\n\n## 5. Passing 2-D Arrays\n\nWhen passing a multidimensional array, you **MUST specify the number of columns** (the second dimension). The compiler needs this to calculate memory addresses correctly.\n\n### Syntax\n```c\nvoid printGrid(int arr[][3], int rows);\n```\n- `[]` (Rows): Optional / Ignored.\n- `[3]` (Cols): **Mandatory**.\n\n### üöÄ Example: Printing a 2D Array\n```c\n#include <stdio.h>\n\nvoid print2D(int arr[][2], int rows) {\n    for(int i = 0; i < rows; i++) {\n        printf(\"[%d, %d] \\n\", arr[i][0], arr[i][1]);\n    }\n}\n\nint main() {\n    int points[2][2] = {{5, 5}, {10, 10}};\n    print2D(points, 2);\n    return 0;\n}\n```\n\n### üíª Expected Output\n```text\n[5, 5] \n[10, 10] \n```\n\n---\n\n## 6. Can we Return an Array?\n\nThis is a common interview question. **NO**, you cannot directly return a local array from a function.\n\n### Syntax\n```c\nint* getArray(); // Returns a pointer (address)\n```\n\n### ‚ùå The Mistake\n```c\nint* getArray() {\n    int arr[5] = {1, 2, 3, 4, 5};\n    return arr; // ‚ö†Ô∏è DANGER: Returning address of local variable\n}\n```\n**Why?** The local array `arr` is destroyed when `getArray()` finishes. The pointer you return points to \"dead\" memory.\n\n### ‚úÖ The Fix (Static)\nOne simple way is to use `static`, so the memory lasts for the whole program.\n```c\nint* getArray() {\n    static int arr[5] = {1, 2, 3, 4, 5};\n    return arr; // ‚úÖ Safe\n}\n```\n\n---\n\n## 7. Common Pitfalls: The `sizeof` Trap\n\nOne of the biggest mistakes beginners make is using `sizeof` on an array parameter.\n\n```c\nvoid func(int arr[]) {\n    printf(\"%lu\", sizeof(arr)); \n}\n```\n\n### üíª Expected Output\n\n```text\n8\n```\n\n*(Note: 8 is the size of a pointer on most 64-bit systems)*\n```\n**Always pass the size as a separate argument!**\n\n---\n\n## ‚ö° Key Takeaways\n- **Pass as Pointer**: Arrays always decay to pointers when passed.\n- **Use `const`**: To protect arrays from modification.\n- **Size Argument**: Always pass size explicitly.\n- **2-D Arrays**: Columns must be specified.\n- **Returning**: Never return a local array variable.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Why is `sizeof(arr)` unreliable inside a function that receives array `arr`?",
                        "options": [
                            "It returns the size of the first element only",
                            "It returns the size of the pointer (usually 8 bytes), not the full array",
                            "It returns 0",
                            "It causes a compilation error"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Because array parameters decay to pointers, `sizeof` measures the pointer, not the memory block."
                    },
                    {
                        "id": 2,
                        "text": "What happens if you try to modify an array passed as `const int arr[]`?",
                        "options": [
                            "The program crashes at runtime",
                            "The compiler generates an error",
                            "It works fine, constraints are just suggestions",
                            "It creates a local copy and modifies that"
                        ],
                        "correctAnswer": 1,
                        "explanation": "The `const` keyword tells the compiler to enforce read-only access. Any attempt to modify it is a syntax error."
                    },
                    {
                        "id": 3,
                        "text": "What is the danger of returning a local array (non-static) from a function?",
                        "options": [
                            "The values become 0",
                            "The array is promoted to global scope",
                            "It returns a pointer to deallocated/dead memory (Dangling Pointer)",
                            "It works perfectly fine"
                        ],
                        "correctAnswer": 2,
                        "explanation": "Local variables are destroyed when the function exits. The returned pointer points to memory that may be overwritten immediately."
                    },
                    {
                        "id": 4,
                        "text": "Which declaration correctly creates a read-only 2-D array parameter?",
                        "options": [
                            "void func(int arr[][3] const)",
                            "void func(int const arr[][3])",
                            "void func(const int arr[][3])",
                            "void func(const int arr[2])"
                        ],
                        "correctAnswer": 2,
                        "explanation": "`const int arr[][3]` ensures that the integers inside the array cannot be changed."
                    },
                    {
                        "id": 5,
                        "text": "When passing `int arr[5]` to `void func(int x[])`, what is `x`?",
                        "options": [
                            "A full copy of the array",
                            "A pointer to the first integer of arr",
                            "A special array reference type",
                            "The value of the first element"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Technically, `x` is `int*` (a pointer), pointing to `&arr[0]`."
                    }
                ]
            },
            {
                "id": "c22",
                "title": "22. Strings in C",
                "duration": "45 mins",
                "content": "# \nThe C language does not have a built-in string data type like C++ or Java.\nInstead, **strings in C are stored as arrays of characters**, terminated by a \"null byte\".\n\n---\n\n## 1. Internal Representation\n\nA string is just a sequence of characters followed by a special `\\0` character.\n\n### üß† Memory View\nIf we store `\"HELLO\"`:\n| Index | 0 | 1 | 2 | 3 | 4 | 5 |\n| :--- | :---: | :---: | :---: | :---: | :---: | :---: |\n| **Char** | 'H' | 'E' | 'L' | 'L' | 'O' | **'\\0'** |\n\n- **Valuable Payload:** 5 characters.\n- **Micro-Manager:** The `\\0` (Null Terminator) tells functions like `printf` where to stop.\n\n---\n\n## 2. Declaration and Initialization\n\nYou can create strings in two main distinct ways.\n\n### Syntax\n```c\nchar str[] = \"Value\"; // Mutable Array\nchar *str = \"Value\";  // Read-Only Literal\n```\n\n### Method A: Character Array (Mutable)\nThis creates a copy of the string in memory that you can change.\n```c\nchar name[] = \"Alice\";\nname[0] = 'B'; // ‚úÖ OK: Becomes \"Blice\"\n```\n\n### Method B: String Literal (Read-Only)\nThis points to a fixed storage location.\n```c\nchar *name = \"Alice\";\n// name[0] = 'B'; // ‚ùå ERROR: Crash (Undefined Behavior)\n```\n\n---\n\n## 3. Reading Strings (Input)\n\nReading strings is trickier than numbers because of spaces.\n\n### Method A: `scanf` (The Simple Way)\nGood for single words. Stops at the first space.\n```c\nchar name[20];\nprintf(\"Enter name: \");\nscanf(\"%s\", name); // ‚ö†Ô∏è No & needed for arrays\n```\n*Input: \"John Doe\" ‚Üí Stored: \"John\"*\n\n### Method B: `fgets` (The Safe Way)\nBest for sentences. Reads spaces and prevents overflow.\n```c\nchar buffer[50];\nprintf(\"Enter full name: \");\nfgets(buffer, 50, stdin);\n```\n*Input: \"John Doe\" ‚Üí Stored: \"John Doe\"*\n\n### üöÄ Example: Safe String Input\n```c\n#include <stdio.h>\n\nint main() {\n    char name[20];\n    \n    printf(\"Who are you? \");\n    fgets(name, 20, stdin); // Safe reading\n    \n    printf(\"Hello, %s\", name);\n    return 0;\n}\n```\n\n**Expected Output:**\n```text\nWho are you? Gen Spark\nHello, Gen Spark\n```\n\n**üí° How it Works:**\n- `fgets` reads up to 19 characters + 1 null terminator.\n- It includes the space in \"Gen Spark\".\n- It reads from simple standard input (`stdin`).\n\n---\n\n## 4. Common Operations\n\n| Operation | Function | Example |\n| :--- | :--- | :--- |\n| **Length** | `strlen(s)` | Count chars (excludes `\\0`) |\n| **Copy** | `strcpy(dest, src)` | Copy `src` to `dest` |\n| **Compare** | `strcmp(s1, s2)` | Returns 0 if equal |\n| **Combine** | `strcat(dest, src)` | Append `src` into `dest` |\n\n---\n\n## ‚ö° Key Takeaways\n- **Null Terminator**: Strings MUST end with `\\0`.\n- **Space Allocation**: Always allocate `length + 1` for the null byte.\n- **Input**: Use `fgets` for text with spaces, `scanf` for single words.\n- **Mutability**: Arrays (`char[]`) are editable; Literals (`char*`) are not.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "How many bytes of memory are required to store the string \"Cat\"?",
                        "options": [
                            "3 bytes",
                            "4 bytes",
                            "8 bytes",
                            "Unknown"
                        ],
                        "correctAnswer": 1,
                        "explanation": "You need 3 bytes for 'C', 'a', 't' plus 1 byte for the null terminator '\\0'. Total = 4."
                    },
                    {
                        "id": 2,
                        "text": "Which method should you use to read a sentence with spaces (e.g., \"Hello World\")?",
                        "options": [
                            "scanf(\"%s\", str);",
                            "fgets(str, size, stdin);",
                            "read(str);",
                            "cin >> str;"
                        ],
                        "correctAnswer": 1,
                        "explanation": "`scanf` stops reading at the first whitespace. `fgets` reads until the newline character, capturing the full sentence."
                    },
                    {
                        "id": 3,
                        "text": "What happens if you try: char *s = \"Hi\"; s[0] = 'B'; ?",
                        "options": [
                            "The string becomes \"Bi\"",
                            "Compiler Error",
                            "Runtime Crash (Undefined Behavior)",
                            "Nothing happens"
                        ],
                        "correctAnswer": 2,
                        "explanation": "String literals defined with `char *` are usually stored in read-only memory. Modifying them causes undefined behavior (often a crash)."
                    },
                    {
                        "id": 4,
                        "text": "What is the index of the null terminator in `char s[] = \"CODE\"`?",
                        "options": [
                            "3",
                            "4",
                            "5",
                            "0"
                        ],
                        "correctAnswer": 1,
                        "explanation": "C=0, O=1, D=2, E=3, \\0=4."
                    },
                    {
                        "id": 5,
                        "text": "Why do we use `strcpy` instead of `str1 = str2` for arrays?",
                        "options": [
                            "Because arrays cannot be assigned directly in C",
                            "Because strcpy is faster",
                            "Because = is for numbers only",
                            "Because it looks cooler"
                        ],
                        "correctAnswer": 0,
                        "explanation": "Arrays in C are not first-class objects that support direct assignment. You must copy them element-by-element or use `strcpy`."
                    }
                ]
            },
            {
                "id": "c23",
                "title": "23. String Functions in C",
                "duration": "50 mins",
                "content": "# String Functions in C\n\nTo work with strings efficiently, C provides standard functions in the **`<string.h>`** library. These functions rely on one critical rule: **The string must end with a `\\0`**.\n\n```c\n#include <string.h>\n```\n\n---\n\n## 1. strlen (String Length)\n\nCalculates the length of a string, **excluding** the null terminator.\n\n### Syntax\n```c\nsize_t strlen(const char *str);\n```\n\n### üöÄ Example\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char s[] = \"Code\";\n    printf(\"Length: %d\\n\", strlen(s));\n    printf(\"Size: %d\\n\", sizeof(s));\n    return 0;\n}\n```\n\n**Expected Output:**\n```text\nLength: 4\nSize: 5\n```\n\n**üí° How it Works:**\n- `strlen` counts 'C', 'o', 'd', 'e' (4).\n- `sizeof` counts all bytes including `\\0` (5).\n\n---\n\n## 2. strcpy (String Copy)\n\nCopies a string from specific source to destination. **Unsafe** if destination is too small.\n\n### Syntax\n```c\nchar* strcpy(char *dest, const char *src);\n```\n\n### üöÄ Example\n```c\nchar src[] = \"Hello\";\nchar dest[20]; // Ensure this is big enough!\n\nstrcpy(dest, src);\nprintf(\"Copied: %s\", dest);\n```\n\n**Expected Output:**\n```text\nCopied: Hello\n```\n\n**üí° How it Works:**\n- Copies 'H', 'e', 'l', 'l', 'o', and the null byte `\\0` to `dest`.\n\n---\n\n## 3. strncpy (Safe String Copy)\n\nCopies AT MOST `n` characters. Safer, but tricky with null termination.\n\n### Syntax\n```c\nchar* strncpy(char *dest, const char *src, size_t n);\n```\n\n### üöÄ Example\n```c\nchar src[] = \"Hello World\";\nchar dest[6];\n\nstrncpy(dest, src, 5); // Copy only 5 chars\ndest[5] = '\\0';       // ‚ö†Ô∏è Manual termination needed!\n\nprintf(\"Safe Copy: %s\", dest);\n```\n\n**Expected Output:**\n```text\nSafe Copy: Hello\n```\n\n**üí° How it Works:**\n- Copies only first 5 chars.\n- Since `n` was reached before `\\0`, it stops **without** adding `\\0`.\n- We manually add `dest[5] = '\\0'` to make it a valid string.\n\n---\n\n## 4. strcat (String Concatenation)\n\nAppends (joins) source to the end of destination.\n\n### Syntax\n```c\nchar* strcat(char *dest, const char *src);\n```\n\n### üöÄ Example\n```c\nchar dest[20] = \"Hello \";\nchar src[] = \"World\";\n\nstrcat(dest, src);\nprintf(\"Joined: %s\", dest);\n```\n\n**Expected Output:**\n```text\nJoined: Hello World\n```\n\n**üí° How it Works:**\n- Finds the `\\0` in \"Hello \".\n- Overwrites it with 'W' from \"World\".\n- Copies the rest and adds a new `\\0`.\n\n---\n\n## 5. strncat (Safe Concatenation)\n\nAppends at most `n` characters. Automatically adds `\\0`.\n\n### Syntax\n```c\nchar* strncat(char *dest, const char *src, size_t n);\n```\n\n### üöÄ Example\n```c\nchar dest[20] = \"Hello \";\nstrncat(dest, \"Beautiful World\", 9);\nprintf(\"%s\", dest);\n```\n\n**Expected Output:**\n```text\nHello Beautiful\n```\n\n**üí° How it Works:**\n- Takes only first 9 characters from source.\n- ALWAYS adds a `\\0` at the end (unlike `strncpy`).\n\n---\n\n## 6. strcmp (String Compare)\n\nCompares two strings character by character (ASCII).\n\n### Syntax\n```c\nint strcmp(const char *s1, const char *s2);\n```\n\n### üöÄ Example\n```c\nif(strcmp(\"Apple\", \"Banana\") < 0) {\n    printf(\"Apple comes first\");\n}\n```\n\n**Expected Output:**\n```text\nApple comes first\n```\n\n**üí° How it Works:**\n- 'A' (65) - 'B' (66) = -1 (Negative).\n- Negative means `s1` is alphabetically smaller.\n\n---\n\n## 7. strncmp (Safe Compare)\n\nCompares only the first `n` characters.\n\n### Syntax\n```c\nint strncmp(const char *s1, const char *s2, size_t n);\n```\n\n### üöÄ Example\n```c\nif(strncmp(\"ApplePie\", \"AppleSauce\", 5) == 0) {\n    printf(\"First 5 chars match\");\n}\n```\n\n**Expected Output:**\n```text\nFirst 5 chars match\n```\n\n**üí° How it Works:**\n- Checks 'A', 'p', 'p', 'l', 'e'. All match.\n- Returns 0 (Equal).\n\n---\n\n## 8. strchr (Find Character)\n\nFinds the **first** occurrence of a character.\n\n### Syntax\n```c\nchar* strchr(const char *str, int c);\n```\n\n### üöÄ Example\n```c\nchar s[] = \"google.com\";\nchar *ptr = strchr(s, '.');\nprintf(\"Domain: %s\", ptr);\n```\n\n**Expected Output:**\n```text\nDomain: .com\n```\n\n**üí° How it Works:**\n- Scans for '.'.\n- Returns pointer to that '.' in memory.\n- Printing `ptr` prints from '.' onwards.\n\n---\n\n## 9. strrchr (Find Last Character)\n\nFinds the **last** occurrence of a character.\n\n### Syntax\n```c\nchar* strrchr(const char *str, int c);\n```\n\n### üöÄ Example\n```c\nchar s[] = \"/home/user/docs/file.txt\";\nchar *file = strrchr(s, '/');\nprintf(\"Filename: %s\", file + 1); // +1 skip '/'\n```\n\n**Expected Output:**\n```text\nFilename: file.txt\n```\n\n**üí° How it Works:**\n- Finds the *last* slash.\n- `file` points to `/file.txt`.\n- `file + 1` skips the slash.\n\n---\n\n## 10. strstr (Find Substring)\n\nFinds the first occurrence of a substring.\n\n### Syntax\n```c\nchar* strstr(const char *haystack, const char *needle);\n```\n\n### üöÄ Example\n```c\nchar s[] = \"C Programming is fun\";\nchar *ptr = strstr(s, \"gram\");\nprintf(\"Found: %s\", ptr);\n```\n\n**Expected Output:**\n```text\nFound: gramming is fun\n```\n\n**üí° How it Works:**\n- Looks for sequence \"gram\".\n- Returns pointer to 'g'.\n\n---\n\n## 11. strtok (String Tokenize)\n\nSplits a string into tokens. **Destructive** (modifies original string).\n\n### Syntax\n```c\nchar* strtok(char *str, const char *delim);\n```\n\n### üöÄ Example\n```c\nchar s[] = \"HTML,CSS,JS\";\nchar *token = strtok(s, \",\");\n\nwhile (token != NULL) {\n    printf(\"Lang: %s\\n\", token);\n    token = strtok(NULL, \",\"); // Pass NULL to continue\n}\n```\n\n**Expected Output:**\n```text\nLang: HTML\nLang: CSS\nLang: JS\n```\n\n**üí° How it Works:**\n- Finds first `,` and replaces it with `\\0`.\n- Returns pointer to \"HTML\".\n- `NULL` tells it to continue from where it left off (using static memory).\n\n---\n\n## ‚ö° Key Takeaways\n- **Safety**: Prefer `n` versions (`strncpy`, `strncat`) to avoid overflows.\n- **Termination**: `strncpy` might NOT add `\\0`; do it manually.\n- **Destruction**: `strtok` modifies your string; use a copy if needed.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What is the key difference between `strcpy` and `strncpy`?",
                        "options": [
                            "strcpy is faster",
                            "strncpy copies a limited number of chars, preventing some overflows",
                            "They are the same",
                            "strcpy works on numbers"
                        ],
                        "correctAnswer": 1,
                        "explanation": "`strncpy` takes a size limit `n`, which helps prevent writing past the destination buffer, although you must be careful with null termination."
                    },
                    {
                        "id": 2,
                        "text": "Why must you manually add `\\0` after `strncpy` sometimes?",
                        "options": [
                            "Because C is annoying",
                            "If the source length >= n, strncpy stops strictly at n without adding \\0",
                            "strncpy never adds \\0",
                            "It is a compiler bug"
                        ],
                        "correctAnswer": 1,
                        "explanation": "If the source string length is equal to or greater than the limit `n`, `strncpy` will fill the buffer but won't append the null terminator."
                    },
                    {
                        "id": 3,
                        "text": "What does `strrchr` do differently from `strchr`?",
                        "options": [
                            "Finds the first occurrence",
                            "Finds the last occurrence",
                            "Finds random occurrences",
                            "Nothing, they are aliases"
                        ],
                        "correctAnswer": 1,
                        "explanation": "The extra 'r' stands for 'reverse' or 'right'. It searches for the **last** occurrence of the character."
                    },
                    {
                        "id": 4,
                        "text": "Which function modifies the original string by inserting null bytes?",
                        "options": [
                            "strstr",
                            "strcmp",
                            "strtok",
                            "strlen"
                        ],
                        "correctAnswer": 2,
                        "explanation": "`strtok` breaks strings by replacing delimiters (e.g., comma) with `\\0` to isolate tokens."
                    },
                    {
                        "id": 5,
                        "text": "If `strcmp(A, B)` returns -5, what does it mean?",
                        "options": [
                            "A is equal to B",
                            "A is greater than B",
                            "A is smaller than B",
                            "String A has 5 chars"
                        ],
                        "correctAnswer": 2,
                        "explanation": "Any negative value means the first string is lexicographically (alphabetically) smaller than the second."
                    }
                ]
            }
        ]
    },
    {
        "id": "c-l5",
        "title": "LEVEL 5: Pointers",
        "lessons": [
            {
                "id": "c24",
                "title": "24. Introduction to Pointers",
                "duration": "45 mins",
                "content": "# Introduction to Pointers in C\n\nPointers are one of the most powerful and distinctive features of C. While normal variables store **values** (like `10` or `'A'`), pointers store **memory addresses** (like `0x7ffee4` or `1002`).\n\nUnderstanding pointers gives you direct control over memory, which is essential for advanced programming.\n\n---\n\n## 1. The Concept of Memory\n\nEvery variable you declare lives at a specific location in your computer's memory (RAM). This location has a unique number called an **Address**.\n\n### ‚ö° Visualization\nImagine memory as a street with houses. Each house has an address.\n- **Variable**: The house itself.\n- **Value**: The people inside the house.\n- **Address**: The house number (e.g., House No. 104).\n\nIf you want to find the people (Value), you go to the address.\n\n---\n\n## 2. Key Operators\n\nTo work with pointers, you need two special operators:\n\n### üìç Address-of Operator (`&`)\nReturns the memory address of a variable.\n- Syntax: `&x` gives the address of x.\n\n### üéØ Dereference Operator (`*`)\nAccesses the value stored at a specific address.\n- Syntax: `*p` gives the value stored at the address `p`.\n\n---\n\n## 3. Declaring and Using Pointers\n\n### Syntax\n```c\ndatatype *pointer_name;\n```\n- `int *p`: A pointer that stores the address of an integer.\n- `char *c`: A pointer that stores the address of a character.\n\n### üöÄ Example: The Basics\n\n```c\n#include <stdio.h>\n\nint main() {\n    int num = 100;\n    int *ptr = &num; // ptr now holds the address of num\n\n    printf(\"Value of num: %d\\n\", num);\n    printf(\"Address of num: %p\\n\", &num);\n    printf(\"Value stored in ptr: %p\\n\", ptr);\n    printf(\"Value pointed to by ptr: %d\\n\", *ptr);\n\n    return 0;\n}\n```\n\n**Expected Output:**\n```text\nValue of num: 100\nAddress of num: 0061FF1C (This changes every run)\nValue stored in ptr: 0061FF1C\nValue pointed to by ptr: 100\n```\n\n**üí° How it Works:**\n1.  `int num = 100;`: Creates an integer variable at address `X`.\n2.  `int *ptr = &num;`: Creates a pointer `ptr` and stores `X` in it.\n3.  `*ptr`: Goes to address `X` and reads the value `100`.\n\n---\n\n## 4. The Syntax Confusion: `*` vs `*`\n\nThe asterisk `*` has two different meanings depending on where it is used. This is a common source of confusion!\n\n### A. In Declaration\nWhen you see `*` during variable creation, it means **\"I am a pointer\"**.\n\n```c\nint *p; // Create a pointer named p\n```\n\n### B. In Usage (Dereference)\nWhen you see `*` before an existing variable, it means **\"Go to the address\"**.\n\n```c\n*p = 50; // Go to the address in p and store 50\n```\n\n**Simple Rule:**\n- `int *p` -> Type definition (Noun)\n- `*p` -> Action (Verb)\n\n---\n\n## 5. Pointer Size\n\nQ: How big is a pointer? \nA: It depends on your computer's architecture (CPU).\n\n- **32-bit system**: Pointers are **4 bytes** (32 bits).\n- **64-bit system**: Pointers are **8 bytes** (64 bits).\n\nInterestingly, `sizeof(char*)`, `sizeof(int*)`, and `sizeof(double*)` are **ALL THE SAME**. Why? Because they all store an address, and an address is just a number. The data type only tells the compiler *how much* data to read once it gets there.\n\n---\n\n## 6. Modifying Values via Pointers\n\nYou can change a variable's value through its pointer using the dereference operator.\n\n```c\n#include <stdio.h>\n\nint main() {\n    int x = 10;\n    int *p = &x;\n\n    *p = 20; // Go to address 'p' and put 20 there\n    \n    printf(\"x is now: %d\", x);\n    return 0;\n}\n```\n\n**Expected Output:**\n```text\nx is now: 20\n```\n\n---\n\n## 7. Common Pitfalls: Wild Pointers\n\nNever declare a pointer without initializing it!\n\n```c\nint *p; // DANGER! Points to a random random memory location\n*p = 10; // CRASH! You just wrote to an unknown address\n```\n\n**Best Practice**: Always initialize to `NULL` if you don't have an address yet.\n```c\nint *ptr = NULL; // Safe\n```\n\n---\n\n## ‚ö° Key Takeaways\n- **& (Ampersand)**: Get the address.\n- **\\* (Asterisk)**: Get the value at the address.\n- **Size**: All pointers are the same size (4 or 8 bytes) regardless of type.\n- **Safety**: Uninitialized pointers are dangerous. Use `NULL`.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What does the `&` operator return?",
                        "options": [
                            "The value of a variable",
                            "The memory address of a variable",
                            "The size of a variable",
                            "The data type of a variable"
                        ],
                        "correctAnswer": 1,
                        "explanation": "The & (ampersand) is the 'Address-of' operator. &x returns the memory location where x is stored."
                    },
                    {
                        "id": 2,
                        "text": "If `int x = 10;` and `int *p = &x;`, what is the value of `*p`?",
                        "options": [
                            "The address of x",
                            "10",
                            "Garbage value",
                            "0"
                        ],
                        "correctAnswer": 1,
                        "explanation": "`*p` (Dereference) goes to the address stored in p (which is x's address) and retrieves the value stored there (10)."
                    },
                    {
                        "id": 3,
                        "text": "What is proper syntax to declare a pointer to an integer?",
                        "options": [
                            "pointer int p;",
                            "int p*;",
                            "int *p;",
                            "int &p;"
                        ],
                        "correctAnswer": 2,
                        "explanation": "The correct syntax is `datatype *name;`. For example, `int *p;`."
                    },
                    {
                        "id": 4,
                        "text": "What happens if you try to dereference a NULL pointer?",
                        "options": [
                            "It returns 0",
                            "It creates a new variable",
                            "The program crashes (Segmentation Fault)",
                            "It returns a random value"
                        ],
                        "correctAnswer": 2,
                        "explanation": "A NULL pointer leads to nowhere. Attempting to read/write to address 0 causes the OS to stop the program for safety."
                    },
                    {
                        "id": 5,
                        "text": "Which statement sets the value of x to 50 using pointer p (where p = &x)?",
                        "options": [
                            "p = 50;",
                            "&p = 50;",
                            "*p = 50;",
                            "p* = 50;"
                        ],
                        "correctAnswer": 2,
                        "explanation": "`*p = 50` means 'Go to the address p points to, and store 50 there'. `p = 50` would change the address itself."
                    }
                ]
            },
            {
                "id": "c25",
                "title": "25. Pointer Arithmetic",
                "duration": "35 mins",
                "content": "# Pointer Arithmetic in C\n\nPointers don't just point to fixed memory locations; they can effectively \"move\" through memory. This is called **Pointer Arithmetic**, and it is the foundation of how C handles arrays and strings efficiently.\n\n---\n\n## 1. How Pointers Move (Scaling)\n\nWhen you add `1` to a pointer (`ptr++`), it doesn't just increase the address by 1 byte. C automatically scales the movement based on the **size of the data type** it points to.\n\n- **char** pointer increments by **1 byte**.\n- **int** pointer increments by **4 bytes** (usually).\n- **double** pointer increments by **8 bytes**.\n\n### üöÄ Example: Scaling Visualization\n```c\n#include <stdio.h>\n\nint main() {\n    int num = 10;\n    int *ptr = &num;\n\n    printf(\"Initial Address: %p\\n\", ptr);\n    ptr++; // Moves to next integer slot\n    printf(\"After ptr++:     %p\\n\", ptr);\n\n    return 0;\n}\n```\n\n**Expected Output:**\n```text\nInitial Address: 0061FF10\nAfter ptr++:     0061FF14 (Notice the +4 jump)\n```\n\n---\n\n## 2. Supported Operations\n\nC allows only specific arithmetic operations on pointers:\n\n### ‚ûï Addition (`ptr + n`)\nMoves the pointer `n` positions forward in memory.\n\n### ‚ûñ Subtraction (`ptr - n`)\nMoves the pointer `n` positions backward in memory.\n\n### üìè Distance (`ptr2 - ptr1`)\nSubtracting two pointers of the **same type** gives the number of **elements** (not bytes) between them.\n\n---\n\n## 3. Pointer Comparison\n\nYou can compare two pointers using relational operators (`<`, `>`, `==`, etc.). This is useful when you want to check if a pointer is within the bounds of an array or if two pointers point to the same location.\n\n```c\nif (p1 == p2) {\n    printf(\"Both point to the same address\");\n}\n\nif (p1 > p2) {\n    printf(\"p1 is further ahead in memory than p2\");\n}\n```\n\n---\n\n## 4. Illegal Operations üö´\n\nNot everything is allowed in pointer arithmetic. You **CANNOT**:\n- Add two pointers (`ptr1 + ptr2` is illegal).\n- Multiply or divide pointers.\n- Add a floating-point number to a pointer.\n\n---\n\n## 5. Practical Use: Array Traversal\n\nUsing pointer arithmetic, you can access array elements without using the square bracket `[]` syntax.\n\n```c\n#include <stdio.h>\n\nint main() {\n    int arr[] = {10, 20, 30};\n    int *p = arr; // Points to first element\n\n    for(int i = 0; i < 3; i++) {\n        printf(\"Element %d: %d\\n\", i, *(p + i));\n    }\n    return 0;\n}\n```\n\n**üí° How it Works:**\n- `*(p + 0)` is the same as `arr[0]`.\n- `*(p + 1)` moves forward 4 bytes to `arr[1]`.\n- `*(p + 2)` moves forward 8 bytes to `arr[2]`.\n\n---\n\n## ‚ö° Key Takeaways\n- **Scaling**: Movement is proportional to the size of the data type.\n- **Distance**: Subtraction returns the count of items between pointers.\n- **Bounds**: Always ensure your arithmetic doesn't move the pointer outside valid memory bounds.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "If `int` is 4 bytes, and pointer `p` is at address 1000, what is the address after `p++`?",
                        "options": [
                            "1001",
                            "1004",
                            "1008",
                            "1002"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Since `int` takes 4 bytes, incrementing an int pointer moves it forward by 4 memory locations (1000 -> 1004)."
                    },
                    {
                        "id": 2,
                        "text": "Subtracting two pointers (`ptr2 - ptr1`) results in:",
                        "options": [
                            "The sum of their addresses",
                            "The number of bytes between them",
                            "The number of elements between them",
                            "A compilation error"
                        ],
                        "correctAnswer": 2,
                        "explanation": "Pointer subtraction returns the number of elements fitting between the two addresses, not the raw byte count."
                    },
                    {
                        "id": 3,
                        "text": "If you have `char *c` at 2000, what is the address of `c + 2`?",
                        "options": [
                            "2001",
                            "2002",
                            "2004",
                            "2008"
                        ],
                        "correctAnswer": 1,
                        "explanation": "`char` is 1 byte. Adding 2 moves the pointer by 2 * 1 = 2 bytes. 2000 + 2 = 2002."
                    },
                    {
                        "id": 4,
                        "text": "Which of the following operations is ILLEGAL on pointers?",
                        "options": [
                            "ptr + 5",
                            "ptr1 - ptr2",
                            "ptr1 + ptr2",
                            "ptr--"
                        ],
                        "correctAnswer": 2,
                        "explanation": "Adding two pointers is illegal in C because the result would be a memory address that has no logical meaning."
                    },
                    {
                        "id": 5,
                        "text": "If `ptr1` points to `arr[0]` and `ptr2` points to `arr[5]`, what is the result of `ptr1 < ptr2`?",
                        "options": [
                            "1 (True)",
                            "0 (False)",
                            "Compilation Error",
                            "Random value"
                        ],
                        "correctAnswer": 0,
                        "explanation": "Relational operators work on pointers. Since `arr[0]` comes before `arr[5]` in memory, `ptr1 < ptr2` is true (evaluates to 1)."
                    }
                ]
            },
            {
                "id": "c26",
                "title": "26. Pointers & Arrays",
                "duration": "40 mins",
                "content": "# Pointers and Arrays: The Connection\n\nIn C, arrays and pointers are so closely related that they are often used interchangeably. However, understanding their subtle differences is key to mastering memory management.\n\n---\n\n## 1. The Decay Rule\n\nThe name of an array acts as a **constant pointer** to its first element. When you use an array name in an expression, it \"decays\" into a pointer.\n\n```c\nint arr[3] = {10, 20, 30};\nint *p = arr; // Equivalent to p = &arr[0];\n```\n\n### ‚ö° Visualization\nImagine `arr` is the starting point of a block of memory. \n- `arr` is the address of the first house.\n- `arr + 1` is the address of the next house (4 bytes away if it's an int).\n\n---\n\n## 2. Notation Equivalence\n\nYou can access array elements using either indexing `[]` or pointer notation `*`. They are exactly the same in C.\n\n| Index Notation | Pointer Notation | Result |\n| :--- | :--- | :--- |\n| `arr[0]` | `*arr` | 10 |\n| `arr[1]` | `*(arr + 1)` | 20 |\n| `arr[i]` | `*(arr + i)` | Value at index i |\n\n### ü§Ø Fun Fact: `i[arr]`\nBecause `arr + i` is the same as `i + arr`, the syntax `i[arr]` is also valid! \n`2[arr]` is same as `arr[2]`. While valid, it is usually avoided for clarity.\n\n---\n\n## 3. Arrays as Function Arguments\n\nWhen you pass an array to a function, C **always** passes it as a pointer. This is why the function doesn't know the size of the array unless you pass it as a second argument.\n\n```c\nvoid printArray(int *ptr, int size) {\n    for(int i = 0; i < size; i++) {\n        printf(\"%d \", *(ptr + i));\n    }\n}\n```\n\n---\n\n## 4. Array Name vs. Pointer Variable\n\nWhile they behave similarly, there is one giant difference: **An array name is a constant, while a pointer is a variable.**\n\n```c\nint arr[5];\nint *p = arr;\n\np++;   // ‚úÖ LEGAL: p is a variable that stores an address\narr++; // ‚ùå ILLEGAL: arr is the name of the memory block\n```\n\n---\n\n## 5. The `sizeof` Distinction\n\nThis is a common interview trap:\n- `sizeof(array)` returns the size of the **entire block**.\n- `sizeof(pointer)` returns the size of the **address** (usually 8 bytes on 64-bit systems).\n\n```c\nint arr[10]; // 10 ints * 4 bytes = 40 bytes\nint *p = arr;\n\nprintf(\"Array size: %zu\\n\", sizeof(arr));   // Output: 40\nprintf(\"Pointer size: %zu\\n\", sizeof(p));   // Output: 8\n```\n\n---\n\n## ‚ö° Key Takeaways\n- **Decay**: Arrays decay to pointers when used or passed to functions.\n- **Constant**: You cannot change where an array name points (`arr++` fails).\n- **Size**: `sizeof` behaves differently for arrays vs. pointers.\n- **Access**: `arr[i]` is just a shortcut for `*(arr + i)`.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Which expression is equivalent to `arr[2]`?",
                        "options": [
                            "*(arr + 2)",
                            "*arr + 2",
                            "&arr + 2",
                            "arr + 2"
                        ],
                        "correctAnswer": 0,
                        "explanation": "`arr[2]` accesses the value at index 2. In pointer notation, this is `*(arr + 2)`."
                    },
                    {
                        "id": 2,
                        "text": "What is the relationship between an array name and a pointer?",
                        "options": [
                            "They are unrelated",
                            "An array name acts as a constant pointer to the first element",
                            "A pointer is always larger",
                            "Array names cannot be used as pointers"
                        ],
                        "correctAnswer": 1,
                        "explanation": "In most contexts, the array name evaluates to the address of the first element (it decays to a pointer)."
                    },
                    {
                        "id": 3,
                        "text": "Why is `arr++` illegal if `arr` is an array name?",
                        "options": [
                            "Because arrays are too large",
                            "Because array names are constant pointers",
                            "Because pointers cannot be incremented",
                            "It is actually legal"
                        ],
                        "correctAnswer": 1,
                        "explanation": "An array name is a label for a fixed block of memory. You cannot change what address it refers to."
                    },
                    {
                        "id": 4,
                        "text": "If an array `int arr[5]` is passed to a function, what does `sizeof(arr)` inside the function return?",
                        "options": [
                            "20 bytes (total array size)",
                            "The size of a pointer (4 or 8 bytes)",
                            "5 (number of elements)",
                            "0"
                        ],
                        "correctAnswer": 1,
                        "explanation": "When passed to a function, an array decays to a pointer. `sizeof` will therefore return the size of that pointer, not the original array."
                    },
                    {
                        "id": 5,
                        "text": "Is `i[arr]` a valid expression in C?",
                        "options": [
                            "No, it's a syntax error",
                            "Yes, it's equivalent to arr[i]",
                            "Only for character arrays",
                            "Only in C++"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Because internally `arr[i]` is `*(arr + i)`, and addition is commutative, `i[arr]` (which is `*(i + arr)`) works perfectly."
                    }
                ]
            },
            {
                "id": "c27",
                "title": "27. Advanced Pointers (Pointer to Pointer)",
                "duration": "45 mins",
                "content": "# Pointer to Pointer (Double Pointer)\n\nPointers allow us to manipulate memory addresses. But what happens when we need to store the address of a pointer itself? This is known as **Multiple Indirection** or a **Double Pointer**.\n\n---\n\n## 1. The Chain of Indirection\n\nTo understand a double pointer, think of a chain where each level points to the next:\n\n1.  **Level 0 (Value)**: An actual data value (e.g., `int x = 10;`).\n2.  **Level 1 (Pointer)**: Stores the address of the value (`int *p1 = &x;`).\n3.  **Level 2 (Double Pointer)**: Stores the address of the pointer (`int **p2 = &p1;`).\n\n### ‚ö° Visualization\nSuppose memory addresses are simplified numbers:\n- `x` is at address `1000`, value is `10`.\n- `p1` is at address `2000`, value is `1000` (address of x).\n- `p2` is at address `3000`, value is `2000` (address of p1).\n\nTo get back to `10` using `p2`, you use two asterisks: `**p2` (Go to 2000, then go to 1000, find 10).\n\n---\n\n## 2. Why Use Double Pointers?\n\nWhile they seem complex, double pointers are essential for two main tasks in C:\n\n### A. Modifying a Pointer inside a Function\nIn C, if you pass a pointer to a function, the function receives a **copy** of that pointer. If you want the function to change where the *original* pointer in the caller points, you must pass its address.\n\n```c\nvoid allocateValue(int **ptr) {\n    static int val = 50;\n    *ptr = &val; // Modifies the original pointer to point to 'val'\n}\n\nint main() {\n    int *p = NULL;\n    allocateValue(&p); // Pass address of the pointer\n    printf(\"%d\", *p); // Output: 50\n}\n```\n\n### B. Dynamic 2D Arrays\nA 2D array can be managed as an \"array of pointers.\" In this case, each element of an array is a pointer to another array (a row). To store the address of such an array of pointers, you need a double pointer.\n\n```c\nint **matrix = malloc(rows * sizeof(int *));\nfor(int i = 0; i < rows; i++) {\n    matrix[i] = malloc(cols * sizeof(int));\n}\n```\n\n---\n\n## 3. Beyond Double Pointers\n\nCan you have `int ***p`? **Yes**. This is a **Triple Pointer** (Pointer to a Pointer to a Pointer). While C allows any number of levels (`****p`), anything beyond 2 or 3 levels is rarely used because it becomes extremely difficult to read and manage.\n\n---\n\n## ‚ö° Key Takeaways\n- **Syntax**: `int **p` is a pointer that points to another `int *`.\n- **Dereferencing**: `**p` gives the final integer value.\n- **Functions**: Use double pointers to let a function modify a pointer defined in `main`.\n- **2D Memory**: Essential for creating dynamic matrices and complex data structures.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What does `int **p;` declare?",
                        "options": [
                            "A pointer to an integer",
                            "A pointer to a pointer to an integer",
                            "A function returning an integer",
                            "Two integer pointers"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Two asterisks (`**`) indicate a pointer to a pointer. It holds the address of another pointer variable."
                    },
                    {
                        "id": 2,
                        "text": "If `p2` is a double pointer and `*p2` is a pointer, what does `**p2` represent?",
                        "options": [
                            "An address of a pointer",
                            "An address of a variable",
                            "The final value stored in the variable",
                            "A compilation error"
                        ],
                        "correctAnswer": 2,
                        "explanation": "Double dereferencing (`**`) follows both addresses in the chain to reach the actual data value."
                    },
                    {
                        "id": 3,
                        "text": "Why would you pass `&ptr` (address of a pointer) to a function?",
                        "options": [
                            "To make the function run faster",
                            "To allow the function to change where the original 'ptr' points",
                            "To protect the pointer from being changed",
                            "Because C requires it for all pointers"
                        ],
                        "correctAnswer": 1,
                        "explanation": "To modify a variable (even a pointer) in the caller's scope, you must pass its address. For a pointer variable, that means passing a double pointer."
                    },
                    {
                        "id": 4,
                        "text": "What is the correct way to initialize a double pointer `pp` to point to pointer `p`?",
                        "options": [
                            "pp = p;",
                            "pp = *p;",
                            "pp = &p;",
                            "*pp = &p;"
                        ],
                        "correctAnswer": 2,
                        "explanation": "Since `pp` stores the address of a pointer, you must use the address-of operator `&` on the pointer `p`."
                    },
                    {
                        "id": 5,
                        "text": "Is there a limit to the levels of indirection (e.g., `*****p`) in C?",
                        "options": [
                            "Yes, maximum 2 levels",
                            "Yes, maximum 3 levels",
                            "No, but excessive levels are rare and hard to read",
                            "Only pointers to integers can have multiple levels"
                        ],
                        "correctAnswer": 2,
                        "explanation": "C allows multiple levels of indirection, though more than 3 is rarely seen in professional code."
                    }
                ]
            }
        ]
    },
    {
        "id": "c-l6",
        "title": "LEVEL 6: Dynamic Memory Allocation",
        "lessons": [
            {
                "id": "c28",
                "title": "28. Introduction to DMA",
                "duration": "35 mins",
                "content": "# Introduction to Dynamic Memory Allocation (DMA)\n\nIn C, memory can be allocated in two main ways: **Static** and **Dynamic**. Understanding the difference is crucial for writing efficient programs that can handle variable amounts of data.\n\n---\n\n## 1. Static vs. Dynamic Memory\n\n### üì¶ Static Memory (Stack)\nWhen you declare an array like `int arr[10];`, the size is fixed at compile time. This memory is managed by the **Stack**.\n- **Pros**: Very fast, automatic management.\n- **Cons**: Fixed size, cannot be changed during runtime.\n\n### üöÄ Dynamic Memory (Heap)\nDynamic allocation allows you to request memory **while the program is running**. This memory is managed in a region called the **Heap**.\n- **Pros**: Flexible size, grows/shrinks as needed.\n- **Cons**: Slightly slower, must be manually managed (and freed).\n\n---\n\n## 2. Deep Dive: The C Memory Layout üèóÔ∏è\n\nA professional C program divides RAM into four specific segments:\n- **Text Segment**: Stores the compiled machine code (read-only).\n- **Data Segment**: Stores global and static variables initialized by the programmer.\n- **Stack**: Stores local variables and function call information (auto-managed).\n- **Heap**: The area used for Dynamic Memory Allocation (programmer-managed).\n\n---\n\n## 3. The Problem of Fragmentation üß©\n\nWhen you allocate and free many small blocks of memory on the **Heap**, it can become \"fragmented.\"\n- **External Fragmentation**: Total free memory is enough, but it's split into small, non-contiguous holes, so a large request fails.\n- **Internal Fragmentation**: Extra memory is allocated but not used (e.g., asking for 3 bytes but getting 4 due to alignment).\n\nProfessional developers use DMA carefully to avoid these issues by allocating larger blocks or using specialized memory pools.\n\n---\n\n## 4. Requirement: `<stdlib.h>`\n\nTo use dynamic memory functions in C, you must include the standard library header:\n```c\n#include <stdlib.h>\n```\n\n---\n\n## ‚ö° Key Takeaways\n- **Static** is for data whose size you know beforehand.\n- **Dynamic** is for data whose size changes or is unknown until runtime.\n- **The Heap** is the \"warehouse\" where dynamic memory lives.\n- **Memory Layout**: Understanding Stack vs Heap is fundamental to avoiding crashes.\n- **Fragmentation**: Reusing heap memory efficiently is a hallmark of a senior developer.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Where is dynamic memory allocated in C?",
                        "options": [
                            "The Stack",
                            "The Heap",
                            "The CPU Cache",
                            "The Hard Drive"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Dynamic memory is allocated from a pool of memory called the Heap, which is separate from the Stack used for static variables."
                    },
                    {
                        "id": 2,
                        "text": "Which of these is a disadvantage of static memory allocation?",
                        "options": [
                            "It is slower than dynamic allocation",
                            "The size cannot be changed during runtime",
                            "It requires manual freeing",
                            "It is stored on the Heap"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Static allocation (like normal arrays) must have a size determined at compile time, which makes it inflexible if data size changes."
                    },
                    {
                        "id": 3,
                        "text": "Which header file is required to use DMA functions in C?",
                        "options": [
                            "<stdio.h>",
                            "<string.h>",
                            "<stdlib.h>",
                            "<math.h>"
                        ],
                        "correctAnswer": 2,
                        "explanation": "The `<stdlib.h>` header contains the declarations for malloc, calloc, realloc, and free."
                    },
                    {
                        "id": 4,
                        "text": "In the context of memory, what does 'Lifetime' refer to in the Heap?",
                        "options": [
                            "It expires when the function ends",
                            "It lasts until the programmer calls free()",
                            "It lasts exactly 10 minutes",
                            "It depends on the CPU speed"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Unlike stack variables that die when a function returns, heap memory stays allocated until you explicitly release it using free()."
                    },
                    {
                        "id": 5,
                        "text": "What happens if you allocate memory on the heap but never free it?",
                        "options": [
                            "The computer runs faster",
                            "The memory is automatically freed by the OS immediately",
                            "A memory leak occurs",
                            "The variable becomes global"
                        ],
                        "correctAnswer": 2,
                        "explanation": "Failing to free heap memory results in a 'Memory Leak', where your program consumes more and more RAM over time."
                    }
                ]
            },
            {
                "id": "c29",
                "title": "29. malloc() and free()",
                "duration": "45 mins",
                "content": "# Memory Allocation: malloc() and free()\n\nThe most common way to request and release memory in C is using the dynamic duo: `malloc()` and `free()`.\n\n---\n\n## 1. What is malloc()?\n\n`malloc` stands for **Memory Allocation**. It requests a block of raw memory of a specific size from the Heap.\n\n### ‚ö° Syntax\n```c\nvoid* malloc(size_t size);\n```\n- **Parameter**: Total number of **bytes** to allocate.\n- **Returns**: A `void*` pointer to the first byte of the allocated block.\n- **Initialization**: The memory contains **garbage values** (it is not cleaned).\n\n---\n\n## 2. Sizing and Memory Alignment üìê\n\nYou should **never** hardcode the number of bytes (e.g., `malloc(4)`). Different systems have different sizes for types.\n\n```c\n// ‚úÖ Professional Practice\nint *ptr = malloc(5 * sizeof(int)); \n```\n> [!TIP]\n> **Memory Alignment**: CPUs often access memory in \"chunks\" (usually 4 or 8 bytes). `malloc` automatically ensures the memory it gives you is properly aligned for any built-in type to ensure maximum performance.\n\n---\n\n## 3. The Casting Debate: (int*) vs. No Cast\n\nIn older C (C89), you had to cast the return of `malloc`. In modern C (C99 onwards), you don't need to because `void*` converts to any pointer automatically.\n\n- **With Cast**: `int *p = (int*)malloc(sizeof(int));` (Required for C++ compatibility).\n- **Without Cast**: `int *p = malloc(sizeof(int));` (Cleaner, preferred by many Linux/C experts).\n\n---\n\n## 4. üöÄ Full Example: Dynamic Array\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n, i, *ptr;\n\n    printf(\"Enter number of elements: \");\n    scanf(\"%d\", &n);\n\n    // 1. ALLOCATE: Request space\n    ptr = malloc(n * sizeof(int));\n\n    // 2. CHECK: Safety First\n    if (ptr == NULL) {\n        perror(\"Failed to allocate memory\");\n        return 1;\n    }\n\n    // 3. USE and FREE\n    for (i = 0; i < n; i++) ptr[i] = i + 1;\n    for (i = 0; i < n; i++) printf(\"%d \", ptr[i]);\n\n    free(ptr);\n    return 0;\n}\n```\n\n### üíª Expected Output\n```text\nEnter number of elements: 3\n1 2 3 \n```\n\n### üîç How it Works\n1.  **`perror`**: A professional way to print the exact reason for failure (e.g., \"Out of memory\").\n2.  **`free(ptr)`**: This returns the memory. If you lose the pointer `ptr` before calling this, that memory is gone forever until the program ends (a **Leak**).\n\n---\n\n## ‚ö° Key Takeaways\n- **Raw Memory**: `malloc` gives you bytes; it doesn't care about types.\n- **Alignment**: Use `sizeof` to let the compiler handle architecture differences.\n- **Cleanup**: Every `malloc` call is a debt you must pay back with `free`.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What does 'malloc' stand for?",
                        "options": [
                            "Main Allocation",
                            "Memory Allocation",
                            "Manual Allocation",
                            "Managed Allocation"
                        ],
                        "correctAnswer": 1,
                        "explanation": "malloc is short for Memory Allocation, the primary function for requesting heap memory."
                    },
                    {
                        "id": 2,
                        "text": "What is the return type of `malloc()`?",
                        "options": [
                            "int*",
                            "float*",
                            "void*",
                            "char*"
                        ],
                        "correctAnswer": 2,
                        "explanation": "malloc returns a `void*` (generic pointer) so that it can be used to allocate memory for any data type."
                    },
                    {
                        "id": 3,
                        "text": "What does `malloc` do if the system runs out of memory?",
                        "options": [
                            "It crashes the program automatically",
                            "It returns a pointer to address 0 (NULL)",
                            "It deletes other variables to make room",
                            "It returns a random address"
                        ],
                        "correctAnswer": 1,
                        "explanation": "On failure, malloc returns `NULL`. It is the programmer's job to check for this and handle it gracefully."
                    },
                    {
                        "id": 4,
                        "text": "Which expression allocates space for an array of 10 doubles correctly?",
                        "options": [
                            "malloc(10);",
                            "malloc(10 * sizeof(double));",
                            "malloc(sizeof(double));",
                            "malloc(10 + sizeof(double));"
                        ],
                        "correctAnswer": 1,
                        "explanation": "You must multiply the number of elements by the size of the data type to get the total byte count."
                    },
                    {
                        "id": 5,
                        "text": "What happens to a block of memory after you call `free(ptr)`?",
                        "options": [
                            "The pointer `ptr` is set to NULL automatically",
                            "The memory is returned to the OS",
                            "The value at that address is deleted",
                            "The program terminates"
                        ],
                        "correctAnswer": 1,
                        "explanation": "free() marks the block as available for the OS to reuse. It DOES NOT set the pointer itself to NULL; you should do that manually if needed."
                    }
                ]
            },
            {
                "id": "c30",
                "title": "30. calloc() function",
                "duration": "40 mins",
                "content": "# Zero-Initialization: calloc()\n\nWhile `malloc` gives you raw memory with \"garbage\" values, `calloc` (**Contiguous Allocation**) gives you a clean slate by initializing all bits to zero.\n\n---\n\n## 1. Syntax and Parameters\n\n```c\nvoid* calloc(size_t n, size_t size);\n```\n- **n**: Number of elements.\n- **size**: Size of each element.\n\n---\n\n## 2. Strategic Use-Case: Struct Initialization üèõÔ∏è\n\n`calloc` is highly professional when dynamically creating structures. It ensures all members (including strings and pointers) start as `0` or `NULL`, preventing crashes from uninitialized pointers.\n\n```c\ntypedef struct {\n    char name[50];\n    int score;\n    void *data_ptr; // Starts as NULL thanks to calloc!\n} Player;\n\nPlayer *p = calloc(1, sizeof(Player));\n```\n\n---\n\n## 3. Performance vs. Safety ‚ö°\n\n- **malloc**: Faster. It just marks memory as used without touching the bits. Use it when you plan to immediately overwrite every byte anyway (like in `strcpy`).\n- **calloc**: Slower. It must write zeros to every single bit. Use it when you need a predictable, clean state or when you won't initialize every field immediately.\n\n---\n\n## 4. üöÄ Example: Dynamic Array with calloc\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    // Allocate for 3 integers, all initialized to 0\n    int *arr = calloc(3, sizeof(int));\n\n    if (arr == NULL) return 1;\n\n    // Verify zero-initialization\n    printf(\"Value at index 0: %d\", arr[0]);\n    \n    free(arr);\n    return 0;\n}\n```\n\n### üí° How it Works?\n> **Security**: `calloc` clears sensitive data that might have been left behind by a previous program in that memory location.\n> **Predictability**: It eliminates the \"it worked on my machine but crashed on yours\" bugs caused by random garbage values.\n\n### üíª Expected Output\n```text\nValue at index 0: 0\n```\n\n---\n\n## ‚ö° Key Takeaways\n- **Clean Memory**: Guaranteed zero-initialization.\n- **Structs**: The safest choice for complex data types.\n- **Arguments**: Takes `(count, size)` instead of just total bytes.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What is the primary difference between malloc and calloc?",
                        "options": [
                            "malloc is for integers, calloc is for floats",
                            "calloc initializes memory to zero, malloc does not",
                            "malloc requires free(), calloc does not",
                            "calloc is only for 2D arrays"
                        ],
                        "correctAnswer": 1,
                        "explanation": "calloc (contiguous allocation) explicitly sets all bits of the allocated memory to zero, while malloc leaves whatever garbage was there before."
                    },
                    {
                        "id": 2,
                        "text": "How many arguments does `calloc()` take?",
                        "options": [
                            "1",
                            "2",
                            "3",
                            "4"
                        ],
                        "correctAnswer": 1,
                        "explanation": "calloc takes two arguments: the number of elements to allocate and the size of each element."
                    },
                    {
                        "id": 3,
                        "text": "Which call is equivalent to `malloc(5 * sizeof(int))` but with zero-initialization?",
                        "options": [
                            "calloc(5 * sizeof(int));",
                            "calloc(5, sizeof(int));",
                            "calloc(sizeof(int), 5, 0);",
                            "calloc(5 + sizeof(int));"
                        ],
                        "correctAnswer": 1,
                        "explanation": "The correct syntax for calloc is the number of elements followed by the size of each."
                    },
                    {
                        "id": 4,
                        "text": "Why might `calloc` be slightly slower than `malloc`?",
                        "options": [
                            "It uses more electricity",
                            "It has to perform the extra step of zeroing out the memory",
                            "It only works on certain CPUs",
                            "It uses the hard drive"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Setting every single bit to zero takes extra processor cycles compared to just reserving the address as malloc does."
                    },
                    {
                        "id": 5,
                        "text": "Does `calloc` require the `<stdlib.h>` header?",
                        "options": [
                            "Yes",
                            "No",
                            "Only for float arrays",
                            "Only on Linux"
                        ],
                        "correctAnswer": 0,
                        "explanation": "Like all standard DMA functions, calloc is defined in the standard library header."
                    }
                ]
            },
            {
                "id": "c31",
                "title": "31. realloc() function",
                "duration": "45 mins",
                "content": "# Resizing Memory: realloc()\n\nWhat if you allocated space for 5 items, but later realize you need 10? Instead of freeing and starting over, you use `realloc` to **resize** the existing block.\n\n---\n\n## 1. Syntax and Safety\n\n```c\nvoid* realloc(void *ptr, size_t new_size);\n```\n- **ptr**: The original memory address.\n- **new_size**: The new total size required.\n\n> [!CAUTION]\n> **The NULL Trap**: If `realloc` fails, it returns `NULL`, but the original memory is **still allocated**. If you assign the result directly to your original pointer (`ptr = realloc(ptr, size)`), and it fails, you lose the address of your data forever!\n\n---\n\n## 2. Why the Pointer Changes? üîÑ\n\nWhen you ask for more space, three things can happen:\n1.  **In-Place Expansion**: If there's free space right after your block, the address stays the same.\n2.  **Relocation**: If something else is blocking the path, C finds a **new large spot**, copies your data there, and frees the old spot automatically. Your pointer address **changes**.\n3.  **Shrinking**: If you ask for less space, the tail end is returned to the OS, and the base address usually stays the same.\n\n---\n\n## 3. üöÄ The Professional \"Re-Allocation\" Pattern\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *arr = malloc(2 * sizeof(int));\n    arr[0] = 10; arr[1] = 20;\n\n    // Resize for 4 integers safely\n    int *temp = realloc(arr, 4 * sizeof(int));\n    \n    if (temp == NULL) {\n        free(arr); // Clean up original before exiting\n        return 1;\n    }\n    \n    arr = temp; // Only update if successful\n    arr[2] = 30; arr[3] = 40;\n\n    for(int i=0; i<4; i++) printf(\"%d \", arr[i]);\n\n    free(arr);\n    return 0;\n}\n```\n\n### üí° How it Works?\n> **Copying**: If relocation happens, `realloc` handles the byte-by-byte copy of your old data to the new location. You don't have to do it manually.\n> **Fragmentation**: Frequently calling `realloc` can lead to heap fragmentation. It's often better to double the size (e.g., 2 -> 4 -> 8) rather than increasing by 1 each time.\n\n### üíª Expected Output\n```text\n10 20 30 40 \n```\n\n---\n\n## ‚ö° Key Takeaways\n- **Safety**: Always use a `temp` pointer for the return value.\n- **Efficiency**: It is the only way to grow or shrink memory without a manual copy-and-delete.\n- **Address**: Never assume the address will stay the same after a `realloc` call.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What is the purpose of `realloc()`?",
                        "options": [
                            "To read data from a file",
                            "To change the size of an existing dynamically allocated block",
                            "To reset a pointer to NULL",
                            "To allocate memory on the Stack"
                        ],
                        "correctAnswer": 1,
                        "explanation": "realloc (re-allocation) is used to increase or decrease the size of memory previously allocated on the heap."
                    },
                    {
                        "id": 2,
                        "text": "What happens to the existing data in a block when it is resized via `realloc`?",
                        "options": [
                            "It is deleted",
                            "It is moved to the hard drive",
                            "It is preserved (up to the lesser of the new and old sizes)",
                            "It is encrypted"
                        ],
                        "correctAnswer": 2,
                        "explanation": "C guarantees that your existing data remains intact after a realloc call, even if the block is moved to a new memory address."
                    },
                    {
                        "id": 3,
                        "text": "Why should you use a temporary pointer with `realloc`?",
                        "options": [
                            "To make the code look professional",
                            "To prevent memory leaks if realloc returns NULL",
                            "Because realloc cannot return the same pointer",
                            "Temporary pointers are faster"
                        ],
                        "correctAnswer": 1,
                        "explanation": "If realloc fails, it returns NULL. If you assign that NULL to your original pointer, you lose the address of your original data, creating a leak."
                    },
                    {
                        "id": 4,
                        "text": "If `realloc(ptr, 0)` is called, what is the effect?",
                        "options": [
                            "Nothing happens",
                            "The program crashes",
                            "It is equivalent to calling free(ptr)",
                            "It doubles the memory size"
                        ],
                        "correctAnswer": 2,
                        "explanation": "Reducing the size to 0 is generally treated as a request to free the memory block."
                    },
                    {
                        "id": 5,
                        "text": "Does `realloc` automatically free the old block if it moves the data to a new address?",
                        "options": [
                            "Yes",
                            "No",
                            "Only if the user asks",
                            "Only on Windows"
                        ],
                        "correctAnswer": 0,
                        "explanation": "Yes, if relocation is necessary, C handles the copying and the freeing of the old memory location for you."
                    }
                ]
            },
            {
                "id": "c32",
                "title": "32. DMA Best Practices",
                "duration": "40 mins",
                "content": "# DMA Best Practices & Safety\n\nDynamic Memory Allocation gives you great power, but with great power comes great responsibility. Professional C development requires a disciplined approach to memory safety.\n\n---\n\n## 1. The \"Never Assume\" Rule\n\nMemory is limited. `malloc`, `calloc`, and `realloc` can fail if the system is out of RAM. Always check for `NULL` before using the pointer.\n\n### ‚ùå Dangerous Code\n```c\nint *p = malloc(1000 * sizeof(int));\np[0] = 5; // CRASH! if malloc failed\n```\n\n### ‚úÖ Professional Code\n```c\nint *p = malloc(1000 * sizeof(int));\nif (p == NULL) {\n    fprintf(stderr, \"Critical Error: Out of Memory\\n\");\n    exit(1);\n}\np[0] = 5; // Safe\n```\n\n---\n\n## 2. Buffer Overflows: The Silent Killer\n\nA **Buffer Overflow** occurs when you write data beyond the boundaries of your allocated block. This can overwrite other variables, corrupt the program's stack, or create massive security vulnerabilities.\n\n```c\nint *arr = malloc(5 * sizeof(int));\nfor(int i = 0; i <= 5; i++) { // ‚ö†Ô∏è BUG: Loop runs 6 times\n    arr[i] = i; // Overwrites memory at index 5!\n}\n```\n> [!CAUTION]\n> C does NOT check array boundaries for you. You must be extremely precise with your loop conditions.\n\n---\n\n## 3. Dangling Pointers & Double Free\n\n- **Dangling Pointer**: A pointer that points to memory that has just been freed.\n- **Double Free**: Freeing the same memory twice. This usually crashes the program immediately.\n\n### üõ°Ô∏è The \"NULLify\" Strategy\nAlways set your pointer to `NULL` immediately after freeing it. This prevents both accidental use and accidental double-frees.\n```c\nfree(ptr);\nptr = NULL; \n\n// Safely calling free(NULL) does nothing and causes no error.\nfree(ptr); // ‚úÖ Safe double-call\n```\n\n---\n\n## 4. The Professional Memory Checklist üèÜ\n\n- [ ] **Check for NULL**: Every allocation must have an `if (p == NULL)` check.\n- [ ] **Match Alloc/Free**: Every `malloc` must have a corresponding `free`.\n- [ ] **Initialize**: Remember that `malloc` memory starts with garbage values.\n- [ ] **Valgrind**: Use tools like Valgrind to scan your binary for leaks.\n\n---\n\n## ‚ö° Key Takeaways\n- **Safety**: Manual memory management is where most C bugs occur.\n- **Precision**: Be careful with array indices (`size-1`).\n- **Tooling**: Use memory debuggers during development.\n- **Discipline**: A master C programmer spends as much time on safety as on logic.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What is a 'Memory Leak'?",
                        "options": [
                            "A hole in the computer's motherboard",
                            "When memory is allocated but never freed, becoming unusable",
                            "When a variable's value changes randomly",
                            "When the hard drive runs out of space"
                        ],
                        "correctAnswer": 1,
                        "explanation": "A memory leak happens when heap memory is 'lost' because the program no longer has a pointer to it but hasn't freed it."
                    },
                    {
                        "id": 2,
                        "text": "What is a 'Dangling Pointer'?",
                        "options": [
                            "A pointer that points to address 0",
                            "A pointer that points to memory that has already been freed",
                            "A pointer that hasn't been used yet",
                            "A pointer to a function"
                        ],
                        "correctAnswer": 1,
                        "explanation": "After free() is called, the pointer still holds the old address. If you try to use it, you are accessing 'dead' memory."
                    },
                    {
                        "id": 3,
                        "text": "What should you do immediately after calling `free(ptr)` to stay safe?",
                        "options": [
                            "Delete the line of code",
                            "Set `ptr = NULL;`",
                            "Restart the computer",
                            "Call malloc again"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Setting the pointer to NULL ensures that if you accidentally try to use it later, the program will crash cleanly rather than causing hard-to-find memory bugs."
                    },
                    {
                        "id": 4,
                        "text": "What happens if you 'Double Free' (call free twice on the same pointer)?",
                        "options": [
                            "Nothing, it's safer",
                            "The computer restarts",
                            "It typically causes a program crash or security vulnerability",
                            "It frees the memory twice as fast"
                        ],
                        "correctAnswer": 2,
                        "explanation": "Double freeing corrupts the heap management structures and is a severe bug that leads to crashes or security exploits."
                    },
                    {
                        "id": 5,
                        "text": "Which tool is commonly used to find memory leaks in C programs?",
                        "options": [
                            "Photoshop",
                            "Valgrind",
                            "Excel",
                            "Slack"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Valgrind is a powerful industry-standard tool for monitoring memory usage and detecting leaks and errors in C/C++."
                    }
                ]
            }
        ]
    },
    {
        "id": "c-l7",
        "title": "LEVEL 7: Structures & Files",
        "lessons": [
            {
                "id": "c33",
                "title": "33. Structures & Unions",
                "duration": "45 mins",
                "content": "# Organizing Data: Structures & Unions\n\nUntil now, we have used arrays to store multiple items of the **same** type. But what if you want to store a student's name (string), roll number (int), and marks (float) together? For this, C provides **Structures** and **Unions**.\n\n---\n\n## 1. What is a Structure?\n\nA structure is a user-defined data type that allows you to group different types of related data into a single unit.\n\n### ‚ö° Syntax: Declaration\n```c\nstruct Student {\n    char name[50];\n    int roll;\n    float marks;\n};\n```\n\n---\n\n## 2. Strategic Concept: Memory Padding & Alignment üìê\n\nHave you ever wondered why a struct with a `char` (1 byte) and an `int` (4 bytes) sometimes takes **8 bytes** instead of 5? This is due to **Memory Padding**.\n\n- **Alignment**: CPUs access memory faster if variables are at addresses that are multiples of their size.\n- **Padding**: The compiler inserts \"empty bytes\" between members to align them correctly.\n\n> [!TIP]\n> **Pro-Tip**: To save memory, arrange your struct members from **largest to smallest** to minimize padding.\n\n---\n\n## 3. Unions: The Memory Efficient Alternative\n\nIn a **Union**, all members share the same starting memory address. It can only hold one value at a time.\n\n```c\nunion Secret {\n    int code;\n    char key[4];\n};\n```\n\n| Feature | Structure | Union |\n| :--- | :--- | :--- |\n| **Memory** | Sum of members (+ padding) | Size of largest member |\n| **Access** | All members at once | Only one at a time |\n| **Use Case** | Complex objects (Student) | Memory-constrained systems |\n\n---\n\n## 4. üöÄ Practical Example: Nested Structures\n\n```c\n#include <stdio.h>\n\ntypedef struct {\n    int x, y;\n} Point;\n\ntypedef struct {\n    Point start;\n    Point end;\n} Line;\n\nint main() {\n    Line L = {{0, 0}, {10, 10}};\n    printf(\"Line from (%d,%d) to (%d,%d)\", L.start.x, L.start.y, L.end.x, L.end.y);\n    return 0;\n}\n```\n\n### üíª Expected Output\n```text\nLine from (0,0) to (10,10)\n```\n\n### üîç How it Works\n1.  **Nested Access**: Notice how we use `L.start.x` to traverse through two levels of structures.\n2.  **Initialization**: We used nested curly braces `{ { } , { } }` to initialize the inner points.\n\n---\n\n## ‚ö° Key Takeaways\n- **Padding**: Structs are often larger than the sum of their parts for CPU speed.\n- **Unions**: Shared memory; useful for hardware registers or saving RAM.\n- **Organization**: Use `typedef` (Lesson 35) with structs for cleaner code.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What is the primary purpose of a structure in C?",
                        "options": [
                            "To store only integers",
                            "To group related data of different types",
                            "To make the program run faster",
                            "To replace the main function"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Structures allow you to group variables of different data types (like int, char, float) under a single name."
                    },
                    {
                        "id": 2,
                        "text": "Which operator is used to access members of a structure?",
                        "options": [
                            "& (Address-of)",
                            "* (Dereference)",
                            ". (Dot operator)",
                            "-> (Arrow operator) - for pointers only"
                        ],
                        "correctAnswer": 2,
                        "explanation": "The dot operator (.) is used to access members of a structure variable."
                    },
                    {
                        "id": 3,
                        "text": "What is the correct syntax to declare a structure for a 'Point' with x and y coordinates?",
                        "options": [
                            "struct Point { int x, y; }",
                            "struct Point { int x; int y; };",
                            "Point { int x; int y; }",
                            "struct Point ( int x, y )"
                        ],
                        "correctAnswer": 1,
                        "explanation": "A structure is declared using the `struct` keyword, followed by curly braces and a trailing semicolon."
                    },
                    {
                        "id": 4,
                        "text": "What is the main difference between a struct and a union in terms of memory?",
                        "options": [
                            "Structs share memory, Unions use separate memory",
                            "Unions share the same memory location for all members, Structs use separate memory for each",
                            "Unions are always larger",
                            "There is no difference"
                        ],
                        "correctAnswer": 1,
                        "explanation": "In a Union, all members share the exact same starting memory address, while each struct member has its own address."
                    },
                    {
                        "id": 5,
                        "text": "In a union with an `int` (4 bytes) and a `char` (1 byte), what is the total size of the union?",
                        "options": [
                            "5 bytes",
                            "1 byte",
                            "4 bytes",
                            "8 bytes"
                        ],
                        "correctAnswer": 2,
                        "explanation": "A Union's size is equal to the size of its largest member. In this case, 4 bytes."
                    }
                ]
            },
            {
                "id": "c34",
                "title": "34. File Handling",
                "duration": "50 mins",
                "content": "# Persistent Data: File Handling\n\nNormally, when a program ends, all its data is lost from RAM. To save data permanently, we must write it to files on the hard drive. C provides a powerful set of functions for **File I/O**.\n\n---\n\n## 1. The FILE Pointer & Opening Modes\n\nAll file operations are handled through a `FILE` pointer. Professional code always checks if the file opened successfully.\n\n```c\nFILE *fp = fopen(\"config.bin\", \"wb\"); // Open for writing in BINARY mode\nif (fp == NULL) {\n    perror(\"Error opening file\");\n    return 1;\n}\n```\n\n### üåì Binary vs. Text Mode\n- **Text Mode (`\"r\"`, `\"w\"`)**: Handles translations (like newline `\\n` to `\\r\\n` on Windows). Best for human-readable files.\n- **Binary Mode (`\"rb\"`, `\"wb\"`)**: No translations. Every byte is saved exactly as it is. Best for images, databases, and custom file formats.\n\n---\n\n## 2. Advanced: File Positioning üìç\n\nSometimes you don't want to read a file from the start. You might want to jump to the middle or the end. C provides three functions for this:\n\n- **`fseek(fp, offset, origin)`**: Moves the file pointer.\n  - `SEEK_SET`: Beginning of file.\n  - `SEEK_CUR`: Current position.\n  - `SEEK_END`: End of file.\n- **`ftell(fp)`**: Returns the current position (in bytes from the start).\n- **`rewind(fp)`**: Sets the position back to the very beginning.\n\n---\n\n## 3. üöÄ Practical Example: Writing & Jumping\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *fp = fopen(\"test.txt\", \"w+\");\n    if (fp == NULL) return 1;\n\n    fputs(\"ABCDE\", fp); // File contains ABCDE\n    \n    // Jump back 2 bytes from the current position\n    fseek(fp, -2, SEEK_CUR);\n    \n    char c = fgetc(fp);\n    printf(\"Character at position: %c\", c);\n\n    fclose(fp);\n    return 0;\n}\n```\n\n### üíª Expected Output\n```text\nCharacter at position: D\n```\n\n### üîç How it Works\n1.  **`w+` mode**: Allows both reading and writing.\n2.  **`fseek(fp, -2, SEEK_CUR)`**: After writing \"ABCDE\", the pointer is at position 5. We jump back 2 bytes to position 3 (the letter 'D').\n3.  **`fgetc`**: Reads a single character from the new position.\n\n---\n\n## ‚ö° Key Takeaways\n- **Binary Mode**: Crucial for non-text data.\n- **fseek**: Allows \"Random Access\" to any part of a file.\n- **Robustness**: Always use `perror` and `NULL` checks when dealing with files.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Which header file is required for file handling in C?",
                        "options": [
                            "<stdlib.h>",
                            "<stdio.h>",
                            "<file.h>",
                            "<string.h>"
                        ],
                        "correctAnswer": 1,
                        "explanation": "<stdio.h> contains the FILE type and functions like fopen, fclose, etc."
                    },
                    {
                        "id": 2,
                        "text": "What does the 'a' mode in `fopen` stand for?",
                        "options": [
                            "Automatic",
                            "Append",
                            "All-access",
                            "Array"
                        ],
                        "correctAnswer": 1,
                        "explanation": "The 'a' mode opens a file for appending, meaning new data is added to the end without deleting existing content."
                    },
                    {
                        "id": 3,
                        "text": "What happens if `fopen` cannot open a file?",
                        "options": [
                            "The program crashes",
                            "It returns NULL",
                            "The computer restarts",
                            "It deletes the file"
                        ],
                        "correctAnswer": 1,
                        "explanation": "If a file cannot be opened (e.g., file not found in 'r' mode), `fopen` returns NULL. You should always check for this."
                    },
                    {
                        "id": 4,
                        "text": "What is the primary difference between `w` and `a` modes?",
                        "options": [
                            "w reads, a writes",
                            "w overwrites the file, a adds to the end",
                            "a is faster than w",
                            "w creates a file, a does not"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Write mode ('w') erases the file content if it exists, while Append ('a') preserves it and adds data to the end."
                    },
                    {
                        "id": 5,
                        "text": "Why is it critical to call `fclose()`?",
                        "options": [
                            "To make the file hidden",
                            "To ensure all data is correctly saved and resources are released",
                            "To delete the temporary buffer",
                            "It is optional in modern C"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Closing a file flushes buffers to disk and frees the memory used by the FILE structure."
                    }
                ]
            },
            {
                "id": "c35",
                "title": "35. Enums in C",
                "duration": "30 mins",
                "content": "# Symbolic Constants: Enums in C\n\nAn **Enumeration (enum)** is a user-defined data type that consists of named integer constants. It makes code more readable and easier to maintain by replacing magic numbers with descriptive names.\n\n---\n\n## 1. What is an Enum?\n\nIf you have a set of related values (like days of the week or menu options), instead of using `int day = 0; // what is 0?`, you use enums.\n\n```c\nenum Day { SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY };\n\nenum Day today = MONDAY;\n```\nBy default, `SUNDAY` is 0, `MONDAY` is 1, and so on.\n\n---\n\n## 2. Custom Values & Syntax\n\nYou can override the default values. If you set one value, the subsequent ones increment from there.\n\n```c\nenum Status { \n    PENDING = 1,  // 1\n    ACTIVE,       // 2\n    COMPLETED = 10, // 10\n    FAILED        // 11\n};\n```\n\n---\n\n## 3. Enum vs #define\n\nWhy use `enum` instead of `#define`?\n- **Scope**: Enums follow block scope rules; `#define` is global.\n- **Type Checking**: Enums are a distinct type, which helps some compilers catch errors.\n- **Debugging**: Debuggers can show the name (e.g., `MONDAY`) instead of just the number (1).\n\n---\n\n## 4. üöÄ Practical Example: Menu System\n\n```c\n#include <stdio.h>\n\nenum Menu { EXIT, START, SETTINGS, HELP };\n\nint main() {\n    int choice = START;\n\n    switch(choice) {\n        case START: printf(\"Game Starting...\\n\"); break;\n        case EXIT: printf(\"Goodbye!\\n\"); break;\n        default: printf(\"Invalid Choice\\n\");\n    }\n    return 0;\n}\n```\n\n### üí° How it Works?\n> **Readability**: `case START` is much clearer than `case 1`.\n> **Maintenance**: If you add a new menu item, you only update the `enum` definition, and the numbers adjust automatically.\n\n---\n\n## ‚ö° Key Takeaways\n- **Integers under the hood**: Enums are basically named integers.\n- **Readability**: Use them for states, options, and categories.\n- **Sequential**: Values increment by default, saving manual assignment.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What is the default integer value of the first member in an enum if not specified?",
                        "options": [
                            "1",
                            "0",
                            "-1",
                            "Random"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Enums in C are zero-indexed by default."
                    },
                    {
                        "id": 2,
                        "text": "If `enum Color { RED=5, GREEN, BLUE };`, what is the value of `BLUE`?",
                        "options": [
                            "2",
                            "6",
                            "7",
                            "0"
                        ],
                        "correctAnswer": 2,
                        "explanation": "Starting from RED=5, GREEN becomes 6 and BLUE becomes 7."
                    },
                    {
                        "id": 3,
                        "text": "Can an enum member across different enums have the same name?",
                        "options": [
                            "Yes",
                            "No, it causes a name collision",
                            "Only if they have the same value",
                            "Only in different files"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Enum member names must be unique within the same scope."
                    }
                ]
            }
        ]
    },
    {
        "id": "c-l8",
        "title": "LEVEL 8: Advanced Concepts",
        "lessons": [
            {
                "id": "c36",
                "title": "36. Preprocessor & Storage Classes",
                "duration": "40 mins",
                "content": "# Advanced C: Preprocessor & Storage\n\nBefore compilation and during execution, C uses two powerful systems to manage code and memory: the **Preprocessor** and **Storage Classes**.\n\n---\n\n## 1. Strategic Tool: Conditional Compilation üõ°Ô∏è\n\nProfessional developers use conditional directives to make code that works on different operating systems (Windows, Linux, Mac) or to include \"Debug Mode\" features.\n\n```c\n#define DEBUG_MODE\n\n#ifdef DEBUG_MODE\n    printf(\"Debug: Memory allocated at %p\\n\", ptr);\n#endif\n```\n- `#ifdef` / `#ifndef`: Check if a macro is defined.\n- `#else` / `#elif`: Handle alternative conditions.\n- `#endif`: Required to close the block.\n\n---\n\n## 2. Predefined Macros üß©\n\nC provides built-in macros that help with logging and error reporting:\n- `__FILE__`: The name of the current file (string).\n- `__LINE__`: The current line number (integer).\n- `__DATE__`: The date of compilation.\n\n```c\nprintf(\"Error in file %s at line %d\", __FILE__, __LINE__);\n```\n\n---\n\n## 3. Storage Classes: A Summary\n\nStorage classes define the **lifetime** and **scope** of a variable.\n\n| Class | Lifetime | Visibility | Use Case |\n| :--- | :--- | :--- | :--- |\n| **auto** | Function end | Local | Default for all local variables |\n| **static** | Program end | Local | Preserve value between function calls |\n| **extern** | Program end | Global | Share variable across multiple `.c` files |\n| **register** | Function end | Local | Hint to store in CPU for extreme speed |\n\n---\n\n## 4. üöÄ Practical Example: Static and Macros\n\n```c\n#include <stdio.h>\n\n#define LOG_MSG(m) printf(\"LOG: %s\\n\", m)\n\nvoid tracker() {\n    static int count = 0;\n    count++;\n    printf(\"Visit #%d\\n\", count);\n}\n\nint main() {\n    LOG_MSG(\"System Started\");\n    tracker(); // Visit #1\n    tracker(); // Visit #2\n    return 0;\n}\n```\n\n### üí° How it Works?\n> **Macros**: `LOG_MSG` is a \"function-like macro.\" It saves typing and is faster than a function call because there is no stack overhead.\n> **Static**: The variable `count` is initialized to `0` only once. It lives in the **Data Segment** of memory, not the Stack.\n\n### üíª Expected Output\n```text\nLOG: System Started\nVisit #1\nVisit #2\n```\n\n---\n\n## ‚ö° Key Takeaways\n- **Preprocessor**: Use it for Header Guards, Macros, and cross-platform logic.\n- **Storage**: `static` is your best friend for maintaining state without global variables.\n- **Logging**: Use `__FILE__` and `__LINE__` for professional debugging.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What symbol do all preprocessor directives start with?",
                        "options": [
                            "&",
                            "$",
                            "#",
                            "@"
                        ],
                        "correctAnswer": 2,
                        "explanation": "All preprocessor commands (directives) like #include and #define start with a hash (#) symbol."
                    },
                    {
                        "id": 2,
                        "text": "Do preprocessor directives like `#define MAX 100` end with a semicolon?",
                        "options": [
                            "Yes, always",
                            "Only if it's a number",
                            "No, never",
                            "Only on Windows"
                        ],
                        "correctAnswer": 2,
                        "explanation": "Preprocessor directives are handled before the C compiler runs and do not follow C statement syntax."
                    }
                ]
            },
            {
                "id": "c37",
                "title": "37. Advanced C Features",
                "duration": "45 mins",
                "content": "# Mastering Advanced C\n\nAs we reach the end of the curriculum, let's explore the final pieces of the puzzle: low-level bit manipulation and integrated project building.\n\n---\n\n## 1. Typedef & The Arrow Operator (->)\n\nProfessional C code uses `typedef` to clean up declarations and the **Arrow Operator (`->`)** to access members through pointers.\n\n```c\ntypedef struct {\n    int id;\n    char name[20];\n} User;\n\nUser *u = malloc(sizeof(User));\nu->id = 1; // Correct way to access member via pointer\n```\n\n---\n\n## 2. Bitwise Operators: Control the Bits üîß\n\nIn systems programming, you often need to manipulate individual bits. C provides operators for this:\n\n| Operator | Meaning | Example (Binary) |\n| :--- | :--- | :--- |\n| `&` | AND | `5 & 1` (0101 & 0001 = 0001) |\n| `|` | OR | `5 | 1` (0101 | 0001 = 0101) |\n| `^` | XOR | `5 ^ 1` (0101 ^ 0001 = 0100) |\n| `<<` | Left Shift | `1 << 2` (0001 becomes 0100 = 4) |\n\n---\n\n## 3. Professional Error Handling\n\nAlways use `perror()` and exit codes for robust software.\n```c\nif (fopen(\"file.txt\", \"r\") == NULL) {\n    perror(\"Error\");\n    exit(EXIT_FAILURE);\n}\n```\n\n---\n\n## üöÄ 4. Capstone Project: Simple Phonebook\n\nThis script integrates everything you've learned: `struct`, `typedef`, `DMA`, and `File I/O`.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    char name[50];\n    char phone[15];\n} Contact;\n\nint main() {\n    // 1. Dynamic Allocation\n    Contact *entry = malloc(sizeof(Contact));\n    if (entry == NULL) return 1;\n\n    strcpy(entry->name, \"Alice\");\n    strcpy(entry->phone, \"123-456\");\n\n    // 2. File Persistence\n    FILE *fp = fopen(\"phonebook.txt\", \"w\");\n    if (fp != NULL) {\n        fprintf(fp, \"%s: %s\", entry->name, entry->phone);\n        fclose(fp);\n        printf(\"Contact saved successfully!\\n\");\n    }\n\n    free(entry); // 3. Memory Cleanup\n    return 0;\n}\n```\n\n### üí° How it Works? (The Big Picture)\n> **Memory Manipulation**: We used `malloc` to reserve space only when needed. This is how large databases manage millions of records without wasting RAM.\n> **Data Organization**: `typedef struct` allowed us to treat a name and phone number as a single object called a `Contact`.\n> **Persistence**: The use of `FILE` functions ensures that even if you turn off the computer, \"Alice\" is still in our phonebook.\n> **Ownership**: By calling `free(entry)`, we officially returned the memory to the OS, preventing a memory leak.\n\n### üíª Expected Output\n```text\nContact saved successfully!\n(File \"phonebook.txt\" created and populated)\n```\n\n---\n\n## ‚ö° Key Takeaways\n- **Integration**: Real apps are built by combining all these concepts.\n- **Bits**: Use Bitwise operators for hardware-level control.\n- **Discipline**: Professionalism in C is about memory safety and error checking.\n- **Graduation**: You are now ready for the Final Exam!",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What is the purpose of the `typedef` keyword?",
                        "options": [
                            "To define a new variable",
                            "To create an alias for an existing data type",
                            "To type-cast a variable",
                            "To create a loop"
                        ],
                        "correctAnswer": 1,
                        "explanation": "typedef (Type Definition) allows you to create a shortcut or descriptive name for complex types."
                    },
                    {
                        "id": 2,
                        "text": "Which bitwise operator is used to 'Shift' bits to the left?",
                        "options": [
                            ">> (Right Shift)",
                            "<< (Left Shift)",
                            "^ (XOR)",
                            "~ (NOT)"
                        ],
                        "correctAnswer": 1,
                        "explanation": "The << operator shifts all bits to the left by a specified number of positions, effectively multiplying the number by 2 for each shift."
                    },
                    {
                        "id": 3,
                        "text": "Which operator is used to access a structure member through a pointer?",
                        "options": [
                            ". (Dot)",
                            "-> (Arrow)",
                            "* (Asterisk)",
                            "& (Ampersand)"
                        ],
                        "correctAnswer": 1,
                        "explanation": "The arrow operator (->) is used specifically for pointers to structures. `ptr->member` is shorthand for `(*ptr).member`."
                    },
                    {
                        "id": 4,
                        "text": "What does `perror()` do?",
                        "options": [
                            "It crashes the program",
                            "It prints a human-readable description of the last system error",
                            "It deletes temporary files",
                            "It checks for syntax errors"
                        ],
                        "correctAnswer": 1,
                        "explanation": "perror stands for 'print error'. It looks at the global 'errno' variable and prints a descriptive message like 'File not found'."
                    },
                    {
                        "id": 5,
                        "text": "Which standard library defines `exit()` and `EXIT_FAILURE`?",
                        "options": [
                            "<stdio.h>",
                            "<string.h>",
                            "<stdlib.h>",
                            "<math.h>"
                        ],
                        "correctAnswer": 2,
                        "explanation": "The standard library (<stdlib.h>) contains the tools for process control and general utility functions."
                    }
                ]
            },
            {
                "id": "c38",
                "title": "38. Const Correctness",
                "duration": "30 mins",
                "content": "# Safety First: Const Correctness\n\nThe `const` keyword is one of the most important tools for writing safe, bug-free C code. It tells the compiler (and other developers) that a value should not change.\n\n---\n\n## 1. Constant Variables\n\nWhen a variable is marked `const`, any attempt to modify it will result in a compiler error.\n\n```c\nconst int MAX_USERS = 100;\n// MAX_USERS = 120; // ERROR!\n```\n\n---\n\n## 2. Pointers & Const: The Confusion\n\nThere are two main ways to use `const` with pointers, and they mean very different things:\n\n### üÖ∞Ô∏è Pointer to Const\nThe **data** cannot be changed through this pointer.\n```c\nconst int *ptr = &val;\n// *ptr = 10; // ERROR!\nptr = &other; // OK: Pointer can move\n```\n\n### üÖ±Ô∏è Const Pointer\nThe **pointer** itself cannot change its address.\n```c\nint *const ptr = &val;\n*ptr = 10; // OK: Data can change\n// ptr = &other; // ERROR!\n```\n\n---\n\n## 3. Why Use Const?\n\n- **Safety**: Prevents accidental modification of data.\n- **Readability**: Communicates intent (e.g., \"this function only reads this array, it won't change it\").\n- **Optimization**: Helps the compiler make better assumptions about your data.\n\n---\n\n## 4. üöÄ Practical Example: Safe Functions\n\n```c\n#include <stdio.h>\n\n// const here ensures the function won't mess with our string\nvoid printMessage(const char *msg) {\n    printf(\"Message: %s\\n\", msg);\n    // msg[0] = 'X'; // This would trigger an error\n}\n\nint main() {\n    printMessage(\"Hello C!\");\n    return 0;\n}\n```\n\n---\n\n## ‚ö° Key Takeaways\n- **Read from right to left**: `int const *` (pointer to a const int), `int * const` (const pointer to an int).\n- **Function parameters**: Use `const` for input-only parameters to protect caller data.\n- **Optimization**: Const can lead to smaller, faster binaries.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What does `const int *ptr` mean?",
                        "options": [
                            "The pointer cannot be changed",
                            "The data pointed to cannot be changed",
                            "Both are constant",
                            "Nothing is constant"
                        ],
                        "correctAnswer": 1,
                        "explanation": "`const int *ptr` is a pointer to a constant integer. You can change the pointer but not the data."
                    },
                    {
                        "id": 2,
                        "text": "Which declaration makes the pointer itself constant?",
                        "options": [
                            "const int *p",
                            "int const *p",
                            "int *const p",
                            "const *int p"
                        ],
                        "correctAnswer": 2,
                        "explanation": "`int *const p` follows the rule that `const` applies to what is on its left. Here, it is the pointer `*`."
                    }
                ]
            },
            {
                "id": "c39",
                "title": "39. Command Line Arguments",
                "duration": "35 mins",
                "content": "# Interacting with the OS: Command Line Arguments\n\nMost professional C programs (like `ls`, `gcc`, or `git`) take input from the terminal. In C, we handle this using `argc` and `argv` in the `main` function.\n\n---\n\n## 1. The main() Signature\n\nUntil now, we used `int main()`. To accept terminal input, we use:\n```c\nint main(int argc, char *argv[]) \n```\n- **`argc` (Argument Count)**: Number of strings passed (including the program name).\n- **`argv` (Argument Vector)**: An array of strings containing the arguments.\n\n---\n\n## 2. How it works in the Terminal\n\nIf you run `./program hello 123`:\n- `argc` = 3\n- `argv[0]` = \"./program\" (Always the executable name)\n- `argv[1]` = \"hello\"\n- `argv[2]` = \"123\"\n\n---\n\n## 3. üöÄ Practical Example: Terminal Adder\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc < 3) {\n        printf(\"Usage: %s num1 num2\\n\", argv[0]);\n        return 1;\n    }\n\n    int a = atoi(argv[1]); // Convert string to int\n    int b = atoi(argv[2]);\n\n    printf(\"Total: %d\\n\", a + b);\n    return 0;\n}\n```\n\n### üí° Critical Tips\n- **Validation**: Always check `argc` before accessing `argv` to avoid segmentation faults.\n- **Conversion**: Arguments are always strings. Use `atoi()` (ASCII to Integer) or `atof()` for math.\n\n---\n\n## ‚ö° Key Takeaways\n- **argv[0]**: Program identity.\n- **Flexibility**: CLIs allow automation and scripting without manual input.\n- **Safety**: Never assume the user provided the right number of arguments.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What is the value of `argv[0]`?",
                        "options": [
                            "The first user argument",
                            "The name of the program",
                            "The number of arguments",
                            "NULL"
                        ],
                        "correctAnswer": 1,
                        "explanation": "argv[0] always contains the path or name used to execute the program."
                    },
                    {
                        "id": 2,
                        "text": "If you run `a.exe 1 2 3`, what is `argc`?",
                        "options": [
                            "3",
                            "4",
                            "1",
                            "5"
                        ],
                        "correctAnswer": 1,
                        "explanation": "argc includes the program name + 3 arguments = 4."
                    }
                ]
            },
            {
                "id": "c40",
                "title": "40. Error Handling in C",
                "duration": "40 mins",
                "content": "# Professionalism: Error Handling in C\n\nC does not have `try/catch`. Instead, it uses **return codes** and a global variable called **`errno`**. Handling errors gracefully is what separates amateur code from industrial-grade software.\n\n---\n\n## 1. Return Values\n\nMost C functions return a special value on failure:\n- `fopen` returns `NULL`.\n- `malloc` returns `NULL`.\n- `main` returns `1` or non-zero to indicate failure to the OS.\n\n---\n\n## 2. The `errno` Variable\n\nWhen a system call fails, it sets a global integer called `errno`. You can find the specific cause (e.g., \"File not found\" vs \"Permission denied\").\n\n```c\n#include <errno.h>\n#include <string.h>\n\nif (failure) {\n    printf(\"Error code: %d\\n\", errno);\n    printf(\"Meaning: %s\\n\", strerror(errno));\n}\n```\n\n---\n\n## 3. `perror()` - The Shortcut\n\nThe `perror(\"string\")` function prints your custom message, followed by the system error description. It's the standard for console errors.\n\n```c\nFILE *fp = fopen(\"ghost.txt\", \"r\");\nif (fp == NULL) {\n    perror(\"Critical Error\"); // Output: Critical Error: No such file or directory\n}\n```\n\n---\n\n## 4. Common Runtime Errors\n\n- **Segmentation Fault**: Accessing memory you don't own (usually a bad pointer).\n- **Stack Overflow**: Too many nested function calls (infinite recursion).\n- **Memory Leak**: Forgetting to `free` what you `malloc`.\n\n---\n\n## ‚ö° Key Takeaways\n- **Check Everything**: Never assume a file opened or memory was allocated.\n- **perror**: Use it for quick, descriptive logs.\n- **Documentation**: Document what your function returns on failure.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Which global variable stores the error code of the last failing system call?",
                        "options": [
                            "err",
                            "errno",
                            "error_code",
                            "status"
                        ],
                        "correctAnswer": 1,
                        "explanation": "errno is defined in <errno.h> and is automatically set by system functions."
                    },
                    {
                        "id": 2,
                        "text": "What does `strerror(errno)` return?",
                        "options": [
                            "An integer",
                            "A pointer to an error message string",
                            "Nothing",
                            "A boolean"
                        ],
                        "correctAnswer": 1,
                        "explanation": "strerror converts the numeric errno into a human-readable string like 'Permission denied'."
                    }
                ]
            }
        ]
    },
    {
        "id": "c-l9",
        "title": "LEVEL 9: Final Certification",
        "lessons": [
            {
                "id": "c41",
                "title": "41. Final C Certification Exam",
                "duration": "60 mins",
                "content": "# üéì Final Certification Exam\n\n**Congratulations!** You have reached the final milestone of the C Programming Masterclass.\n\nThis certification lesson is a comprehensive review of everything you have learned, from basic variables to advanced file handling and dynamic memory management.\n\n---\n\n## üìà What this Certification Means\n\nBy passing this final quiz, you demonstrate proficiency in:\n1.  **Fundamental C Syntax**: Data types, operators, and control flow.\n2.  **Modular Programming**: Using functions and managing variable scope.\n3.  **Data Structures**: Working with arrays, strings, and the powerful `struct` system.\n4.  **Memory Mastery**: Understanding pointers and manual memory allocation (DMA).\n5.  **Systems Thinking**: Handling files and preprocessor directives.\n\n---\n\n## üìù Exam Instructions\n\n- The exam consists of **20 comprehensive questions**.\n- You must achieve a score of **70% or higher** (14 correct answers) to pass.\n- If you pass, you will be and to claim your **Official C Programming Certificate**.\n\n---\n\n## üöÄ Ready to Graduate?\n\nTake a deep breath, review your notes if needed, and click the button below to start your final assessment.\n\n**Good luck! We are rooting for you.**",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Why do professional developers use a temporary pointer when calling `realloc()`?",
                        "options": [
                            "To make the code run faster",
                            "To prevent a memory leak if `realloc` returns NULL",
                            "Because `realloc` requires two pointers",
                            "To clear the garbage values"
                        ],
                        "correctAnswer": 1,
                        "explanation": "If `realloc` fails and returns NULL, assigning it directly to the original pointer would lose the address of the existing memory, causing a leak."
                    },
                    {
                        "id": 2,
                        "text": "What is 'Memory Padding' in C structures?",
                        "options": [
                            "Extra memory added to the end of the file",
                            "Empty bytes inserted by the compiler to align members for CPU efficiency",
                            "A way to encrypt data in a struct",
                            "Deleting unused variables automatically"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Compilers insert padding bytes to ensure that structure members are aligned with memory boundaries that the CPU can access efficiently."
                    },
                    {
                        "id": 3,
                        "text": "Which `fseek` origin constant is used to move the pointer relative to the current position?",
                        "options": [
                            "SEEK_SET",
                            "SEEK_END",
                            "SEEK_CUR",
                            "SEEK_START"
                        ],
                        "correctAnswer": 2,
                        "explanation": "SEEK_CUR is used in `fseek` to specify that the offset is relative to the current file pointer position."
                    },
                    {
                        "id": 4,
                        "text": "What is a 'Dangling Pointer'?",
                        "options": [
                            "A pointer that points to NULL",
                            "A pointer that points to memory that has already been freed",
                            "A pointer that hasn't been initialized yet",
                            "A pointer used in a loop"
                        ],
                        "correctAnswer": 1,
                        "explanation": "A dangling pointer occurs after `free()` is called if the pointer is not set to NULL; it still holds the address of 'dead' memory."
                    },
                    {
                        "id": 5,
                        "text": "Which preprocessor directive is most commonly used as a 'Header Guard'?",
                        "options": [
                            "#include",
                            "#define",
                            "#ifndef...#define...#endif",
                            "#pragma once (only)"
                        ],
                        "correctAnswer": 2,
                        "explanation": "The #ifndef pattern is the standard, cross-platform way to prevent multiple inclusions of the same header file."
                    },
                    {
                        "id": 6,
                        "text": "Which memory segment stores local variables and function call information?",
                        "options": [
                            "Heap",
                            "Data Segment",
                            "Stack",
                            "Text Segment"
                        ],
                        "correctAnswer": 2,
                        "explanation": "The Stack is responsible for automatic memory management of local variables and 'frames' for function calls."
                    },
                    {
                        "id": 7,
                        "text": "What is the difference between `malloc` and `calloc`?",
                        "options": [
                            "malloc is faster; calloc initializes memory to zero",
                            "calloc is only for arrays of floats",
                            "malloc handles files, calloc handles RAM",
                            "There is no difference"
                        ],
                        "correctAnswer": 0,
                        "explanation": "malloc leaves garbage values in the memory, while calloc explicitly writes zeros to every bit, which is safer but slightly slower."
                    },
                    {
                        "id": 8,
                        "text": "Which bitwise operator is used to 'turn on' a specific bit (set it to 1) without changing others?",
                        "options": [
                            "& (AND)",
                            "| (OR)",
                            "^ (XOR)",
                            "~ (NOT)"
                        ],
                        "correctAnswer": 1,
                        "explanation": "The OR operator (|) is used to set specific bits. Any bit ORed with 1 becomes 1."
                    },
                    {
                        "id": 9,
                        "text": "Which storage class should you use to make a variable 'remember' its value between function calls without using global variables?",
                        "options": [
                            "auto",
                            "extern",
                            "static",
                            "register"
                        ],
                        "correctAnswer": 2,
                        "explanation": "A `static` local variable is initialized once and persists in the Data Segment for the entire duration of the program."
                    },
                    {
                        "id": 10,
                        "text": "What happens if you call `free()` on a NULL pointer?",
                        "options": [
                            "The program crashes",
                            "It causes a memory leak",
                            "Nothing; it is a safe operation in standard C",
                            "It restarts the computer"
                        ],
                        "correctAnswer": 2,
                        "explanation": "Standard C guarantees that calling `free(NULL)` does absolutely nothing and is perfectly safe. This is why 'NULLifying' pointers after freeing them is a best practice."
                    },
                    {
                        "id": 11,
                        "text": "What is the output of the following code snippet?\n\n```c\nint a = 5;\nint *p = &a;\nprintf(\"%d\", (*p)++);\nprintf(\"%d\", a);\n```",
                        "options": [
                            "55",
                            "56",
                            "66",
                            "65"
                        ],
                        "correctAnswer": 1,
                        "explanation": "(*p)++ is a post-increment of the value. It prints the current value (5) first, then increments 'a' to 6."
                    },
                    {
                        "id": 12,
                        "text": "What does this code print?\n\n```c\nchar str[] = \"Genspark\";\nprintf(\"%zu\", sizeof(str));\n```",
                        "options": [
                            "8",
                            "9",
                            "4",
                            "1"
                        ],
                        "correctAnswer": 1,
                        "explanation": "sizeof includes the hidden null terminator '\\0' at the end of the string literal."
                    },
                    {
                        "id": 13,
                        "text": "Analyze this code. What is wrong with it?\n\n```c\nvoid count() {\n    static int x = 0;\n    x++;\n    printf(\"%d\", x);\n}\n```",
                        "options": [
                            "Nothing, it correctly counts calls",
                            "x will be reset to 0 every call",
                            "static variables cannot be initialized",
                            "It will cause a link error"
                        ],
                        "correctAnswer": 0,
                        "explanation": "This is correct C code. Static variables are initialized once and retain their value between calls."
                    },
                    {
                        "id": 14,
                        "text": "Output of: `printf(\"%d\", 5 | 2);`",
                        "options": [
                            "7",
                            "5",
                            "2",
                            "1"
                        ],
                        "correctAnswer": 0,
                        "explanation": "5 is 101, 2 is 010. 101 | 010 = 111, which is 7."
                    },
                    {
                        "id": 15,
                        "text": "What is the result of `1 << 3`?",
                        "options": [
                            "3",
                            "4",
                            "8",
                            "1"
                        ],
                        "correctAnswer": 2,
                        "explanation": "Shifting 1 left by 3 bits: 0001 -> 1000, which is 8."
                    },
                    {
                        "id": 16,
                        "text": "Analyze for bugs: `int *ptr = malloc(sizeof(int)); *ptr = 10; return;`",
                        "options": [
                            "Syntax error",
                            "Memory Leak",
                            "Segmentation Fault",
                            "Dangling Pointer"
                        ],
                        "correctAnswer": 1,
                        "explanation": "The memory was allocated via malloc but never freed before the function returns, causing a leak."
                    },
                    {
                        "id": 17,
                        "text": "Bug detection: `char *s; strcpy(s, \"Hi\");`",
                        "options": [
                            "Buffer Overflow",
                            "Uninitialized Pointer",
                            "Memory Leak",
                            "Format String Error"
                        ],
                        "correctAnswer": 1,
                        "explanation": "The pointer 's' is declared but doesn't point to any allocated memory, leading to undefined behavior."
                    },
                    {
                        "id": 18,
                        "text": "Identify the risk: `void f() { f(); }`",
                        "options": [
                            "Memory Leak",
                            "Stack Overflow",
                            "Arithmetic Overflow",
                            "Infinite Loop (only)"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Infinite recursion without a base case will eventually exhaust the stack memory."
                    },
                    {
                        "id": 19,
                        "text": "Which access method is correct for `struct Node *n;`?",
                        "options": [
                            "n.value",
                            "n->value",
                            "n(value)",
                            "*n->value"
                        ],
                        "correctAnswer": 1,
                        "explanation": "For pointers to structures, the 'arrow' operator (->) must be used."
                    },
                    {
                        "id": 20,
                        "text": "Final Analysis: Is C a compiled or interpreted language?",
                        "options": [
                            "Interpreted",
                            "Compiled",
                            "Both",
                            "Neither"
                        ],
                        "correctAnswer": 1,
                        "explanation": "C is a compiled language; source code is translated into machine-readable binaries before execution."
                    }
                ]
            }
        ]
    }
]