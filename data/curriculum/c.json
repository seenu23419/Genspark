[
    {
        "id": "c-l1",
        "title": "LEVEL 1: Introduction",
        "lessons": [
            {
                "id": "c1",
                "title": "Lesson 1: Introduction",
                "duration": "15 mins",
                "content": "**Welcome to C Programming!** Your journey to becoming a powerful programmer starts here. C is the foundation of modern computing.\n\n---\n\n## What is C?\n\nC is a **general-purpose, low-level programming language** created to make computers do exactly what you want.\n\n- **General-purpose**  Used for almost any type of software\n- **Low-level**  Close to hardware, giving you control\n- **Fast & Efficient**  Programs run at lightning speed\n- **Portable**  Write once, run anywhere\n\n> C has been closely associated with the UNIX system where it was developed, since both the system and most of the programs that run on it are written in C.\n\n---\n\n## Header Files in C\n\nBefore we dive deeper, we need to understand **Header Files**. In C, header files (ending in `.h`) contain declarations for functions that are defined in external libraries.\n\n### Why Use Header Files?\n\n- **Reusability**: You don't have to write the same function code repeatedly.\n- **Organization**: They help keep your code clean by separating declarations from logic.\n- **Standard Libraries**: C provides many built-in header files like `<stdio.h>` for input/output and `<math.h>` for mathematical calculations.\n\n---\n\n## History of C Language\n\n- **Created by:** Dennis Ritchie at AT&T Bell Labs (1972)\n- **Purpose:** To overcome limitations of earlier languages (B, BCPL)\n- **First Use:** Building the UNIX operating system\n- **Legacy:** Still one of the most popular languages today\n\n> Dennis Ritchie is known as the founder of C language and his creation revolutionized computer science.\n\n---\n\n## Why Learn C?\n\n### C is a Core Language\nIn computing, C is the foundational language that teaches you how computers really work. It builds a mental model of memory and execution that will make you a better programmer in *any* language.\n\n### C is Small & Simple\n- Only 32 keywords (most languages have 50+)\n- Simple to learn, powerful to use\n- Easy to remember the basics\n\n### C is Fast\n- No \"middleman\" software slowing you down\n- Direct access to computer hardware\n- Perfect for performance-critical applications\n\n### C is Portable\n- Write code once on Windows\n- Run it unchanged on Mac or Linux\n- Works on phones, IoT devices, supercomputers\n\n---\n\n## Advantages & Limitations of C\n\nTo understand C completely, we must look at both its strengths and its weaknesses.\n\n### Advantages\n\n1. **High Performance**: C is extremely fast because it runs close to the hardware.\n2. **Portability**: C programs can run on any machine with little to no changes.\n3. **Low-Level Access**: You can directly control memory and hardware, perfect for drivers and kernels.\n4. **Structured**: It allows breaking complex problems into smaller functions.\n5. **Core Foundation**: Learning C makes it easy to learn C++, Java, and Python later.\n\n### Limitations\n\n1. **No Constructor / Destructor**: Unlike C++ or Java, C does not support Object-Oriented Programming (OOP).\n2. **Manual Memory Management**: You must allocate and free memory yourself. Forgetting to free memory causes **memory leaks**.\n3. **No Garbage Collection**: There is no automatic system to clean up unused memory.\n4. **Runtime Checking**: C has strict checking at compile time but very little at runtime (e.g., array index out of bounds is not checked).\n5. **No Namespaces**: All variables must have unique names in the global scope, which can cause naming conflicts in large projects.\n\n---\n\n## Real-World Applications\n\n### Operating Systems\n- Linux Kernel\n- Windows Core\n- macOS Foundation\n\n*C powers the software on billions of devices*\n\n### Embedded Systems\n- Cars & Automobiles\n- Medical Devices\n- Smart Home Appliances\n\n*C runs the tiny computers inside everyday devices*\n\n### High-Performance Software\n- Databases (MySQL, Oracle)\n- Game Engines\n- Compilers & Interpreters\n\n*C handles millions of operations per second*\n\n### Software Development Tools\n- Compilers\n- Text Editors\n- Version Control Systems\n\n*Tools you use are often built with C*\n\n---\n\n## How C Works: The Compilation Process\n\nComputers don't understand C code directly. They only understand binary (0s and 1s). To run a C program, it must be **compiled**.\n\nThe journey from Code to Execution involves 4 steps:\n\n1. **Preprocessing**: The preprocessor handles lines starting with `#` (like `#include`). It prepares the code for compilation.\n2. **Compilation**: The compiler translates your C code into **Assembly code** (low-level human-readable instructions).\n3. **Assembly**: The assembler converts the assembly code into **Object code** (binary machine code, but not yet executable).\n4. **Linking**: The linker combines your object code with library files (like the code for `printf`) to create the final **Executable file** (e.g., `.exe` or `.out`).\n\n> **Source Code (.c)**  **Compiler**  **Machine Code (.exe)**\n\n---\n\n## C vs. Other Languages\n\nWhy learn C when we have Python or Java?\n\n| Feature | **C Language** | **Python / Java** |\n| :--- | :--- | :--- |\n| **Type** | Compiled (Machine Code) | Interpreted / VM |\n| **Speed** | Extremely Fast | Slower |\n| **Memory** | Manual (You control it) | Automatic (Garbage Collection) |\n| **Usage** | Systems, Embedded | Web, Apps |\n\n---\n\n## Your First C Program\n\nEvery programming journey starts with a simple tradition: printing \"Hello, World!\" to the screen. Here is what it looks like in C:\n\n```c\n#include <stdio.h>\n\nint main() {\n    printf(\"Hello, World!\\n\");\n    return 0;\n}\n```\n\n### Breaking it Down:\n\n1. `#include <stdio.h>`: This line tells the compiler to include the **Standard Input Output** library. It contains the code for input/output functions like `printf`.\n2. `int main() { ... }`: This is the **main function**. Every C program starts execution from here.\n3. `printf(\"Hello, World!\\n\");`: This function prints text to the screen. The `\\n` creates a new line.\n4. `return 0;`: This ends the main function and returns `0` to the operating system, which means \"the program finished successfully\".\n\n---\n\n## What You'll Learn\n\nIn this C journey, you'll master:\n\n- **Fundamentals**  Variables, Data Types, Operators\n- **Control Flow**  Decision Making, Loops\n- **Functions**  Modular, Reusable Code\n- **Arrays & Strings**  Handling Collections of Data\n- **Pointers**  Advanced Memory Management\n- **Structures**  Organizing Complex Data\n- **File Handling**  Reading & Writing Files\n\n---\n\n## Your Next Steps\n\n1. **Start with:** Keywords and Identifiers\n2. **Then:** Build your first real program\n3. **Finally:** Take the Quiz below to test your knowledge!\n\n> *\"The way to get started is to quit talking and begin doing.\" — Walt Disney*",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Where does the execution of every C program start?",
                        "options": [
                            "From the first line of the file",
                            "From the main() function",
                            "From the #include statement",
                            "From user input"
                        ],
                        "correctAnswer": 1,
                        "explanation": "The execution of every C program always begins inside the 'main()' function."
                    },
                    {
                        "id": 2,
                        "text": "What is the role of the 'Compiler' in C?",
                        "options": [
                            "To run the program directly",
                            "To convert C code into machine code (binary)",
                            "To write the code for you",
                            "To organize files in folders"
                        ],
                        "correctAnswer": 1,
                        "explanation": "The compiler translates human-readable C code into machine code (binary 0s and 1s) that the computer can execute."
                    },
                    {
                        "id": 3,
                        "text": "What does the line '#include <stdio.h>' do?",
                        "options": [
                            "It prints text to the screen",
                            "It cleans up memory",
                            "It includes the Standard Input Output library",
                            "It defines the main function"
                        ],
                        "correctAnswer": 2,
                        "explanation": "This line tells the preprocessor to include the 'stdio.h' library, which contains input/output functions like 'printf'."
                    },
                    {
                        "id": 4,
                        "text": "Which step of compilation combines object code with libraries to create an executable?",
                        "options": [
                            "Preprocessing",
                            "Compiling",
                            "Assembling",
                            "Linking"
                        ],
                        "correctAnswer": 3,
                        "explanation": "The 'Linking' step combines your object code with external libraries (like stdio.h code) to produce the final executable file."
                    },
                    {
                        "id": 5,
                        "text": "What is the purpose of the 'return 0;' statement in the main function?",
                        "options": [
                            "To repeat the program",
                            "To stop the program and indicate success",
                            "To print 0 to the screen",
                            "To pause the program"
                        ],
                        "correctAnswer": 1,
                        "explanation": "'return 0;' terminates the main function and returns the value 0 to the OS, indicating that the program finished successfully."
                    }
                ]
            },
            {
                "id": "c2",
                "title": "Lesson 2: Keywords and Identifiers",
                "duration": "20 mins",
                "content": "**Welcome to Lesson 2!** Now that you understand the basics of C, it's time to learn the building blocks of the language: Keywords and Identifiers.\n\n---\n\n## Keywords\n\nKeywords in C are **reserved words** that have a fixed meaning defined by the language itself.\n\nYou cannot use them as variable names, function names, or identifiers. The compiler already understands exactly what each keyword represents and how it should behave.\n\n> **Important:** All C keywords must be written in **lowercase**. Using uppercase or mixed case will not work and will be treated as normal identifiers.\n\n---\n\n## What Keywords Do\n\nKeywords are the vocabulary of C. They are used to:\n- **Declare variables** (e.g., `int`, `char`)\n- **Control program flow** (e.g., `if`, `while`)\n- **Manage memory** (e.g., `static`, `sizeof`)\n- **Give instructions** (e.g., `return`, `break`)\n\nBecause their meanings are predefined, keywords cannot be redefined or repurposed by the programmer.\n\n---\n\n## The 32 C Keywords\n\nC is a small language with only 32 keywords. They are broadly categorized as follows:\n\n### Data Type Keywords (9)\n\nUsed to specify the type of data a variable holds.\n\n- `char`, `int`, `float`, `double`, `void`\n- `signed`, `unsigned`, `short`, `long`\n\n### Control Flow Keywords (12)\n\nUsed to control the logic and flow of the program.\n\n- **Decisions:** `if`, `else`, `switch`, `case`, `default`\n- **Loops:** `for`, `while`, `do`\n- **Jumps:** `break`, `continue`, `goto`, `return`\n\n### Storage & Structure Keywords (11)\n\nUsed for memory management and defining data structures.\n\n- `auto`, `static`, `extern`, `register`\n- `const`, `volatile`, `restrict`\n- `struct`, `union`, `enum`, `typedef`, `sizeof`\n\n---\n\n## Identifiers\n\nIdentifiers are the **names you create** to identify different elements in a C program.\n\nUnlike keywords (which strictly belong to C), identifiers belong to **you**. You use them to name your variables, functions, arrays, and structures.\n\n---\n\n## Rules for Writing Identifiers\n\nTo ensure your code compiles correctly, you must follow these rules when naming things:\n\n### Rule 1: Characters Allowed\nAn identifier can only contain:\n- **Letters:** a–z, A–Z\n- **Digits:** 0–9\n- **Underscore:** _\n\n### Rule 2: No Leading Digits\nAn identifier must **NOT** start with a digit.\n- Valid: `number`, `_count`, `var1`\n- Invalid: `9number`, `1stValue`\n\n### Rule 3: Case Sensitivity\nC is case-sensitive. `number`, `Number`, and `NUMBER` are three different identifiers.\n\n### Rule 4: No Special Characters\nDo NOT use special characters or spaces.\n- Valid: `myVar`, `count1`, `_value`\n- Invalid: `my var`, `value$`\n\n### Rule 5: No Keywords\nYou cannot use a keyword as an identifier.\n- Invalid: `int`, `while`, `return`\n\n---\n\n## How They Work Together\n\nEvery line of C code is a mix of keywords and identifiers.\n\n**Example 1:**\n```c\nint age;\n```\n- `int`  **Keyword** (tells C this is an integer)\n- `age`  **Identifier** (the name you gave this integer)\n\n**Example 2:**\n```c\nreturn result;\n```\n- `return`  **Keyword** (instruction to exit)\n- `result`  **Identifier** (variable being returned)\n\n---\n\n## Your Next Steps\n\n1. **Start with:** Variables and Constants\n2. **Then:** Learn how to store data\n3. **Finally:** Take the Quiz below to test your knowledge!",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What is the key difference between a Keyword and an Identifier?",
                        "options": [
                            "Keywords are user-defined names, Identifiers are reserved words",
                            "Keywords are reserved words with fixed meanings, Identifiers are user-defined names",
                            "Both are used to name variables",
                            "They are exactly the same"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Keywords are predefined by C (like 'int', 'return'), while Identifiers are names you create (like 'myVariable', 'score')."
                    },
                    {
                        "id": 2,
                        "text": "According to the Compiler Insight, where are Identifiers stored during compilation?",
                        "options": [
                            "In the text editor",
                            "In the Symbol Table",
                            "In the Keyword Dictionary",
                            "In the CPU register"
                        ],
                        "correctAnswer": 1,
                        "explanation": "The compiler stores all user-defined identifiers in a data structure called a 'Symbol Table' to manage them."
                    },
                    {
                        "id": 3,
                        "text": "Which of the following is a VALID identifier?",
                        "options": [
                            "2ndPlace",
                            "my-score",
                            "_totalCount",
                            "break"
                        ],
                        "correctAnswer": 2,
                        "explanation": "'_totalCount' is valid. '2ndPlace' starts with a digit, 'my-score' has a hyphen, and 'break' is a reserved keyword."
                    },
                    {
                        "id": 4,
                        "text": "How must all C keywords be written?",
                        "options": [
                            "In UPPERCASE",
                            "In CamelCase",
                            "In lowercase",
                            "In any case (insensitive)"
                        ],
                        "correctAnswer": 2,
                        "explanation": "C is case-sensitive, and all standard keywords (like 'if', 'while', 'int') must strictly be written in lowercase."
                    },
                    {
                        "id": 5,
                        "text": "How many keywords does the C language have?",
                        "options": [
                            "25",
                            "32",
                            "50",
                            "100"
                        ],
                        "correctAnswer": 1,
                        "explanation": "C is a small and simple language with exactly 32 standard keywords."
                    }
                ]
            },
            {
                "id": "c3",
                "title": "Lesson 3: Variables and Constants",
                "duration": "25 mins",
                "content": "**Welcome to Lesson 3!** In this lesson, we will explore the fundamental containers of data in C: Variables and Constants.\n\n---\n\n## What is a Variable?\n\nA variable is a **named memory location** used to store data that can be changed during program execution. When you save a value in C, you choose a name (identifier) and a storage type (data type).\n\n- **Container**  Variables hold your data\n- **Dynamic**  The value can change as the program runs\n- **Addressable**  Each variable exists at a specific location in your computer's RAM\n\n---\n\n## Syntax for Declaring Variables\n\nTo create a variable, you must specify its **Data Type** followed by its **Name**.\n\n```c\n<datatype> <variable_name>;\n```\n\n**Example:**\n```c\nint age;      // Declaration\nage = 25;     // Initialization\nint score = 100; // Declaration + Initialization\n```\n\n---\n\n## Rules for Variable Names\n\nSince variable names are **Identifiers**, they must follow the same rules we learned in Lesson 2:\n1. **Allowed Characters**: Only letters, digits, and underscores (`_`).\n2. **No Leading Digits**: Cannot start with `0-9`.\n3. **Case Sensitive**: `myVar` and `myvar` are different.\n4. **No Keywords**: Cannot name a variable `int` or `while`.\n\n---\n\n## C Constants\n\nConstants are fixed values that **cannot be modified after initialization**. They are used for values that should remain permanent, like the value of PI or maximum limits.\n\n### Method 1: The `const` Keyword\nUsing `const` creates a \"read-only\" variable. It occupies memory and has a specific data type.\n\n```c\nconst float PI = 3.14159;\n```\n\n### Method 2: The `#define` Directive\n`#define` is a preprocessor command. It tells the compiler to replace every instance of a word with a value *before* the code actually compiles.\n\n```c\n#define MAX_VAL 100\n```\n\n---\n\n## Compiler Insight: const vs #define\n\nWhile both create constants, they work very differently under the hood:\n\n- **`const`** is handled by the **Compiler**. It has a type (like `int` or `float`) and follows scope rules. It actually takes up space in memory.\n- **`#define`** is handled by the **Preprocessor**. It is a simple \"find and replace\" mechanism. It has no type and does not take up memory in the same way.\n\n> **Tip:** Modern C programmers prefer `const` because the compiler can catch type errors, whereas `#define` can sometimes lead to sneaky bugs.\n\n---\n\n## Example Program\n\nHere is a simple program that uses both variables and constants to calculate a final score.\n\n```c\n#include <stdio.h>\n\n#define MAX_SCORE 100\n\nint main() {\n    const int BONUS = 10;\n    int baseScore = 85;\n    int finalScore;\n\n    finalScore = baseScore + BONUS;\n\n    printf(\"Base Score: %d\\n\", baseScore);\n    printf(\"Bonus Applied: %d\\n\", BONUS);\n    printf(\"Final Score: %d\\n\", finalScore);\n    printf(\"Maximum Possible: %d\\n\", MAX_SCORE);\n\n    return 0;\n}\n```\n\n### Expected Output:\n```text\nBase Score: 85\nBonus Applied: 10\nFinal Score: 95\nMaximum Possible: 100\n```\n\n### How it Works:\n\n1. **Line 3**: `#define MAX_SCORE 100` tells the **Preprocessor** to replace every occurrence of `MAX_SCORE` with `100` before the code compiles.\n2. **Line 6**: `const int BONUS` creates a read-only variable. Once initialized to 10, it cannot be changed during execution.\n3. **Line 7**: `int baseScore = 85` is a standard **Variable**. This can be updated later if the student gains more points.\n4. **Line 13-16**: `printf` displays the values. Notice how we use `%d` for integers.\n\n### Key Takeaways:\n1. **`baseScore`** is a variable (dynamic data).\n2. **`BONUS`** is a typed constant (memory-resident, fixed value).\n3. **`MAX_SCORE`** is a preprocessor macro (text replacement).\n\n---\n\n## Your Next Steps\n\n1. **Start with:** C Data Types\n2. **Then:** Master how memory is allocated\n3. **Finally:** Take the Quiz below to test your knowledge!\n\n> *\"Code is like humor. When you have to explain it, it’s bad.\" — Cory House*",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Technically, what is a variable in the C language?",
                        "options": [
                            "A nickname for a hard drive file",
                            "A named memory location in RAM",
                            "A temporary instruction for the CPU",
                            "A fixed value that never changes"
                        ],
                        "correctAnswer": 1,
                        "explanation": "A variable is a named location in the computer's memory (RAM) where data is stored and can be modified."
                    },
                    {
                        "id": 2,
                        "text": "What is the difference between declaring and initializing a variable?",
                        "options": [
                            "They are exactly the same thing",
                            "Declaring creates the name; Initializing gives it a first value",
                            "Initializing creates the name; Declaring gives it a first value",
                            "Declaring is for constants; Initializing is for variables"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Declaring tells the compiler the variable's name and type. Initializing is the act of assigning it an initial value (e.g., 'int x = 10;')."
                    },
                    {
                        "id": 3,
                        "text": "Based on the Compiler Insight, why is 'const' often preferred over '#define'?",
                        "options": [
                            "Because 'const' makes the program run faster",
                            "Because '#define' uses more memory",
                            "Because 'const' is type-safe and handled by the compiler",
                            "Because 'const' can be changed later"
                        ],
                        "correctAnswer": 2,
                        "explanation": "Modern programmers prefer 'const' because it has a data type, allowing the compiler to catch errors that the preprocessor would miss with '#define'."
                    },
                    {
                        "id": 4,
                        "text": "Which component of the C build process handles the '#define' directive?",
                        "options": [
                            "The Linker",
                            "The Assembler",
                            "The Preprocessor",
                            "The CPU"
                        ],
                        "correctAnswer": 2,
                        "explanation": "The Preprocessor handles all directives starting with '#' (like #include and #define) before the actual compilation begins."
                    },
                    {
                        "id": 5,
                        "text": "Which of the following is a VALID variable declaration and initialization in C?",
                        "options": [
                            "integer x = 5;",
                            "int 1stValue = 10;",
                            "float _price = 19.99;",
                            "var count = 0;"
                        ],
                        "correctAnswer": 2,
                        "explanation": "'float _price = 19.99;' is valid. '1stValue' is invalid because it starts with a digit, and 'var' or 'integer' are not keywords in C."
                    }
                ]
            },
            {
                "id": "c4",
                "title": "Lesson 4: Data Types",
                "duration": "30 mins",
                "content": "A data type is a C keyword that tells the compiler what kind of data a variable will store.\nWithout a data type, the compiler has no idea how much memory to allocate or how to interpret the stored value.\n\nA data type gives the compiler two critical pieces of information:\n1. **Size of the data** (how much memory is required)\n2. **Type of the data** (integer, decimal, character, etc.)\n\nBased on this, the compiler knows how to store, read, and modify the data.\n\n---\n\n## Categories of Data Types in C\n\nC data types are mainly divided into two categories:\n1. **Basic (Primitive) Data Types**\n2. **User-Defined & Derived Data Types**\n\n---\n\n## Basic / Primitive Data Types\n\nPrimitive data types are the **fundamental building blocks** of C programming. They are built into the language and represent the simplest forms of data that can be stored in memory.\n\n> **Why are they called 'Primitive'?**\n> Because they cannot be broken down into simpler types. They are the foundation upon which all other complex data structures are built.\n\n---\n\n## Understanding Primitive Data Types\n\n### `int` (Integer)\n\n**What is an Integer?**\nAn integer is a whole number without any fractional or decimal part. It can be positive, negative, or zero.\n\n **Size**: 4 bytes (32 bits) on most modern systems\n\n **Range**: -2,147,483,648 to 2,147,483,647\n\n **Memory Representation**: Stored in binary format using 2's complement for negative numbers\n\n **Purpose**: Used to store whole numbers like age, count, roll numbers, scores\n\n **Examples**: `-10, 0, 25, 1000, 45000`\n\n**When to use int:**\n- Counting items (number of students, products, etc.)\n- Loop counters\n- Array indices\n- Mathematical calculations without decimals\n- Age, year, quantity\n\n**Example code:**\n```c\nint age = 21;\nint score = -5;\nint max_value = 2147483647;\nint count = 0;\nint year = 2024;\n```\n\n**Important Notes:**\n- If you try to store a value larger than 2,147,483,647, it will **overflow** and wrap around to negative values\n- Integer division truncates decimals: `7 / 2 = 3` (not 3.5)\n\n---\n\n### Type Modifiers for int\n\nYou can modify the `int` type to change its size and range:\n\n#### **`signed int`** (default)\n- Can store both positive and negative numbers\n- Range: -2,147,483,648 to 2,147,483,647\n- `int` and `signed int` are the same\n\n```c\nsigned int temperature = -15;  // Can be negative\n```\n\n#### **`unsigned int`**\n- Can ONLY store positive numbers (0 and above)\n- Range: 0 to 4,294,967,295 (double the positive range)\n- Useful when you know the value will never be negative\n\n```c\nunsigned int population = 1000000;  // Always positive\nunsigned int age = 25;  // Age cannot be negative\n```\n\n#### **`short int`** (or just `short`)\n- Smaller integer type\n- Size: 2 bytes (16 bits)\n- Range: -32,768 to 32,767\n- Use when you need to save memory\n\n```c\nshort int marks = 95;\nshort day = 15;  // Day of month (1-31)\n```\n\n#### **`long int`** (or just `long`)\n- Larger integer type\n- Size: 4 or 8 bytes (system dependent)\n- Range: At least -2,147,483,648 to 2,147,483,647\n- Use for very large numbers\n\n```c\nlong int distance = 9876543210L;\nlong population = 7800000000L;  // World population\n```\n\n#### **`long long int`**\n- Even larger integer type\n- Size: 8 bytes (64 bits)\n- Range: -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807\n\n```c\nlong long int bigNumber = 9223372036854775807LL;\n```\n\n---\n\n### `float` (Single Precision Decimal)\n\n**What is a Float?**\nA float is a data type used to store decimal numbers (numbers with fractional parts). It uses **floating-point representation** to store very large or very small numbers efficiently.\n\n **Size**: 4 bytes (32 bits)\n\n **Range**: Approximately ±3.4e-38 to ±3.4e+38\n\n **Precision**: 6-7 significant digits\n\n **Memory Representation**: Uses IEEE 754 standard (1 sign bit, 8 exponent bits, 23 mantissa bits)\n\n **Purpose**: Used to store decimal numbers when high precision is not critical\n\n **Examples**: `3.14f, -0.5f, 99.99f, 2.5e-3f`\n\n**When to use float:**\n- Storing prices (with limited precision)\n- Temperature readings\n- Percentages\n- Graphics and game development (coordinates, colors)\n- When memory is limited and high precision is not needed\n\n**Example code:**\n```c\nfloat temperature = 36.5f;\nfloat price = 19.99f;\nfloat pi = 3.14f;\nfloat percentage = 85.5f;\nfloat weight = 65.75f;\n```\n\n**Important Notes:**\n- Always add `f` suffix to float literals: `3.14f` (without `f`, it's treated as double)\n- Float has limited precision - don't use for financial calculations\n- Comparing floats with `==` can be unreliable due to precision errors\n\n**Precision Example:**\n```c\nfloat x = 0.1f + 0.2f;\n// x might not be exactly 0.3 due to floating-point representation\n```\n\n---\n\n### `double` (Double Precision Decimal)\n\n**What is a Double?**\nA double is like a float but with **double the precision**. It can store decimal numbers with much higher accuracy.\n\n **Size**: 8 bytes (64 bits)\n\n **Range**: Approximately ±1.7e-308 to ±1.7e+308\n\n **Precision**: 15-17 significant digits\n\n **Memory Representation**: Uses IEEE 754 standard (1 sign bit, 11 exponent bits, 52 mantissa bits)\n\n **Purpose**: Used to store decimal numbers with HIGH precision\n\n **Examples**: `3.1415926535, 12345.678912, 9.99999, 1.23e-5`\n\n**When to use double:**\n- Scientific calculations requiring high precision\n- Financial calculations (money)\n- Mathematical computations (trigonometry, calculus)\n- Engineering applications\n- Default choice for decimal numbers in C\n\n**Example code:**\n```c\ndouble distance = 12345.6789;\ndouble pi = 3.14159265358979;\ndouble scientific_value = 1.23e-5;\ndouble account_balance = 1234567.89;\ndouble gravity = 9.80665;  // m/s²\n```\n\n**Important Notes:**\n- No suffix needed for double literals: `3.14` is automatically a double\n- More accurate than float but uses twice the memory\n- Preferred over float for most applications\n\n**Float vs Double Comparison:**\n```c\nfloat f = 3.14159265358979f;\ndouble d = 3.14159265358979;\n\nprintf(\"Float:  %.15f\\n\", f);   // Less precision\nprintf(\"Double: %.15f\\n\", d);   // More precision\n```\n\n---\n\n### `char` (Single Character)\n\n**What is a Char?**\nA char stores a **single character** like a letter, digit, or symbol. Internally, it's stored as a small integer (ASCII value).\n\n **Size**: 1 byte (8 bits)\n\n **Range**: -128 to 127 (or 0 to 255 if unsigned)\n\n **Memory Representation**: Stores the ASCII code of the character\n\n **Purpose**: Used to store single characters or small integer values\n\n **Examples**: `'A', 'z', '@', '9', '\\n', ' '`\n\n**When to use char:**\n- Storing single characters (grades, symbols, initials)\n- Building strings (arrays of characters)\n- Small integer values (-128 to 127)\n- Menu choices ('Y'/'N', 'A'/'B'/'C')\n\n**Example code:**\n```c\nchar grade = 'A';\nchar symbol = '@';\nchar digit = '5';  // Character '5', not number 5\nchar newline = '\\n';\nchar initial = 'J';\n```\n\n**Understanding ASCII:**\nEvery character has a numeric code (ASCII value):\n- `'A'` = 65\n- `'a'` = 97\n- `'0'` = 48\n- `' '` (space) = 32\n\n```c\nchar ch = 'A';\nprintf(\"Character: %c\\n\", ch);  // Prints: A\nprintf(\"ASCII value: %d\\n\", ch);  // Prints: 65\n```\n\n**Special Characters (Escape Sequences):**\n```c\nchar newline = '\\n';   // New line\nchar tab = '\\t';       // Tab\nchar backslash = '\\\\'; // Backslash\nchar quote = '\\'';     // Single quote\n```\n\n**unsigned char:**\n- Range: 0 to 255\n- Used for binary data or when you need values above 127\n\n```c\nunsigned char byte = 255;\n```\n\n---\n\n### `void` (No Value)\n\n**What is Void?**\nVoid means **\"nothing\"** or **\"no type\"**. It's used to indicate the absence of a value.\n\n **Size**: No size (represents absence of value)\n\n **Purpose**: Used to specify that a function does not return any value\n\n **Usage**: Common in function return types and generic pointers\n\n**When to use void:**\n1. **Function returns nothing:**\n```c\nvoid displayMessage() {\n    printf(\"Hello, World!\");\n    // No return statement needed\n}\n```\n\n2. **Function takes no parameters:**\n```c\nvoid greet(void) {\n    printf(\"Welcome!\");\n}\n```\n\n3. **Generic pointers:**\n```c\nvoid *ptr;  // Can point to any data type\n```\n\n---\n\n## Size of Data Types\n\nYou can check the exact size using the `sizeof()` operator:\n\n```c\n#include <stdio.h>\n\nint main() {\n    printf(\"Size of int: %lu bytes\\n\", sizeof(int));\n    printf(\"Size of float: %lu bytes\\n\", sizeof(float));\n    printf(\"Size of double: %lu bytes\\n\", sizeof(double));\n    printf(\"Size of char: %lu byte\\n\", sizeof(char));\n    printf(\"Size of short: %lu bytes\\n\", sizeof(short));\n    printf(\"Size of long: %lu bytes\\n\", sizeof(long));\n    printf(\"Size of long long: %lu bytes\\n\", sizeof(long long));\n    \n    return 0;\n}\n```\n\n### Expected Output\n\n```text\nSize of int: 4 bytes\nSize of float: 4 bytes\nSize of double: 8 bytes\nSize of char: 1 byte\nSize of short: 2 bytes\nSize of long: 8 bytes\nSize of long long: 8 bytes\n```\n\n---\n\n## Complete Data Types Summary Table\n\n| Type | Size | Range | Precision | Purpose | Examples |\n|------|------|-------|-----------|---------|----------|\n| **char** | 1 byte | -128 to 127 | N/A | Single character | 'A', '@', '9' |\n| **unsigned char** | 1 byte | 0 to 255 | N/A | Positive characters | 200, 255 |\n| **short** | 2 bytes | -32,768 to 32,767 | N/A | Small integers | 100, -500 |\n| **unsigned short** | 2 bytes | 0 to 65,535 | N/A | Small positive integers | 60000 |\n| **int** | 4 bytes | -2,147,483,648 to 2,147,483,647 | N/A | Whole numbers | -10, 0, 1000 |\n| **unsigned int** | 4 bytes | 0 to 4,294,967,295 | N/A | Large positive integers | 3000000000 |\n| **long** | 4-8 bytes | System dependent | N/A | Large integers | 2147483647L |\n| **long long** | 8 bytes | ±9,223,372,036,854,775,807 | N/A | Very large integers | 9223372036854775807LL |\n| **float** | 4 bytes | ±3.4e±38 | 6-7 digits | Decimal numbers | 3.14f, 99.99f |\n| **double** | 8 bytes | ±1.7e±308 | 15-17 digits | High precision decimals | 3.14159, 12345.6789 |\n| **long double** | 10-16 bytes | Extended range | 18-19 digits | Very high precision | 3.141592653589793238L |\n| **void** | N/A | No value | N/A | No return value | N/A |\n\n---\n\n## Choosing the Right Data Type\n\n### Decision Guide:\n\n1. **Need whole numbers?**\n   - Small range (-32K to 32K)?  `short`\n   - Normal range?  `int`\n   - Large numbers?  `long` or `long long`\n   - Only positive?  Add `unsigned`\n\n2. **Need decimal numbers?**\n   - Low precision OK?  `float`\n   - Need accuracy?  `double`\n   - Scientific calculations?  `double` or `long double`\n\n3. **Need characters?**\n   - Letters, symbols?  `char`\n   - Binary data?  `unsigned char`\n\n4. **Function returns nothing?**\n   - Use `void`\n\n---\n\n## User-Defined & Derived Data Types\n\nThese types are created using basic data types to organize and manage complex data more effectively.\n\n---\n\n### `Arrays` (Derived Type)\n\nAn array is a collection of variables of the **same data type** stored in **contiguous memory locations** (one after another).\n\n**Key Characteristics:**\n **Fixed Size**: Once defined, you cannot change the size of a standard array.\n **Index-Based**: Access elements using an index starting from **0** up to `size - 1`.\n **Homogeneous**: All elements must be of the same type (all `int`, all `float`, etc.).\n\n**Example Code:**\n```c\nint marks[5] = {90, 85, 70, 95, 80};\n\n// Accessing elements\nprintf(\"First mark: %d\", marks[0]); // 90\nprintf(\"Fourth mark: %d\", marks[3]); // 95\n```\n\n**Memory Layout:**\nIf `marks[0]` is at memory address `1000`, and `int` is 4 bytes:\n- `marks[0]`  `1000`\n- `marks[1]`  `1004`\n- `marks[2]`  `1008`\n\n**Pro Tip:**\nYou can calculate the number of elements using `sizeof`:\n`int count = sizeof(marks) / sizeof(marks[0]);`\n\n---\n\n### `Structures` (User-Defined Type)\n\nA structure (or `struct`) allows you to group variables of **different data types** together under a single name. It's essentially creating your own custom data type.\n\n**Use Case**: Storing records (e.g., a Student record with name, age, and grade).\n\n**Example Code:**\n```c\nstruct Student {\n    char name[50];\n    int age;\n    float marks;\n};\n\nstruct Student s1 = {\"Alice\", 20, 88.5};\n\n// Accessing members using the dot (.) operator\nprintf(\"Name: %s, Age: %d\", s1.name, s1.age);\n```\n\n**typedef Keyword:**\nYou can use `typedef` to give a shorter name to your structure:\n```c\ntypedef struct Student Student;\nStudent s2; // No need to write 'struct' anymore\n```\n\n---\n\n### `Unions` (User-Defined Type)\n\nA union is similar to a structure, but with a critical difference: **all members share the same memory location**. \n\n**Key Characteristics:**\n **Memory Efficiency**: Size of a union is the size of its **largest** member.\n **Single Value**: At any given time, a union can hold a value for only ONE of its members.\n\n**Example Code:**\n```c\nunion Data {\n    int i;\n    float f;\n    char str[20];\n};\n\nunion Data d;\nd.i = 10; \nprintf(\"Value: %d\", d.i); // Works\n\nd.f = 220.5;\nprintf(\"Value: %f\", d.f); // Works, but d.i is now corrupted!\n```\n\n---\n\n### `Pointers` (Derived Type)\n\nA pointer is a special variable that stores the **memory address** of another variable instead of a value.\n\n**Key Operators:**\n `&` (Address-of operator): Gets the memory address of a variable.\n `*` (Dereference operator): Gets the value stored at the address a pointer is holding.\n\n**Example Code:**\n```c\nint num = 10;\nint *ptr = &num; // ptr stores the address of num\n\nprintf(\"Address: %p\", ptr);   // Prints memory address\nprintf(\"Value: %d\", *ptr);    // Prints 10 (Dereferencing)\n```\n\n**Common Pitfalls:**\n- **NULL Pointers**: Always initialize pointers to `NULL` if you don't assign them an address immediately. `int *p = NULL;`\n- **Dangling Pointers**: Be careful not to point to memory that has been freed.\n\n---\n\n### `Enums` (User-Defined Type)\n\nAn Enumeration (or `enum`) is a user-defined type that consists of a set of **named integer constants**. It makes your code more readable and self-documenting.\n\n**Example Code:**\n```c\nenum Day { MON, TUE, WED, THU, FRI, SAT, SUN };\n// MON = 0, TUE = 1, etc. by default\n\nenum Day today = WED;\n\nif (today == WED) {\n    printf(\"It is Wednesday!\");\n}\n```\n\n**Custom Values:**\nYou can specify custom values for enum constants:\n```c\nenum Level { EASY = 1, MEDIUM = 5, HARD = 10 };\n```",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What is the standard size of a 'double' data type on most modern 64-bit C compilers?",
                        "options": [
                            "2 bytes",
                            "4 bytes",
                            "8 bytes",
                            "16 bytes"
                        ],
                        "correctAnswer": 2,
                        "explanation": "A 'double' (double precision floating point) typically occupies 8 bytes (64 bits) to provide high precision (15-17 significant digits)."
                    },
                    {
                        "id": 2,
                        "text": "If you are storing a value like 3.1415926535 and need exactly 15 digits of accuracy, which type should you use?",
                        "options": [
                            "int",
                            "float",
                            "double",
                            "long int"
                        ],
                        "correctAnswer": 2,
                        "explanation": "A 'float' only provides 6-7 digits of precision, whereas 'double' provides 15-17 digits, making it the correct choice for high-accuracy decimals."
                    },
                    {
                        "id": 3,
                        "text": "Which of these is true about how C stores a 'char' variable internally?",
                        "options": [
                            "It stores the actual graphical shape of the letter",
                            "It stores the character as a small integer (ASCII value)",
                            "It stores the character as a string of length 1",
                            "It stores characters in a encrypted format"
                        ],
                        "correctAnswer": 1,
                        "explanation": "In C, characters are internally handled as integers corresponding to their ASCII codes (e.g., 'A' is stored as 65)."
                    },
                    {
                        "id": 4,
                        "text": "What is the primary advantage of using 'unsigned int' instead of 'signed int' for a value like 'population'?",
                        "options": [
                            "It uses half the memory",
                            "It makes the program run faster",
                            "It doubles the positive range by not storing negative numbers",
                            "It allows storing decimal points"
                        ],
                        "correctAnswer": 2,
                        "explanation": "By removing the bit used for the negative sign, 'unsigned int' can store positive values up to ~4.29 billion, compared to ~2.14 billion for 'signed int'."
                    },
                    {
                        "id": 5,
                        "text": "In a 'union', if you define an 'int i' and a 'float f', what happens to the memory?",
                        "options": [
                            "Separate memory is allocated for both",
                            "Both members share the same memory location",
                            "Memory is only allocated for the 'int'",
                            "Unions do not use memory"
                        ],
                        "correctAnswer": 1,
                        "explanation": "A 'union' uses a single shared memory space for all its members. The size of the union is equal to its largest member."
                    }
                ]
            },
            {
                "id": "c5",
                "title": "Lesson 5: Input/Output",
                "duration": "25 mins",
                "content": "In C, input and output refer to how a program receives data and produces results. It is the bridge between the human user and the electronic processor.\n\n---\n\n## Displaying Output\n\n### `printf()` Function\n\n**What is printf?**\nIt is the primary function in C for sending data to the screen. It stands for \"print formatted\".\n\n **Library**: `<stdio.h>`\n\n **Formal Syntax**:\n```c\nprintf(\"Format String\", argument1, argument2, ...);\n```\n\n**Syntax Breakdown:**\n- **Format String**: The text to be printed, containing text and *format specifiers* (like `%d`).\n- **Arguments**: The variables or values that will replace the specifiers in the text.\n\n **Format Specifiers**: `%d` (int), `%f` (float), `%c` (char), `%s` (string)\n\n **Purpose**: To display text and variable values on the console\n\n**Example code:**\n```c\nint age = 25;\nprintf(\"I am %d years old\\n\", age);\n\nfloat pi = 3.14159;\nprintf(\"Value of Pi: %.2f\", pi); // %.2f rounds to 2 decimal places\n```\n\n---\n\n## Reading User Input\n\n### `scanf()` Function\n\n**What is scanf?**\nIt is the primary function for reading input from the keyboard. It stands for \"scan formatted\".\n\n **Library**: `<stdio.h>`\n\n **Formal Syntax**:\n```c\nscanf(\"Format Specifiers\", &variable1, &variable2, ...);\n```\n\n**Syntax Breakdown:**\n- **Format Specifiers**: Tells `scanf` what kind of data to look for (e.g., `%d` for integer).\n- **&variable**: Provide the *address* of the variables where you want to store the input.\n\n **The & Operator**: Crucial symbol that provides the *address* of the variable to the function\n\n **Purpose**: To take data from the user and store it in memory\n\n**How does scanf() work?**\n1. **Pause**: The program stops and waits for you to type something.\n2. **Buffer**: Your typing goes into a temporary pool (the buffer) until you hit **Enter**.\n3. **Parse**: `scanf` looks at its specifier (e.g., `%d`) and tries to find a matching value in the buffer.\n4. **Assign**: It stores that value directly into the memory address you provided.\n\n---\n\n## Technical Deep Dive: The `&` Symbol\n\nThink of a variable like a house. To put a package inside the house, a delivery driver needs the **Address**, not just the name. \n- `age` is the value inside the house (the tenant).\n- `&age` is the physical coordinate (the address).\n\n`scanf` is like the delivery driver; it requires the `&` operator to know exactly which memory slot to fill.\n\n---\n\n## Compiler Insight: The I/O Buffer\n\nWhen you use `printf` or `scanf`, C doesn't talk directly to the hardware every time. Instead, it uses a **Buffer**.\n\n- **Output Buffering**: Text is collected in a temporary space and sent to the screen all at once when a `\\n` is detected.\n- **Input Buffering**: When you type \"25\" and hit Enter, the \"2\", \"5\", and \"Enter\" are stored. `scanf` takes what it needs and leaves the rest.\n\n---\n\n## Complete Interactive Example\n\n```c\n#include <stdio.h>\n\nint main() {\n    char initial;\n    int age;\n\n    printf(\"Enter your initial: \");\n    scanf(\"%c\", &initial);\n\n    printf(\"Enter your age: \");\n    scanf(\"%d\", &age);\n\n    printf(\"\\n--- SUMMARY ---\\n\");\n    printf(\"User: %c\\n\", initial);\n    printf(\"Age: %d years\\n\", age);\n\n    return 0;\n}\n```\n\n### Expected Output\n```text\nEnter your initial: A\nEnter your age: 30\n\n--- SUMMARY ---\nUser: A\nAge: 30 years\n```\n\n---\n\n## Code Explanation\n\n1.  **`#include <stdio.h>`**: Includes the **Standard Input Output** library. This allows us to use functions like `printf` and `scanf`.\n2.  **`char initial; int age;`**: Declares two variables. `initial` stores a single character, and `age` stores a whole number.\n3.  **`scanf(\"%c\", &initial);`**: The `&` (address-of) operator is crucial. It tells `scanf` the exact memory location to \"drop\" the user's input.\n4.  **`scanf(\"%d\", &age);`**: Note that `%c` is for characters and `%d` is for integers.\n5.  **`printf(\"Summary...\");`**: Displays the final data. The placeholders are replaced by the actual values stored in the variables.\n6.  **`return 0;`**: Standard way to tell the Operating System that the program finished successfully.\n",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Which format specifier is used to display a floating-point number with exactly 2 decimal places in 'printf'?",
                        "options": [
                            "%f",
                            "%.2f",
                            "%2f",
                            "%d2"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Adding '.2' between the % and f (%.2f) tells C to round the floating-point value to exactly two decimal places for output."
                    },
                    {
                        "id": 2,
                        "text": "What is the technical reason for using the '&' (address) operator with variables in 'scanf'?",
                        "options": [
                            "To encrypt the data",
                            "To tell scanf the memory address where the value should be stored",
                            "To speed up the input process",
                            "To convert text into binary"
                        ],
                        "correctAnswer": 1,
                        "explanation": "'scanf' needs the memory address of the variable so it can directly overwrite that memory location with the user's input."
                    },
                    {
                        "id": 3,
                        "text": "Which library header file MUST be included to use 'printf' and 'scanf' functions?",
                        "options": [
                            "<conio.h>",
                            "<stdlib.h>",
                            "<stdio.h>",
                            "<string.h>"
                        ],
                        "correctAnswer": 2,
                        "explanation": "'stdio.h' stands for Standard Input/Output. It contains the declarations for basic I/O functions like 'printf' and 'scanf'."
                    },
                    {
                        "id": 4,
                        "text": "When reading a string into a character array 'char name[20]' using 'scanf(\"%s\", name)', why is the '&' symbol usually omitted?",
                        "options": [
                            "Because strings are not variables",
                            "Because the name of an array already acts as its base address",
                            "Because scanf cannot read strings",
                            "Because strings ignore memory rules"
                        ],
                        "correctAnswer": 1,
                        "explanation": "In C, the name of an array (without an index) is a pointer to its first element. Therefore, 'name' is already an address, and '&' is redundant."
                    },
                    {
                        "id": 5,
                        "text": "Which function is specifically designed to output only a SINGLE character to the screen?",
                        "options": [
                            "printf()",
                            "scanf()",
                            "putchar()",
                            "getchar()"
                        ],
                        "correctAnswer": 2,
                        "explanation": "'putchar()' is a dedicated function for displaying a single character. While 'printf(\"%c\", ...)' can also do this, 'putchar()' is more specialized and efficient."
                    }
                ]
            },
            {
                "id": "c6",
                "title": "Lesson 6: Operators",
                "duration": "35 mins",
                "content": "Operators are special symbols that perform operations on values and variables. They are the engines of logic in your C programs.\n\n---\n\n## Arithmetic Operators\n\nArithmetic operators form the mathematical foundation of C programming. Just like a standard calculator, C uses these symbols to perform fundamental operations such as addition, subtraction, multiplication, and division. \n\nThese operators work seamlessly on both integers (whole numbers) and floating-point numbers (decimals), allowing you to construct complex formulas for everything from simple counters to advanced physics simulations.\n\n### `+`, `-`, `*`, `/`, `%` \n\n| Operator | Purpose | Example |\n| :--- | :--- | :--- |\n| `+` | Addition | `10 + 5 = 15` |\n| `-` | Subtraction | `10 - 5 = 5` |\n| `*` | Multiplication | `4 * 3 = 12` |\n| `/` | Division | `10 / 4 = 2` (Integer) |\n| `%` | Modulo | `10 % 3 = 1` |\n\n### Example\n```c\nint a = 10, b = 3;\nprintf(\"Division: %d\\n\", a / b); // Output: 3\nprintf(\"Remainder: %d\\n\", a % b); // Output: 1\n```\n\n### Expected Output\n```text\nDivision: 3\nRemainder: 1\n```\n\n> [!TIP]\n> **Compiler Insight: The Integer Trap**\n> When dividing two integers in C, the result is *always* an integer. The decimal part is truncated (thrown away), not rounded. To get `2.5`, at least one number must be a `float`: `10.0 / 4` results in `2.5`.\n\n---\n\n## Relational Operators\n\nRelational operators are used to compare two values, essentially asking a question about their relationship (e.g., \"Is 5 greater than 3?\"). In C, these comparisons don't return \"True\" or \"False\" keywords; instead, they return integer values: **1** represents True, and **0** represents False. These are the decision-making tools for loops and if-statements.\n\n### `==`, `!=`, `>`, `<`, `>=`, `<=` \n\n| Operator | Meaning | True Example |\n| :--- | :--- | :--- |\n| `==` | Equal To | `5 == 5` |\n| `!=` | Not Equal To | `5 != 3` |\n| `>` | Greater Than | `10 > 7` |\n| `<` | Less Than | `3 < 8` |\n\n### Example\n```c\nint x = 5, y = 10;\nprintf(\"Is x equal to y? %d\", x == y); // Returns 0\n```\n\n### Expected Output\n```text\nIs x equal to y? 0\n```\n\n---\n\n## Logical Operators\n\nLogical operators allow you to combine multiple conditions into complex decision logic. They are essential for validating ranges (e.g., \"Is age between 18 AND 65?\") or checking multiple requirements (e.g., \"Has ticket OR is VIP\"). Like relational operators, they return 1 (True) or 0 (False).\n\n### `&&` (AND), `||` (OR), `!` (NOT) \n\n*   **`&&` (AND)**: Returns 1 only if **both** sides are true.\n*   **`||` (OR)**: Returns 1 if **at least one** side is true.\n*   **`!` (NOT)**: Reverses the state (True becomes False).\n\n### Example\n```c\nint age = 20, has_ticket = 1;\nif (age >= 18 && has_ticket) {\n    printf(\"Welcome to the show!\\n\");\n}\n```\n\n> [!WARNING]\n> **Short-Circuit Logic**\n> C is efficient! In `(A && B)`, if `A` is false, C **won't even check** `B` because the whole thing is already false. Similarly, in `(A || B)`, if `A` is true, C skips `B`.\n\n---\n\n## Increment & Decrement\n\nThese are unary operators (meaning they operate on a single variable) designed for convenience. They increase (`++`) or decrease (`--`) a variable's value by exactly 1. They are incredibly common in loops and counters. \n\nThe placement of the operator matters significantly: **Prefix** modifies the value *before* it's used, while **Postfix** uses the current value *before* modifying it.\n\n### `++` (Increment), `--` (Decrement)\n\n*   **Prefix (`++a`)**: Increment first, then use the value.\n*   **Postfix (`a++`)**: Use the value first, then increment.\n\n### Example\n```c\nint x = 5;\nprintf(\"%d \", ++x); // Prints 6, x is now 6\nprintf(\"%d\", x++);   // Prints 6, x is now 7\n```\n\n### Expected Output\n```text\n6 6\n```\n\n---\n\n## Assignment Operators\n\nAssignment operators are used to store or update values in variables. While the basic `=` is the most common, C offers \"Compound Assignment\" operators. These combine an arithmetic operation with assignment, making your code shorter and often easier to read (e.g., `x += 5` instead of `x = x + 5`).\n\n### `=`, `+=`, `-=`, `*=`, `/=`\n\n| Expression | Equivalent To |\n| :--- | :--- |\n| `x += 5` | `x = x + 5` |\n| `x *= 2` | `x = x * 2` |\n\n---\n\n## Precedence (The Rulebook)\n\nJust like in standard mathematics (BODMAS/PEMDAS), C follows a strict order of operations known as Operator Precedence. This hierarchy dictates which parts of an expression are evaluated first. For instance, multiplication `*` is always performed before addition `+`. Understanding this prevents unexpected results in complex formulas.\n\nWhen multiple operators are in one line, C follows a strict order:\n1.  **Parentheses** `()` - Highest Priority\n2.  **Arithmetic** `* / %` then `+ -`\n3.  **Relational** `< >` then `== !=`\n4.  **Logical** `&&` then `||` \n5.  **Assignment** `=` - Lowest Priority\n\n### Logic Master Example\n```c\n#include <stdio.h>\n\nint main() {\n    int a = 10, b = 20, c = 30;\n    int res = a + b * c > 500 && b != c;\n    // Steps: \n    // 1. b * c = 600\n    // 2. a + 600 = 610\n    // 3. 610 > 500 = 1 (True)\n    // 4. b != c = 1 (True)\n    // 5. 1 && 1 = 1\n    printf(\"Final Result: %d\", res);\n    return 0;\n}\n```\n\n### Expected Output\n```text\nFinal Result: 1\n```\n\n---\n\n## The 3 Types of Operators\n\nYou might encounter these terms in technical documentation. They simply categorize operators based on the number of \"operands\" (values or variables) they require to function.\n\n| Type | Operands Needed | Examples |\n| :--- | :---: | :--- |\n| **Unary** | 1 | `++`, `--`, `!`, `sizeof`, `(type)` |\n| **Binary** | 2 | `+`, `-`, `*`, `/`, `%`, `>`, `<` |\n| **Ternary** | 3 | `? :` (Conditional Operator) |\n\n---\n\n## Type Conversion & Casting\n\nIn C, you often need to mix different data types, such as adding an integer to a float. C has strict rules for how these types interact to ensure data integrity.\n\n### Implicit Conversion (Promotion)\nThis happens automatically when you mix smaller types with larger ones. C promotes the smaller value to the larger type to prevent data loss (e.g., `int` becomes `float`).\n\n### Explicit Conversion (Casting)\nSometimes you need to override C's automatic behavior. **Type Casting** allows you to manually force a value to be treated as a specific type, giving you full control over the operation.\n\n### Example\n```c\n#include <stdio.h>\n\nint main() {\n    int i = 10;\n    float f = 5.5;\n\n    // Implicit Conversion\n    // 'i' becomes 10.0, result is 15.5\n    float result = i + f; \n    printf(\"Implicit: %.1f\\n\", result);\n\n    // Explicit Casting\n    // (int)f converts 5.5 to 5 (truncates decimal)\n    int truncated = (int)f;\n    printf(\"Casted to int: %d\\n\", truncated);\n\n    // Common Use Case: Integer Division fix\n    int a = 5, b = 2;\n    float div = (float)a / b; // 2.5 (Correct)\n    // Without cast: 5/2 = 2 (Incorrect for precise math)\n    printf(\"Division: %.1f\", div);\n\n    return 0;\n}\n```\n\n### Expected Output\n```text\nImplicit: 15.5\nCasted to int: 5\nDivision: 2.5\n```\n\n### Code Explanation\n1.  `int i = 10; float f = 5.5;`: We create an integer and a floating-point number.\n2.  `float result = i + f;`: **Implicit Promotion**. C sees you adding an `int` `10` to a `float` `5.5`. To avoid losing the `.5`, C temporarily converts `10` to `10.0`. The result `15.5` is stored in a `float`.\n3.  `int truncated = (int)f;`: **Explicit Casting**. You are forcing the `float` `5.5` to become an `int`. C does this by chopping off the decimal part (`.5`), leaving `5`. This is useful when you want to round down or remove precision.\n4.  `float div = (float)a / b;`: **The Division Fix**. If we did `a / b` (which is `5 / 2`), C would do integer division and give `2`. By casting `a` to `(float)a`, it becomes `5.0`. Now `5.0 / 2` triggers implicit promotion for `2`, resulting in the correct `2.5`.\n\n---\n\n## The Ternary Operator (`?:`)\n\nThe Ternary Operator is a powerful, concise shorthand for simple `if-else` statements. It is unique in C because it is the only operator that takes **3 operands**. It allows you to make a decision and return a value in a single line of code, referencing the logic: \"If standard is met, do this; otherwise, do that.\"\n\n### Syntax\n`condition ? value_if_true : value_if_false`\n\n### Example\n```c\n#include <stdio.h>\n\nint main() {\n    int age = 20;\n    // If age >= 18, assign 1 (True). Else assign 0 (False).\n    int isAdult = (age >= 18) ? 1 : 0;\n\n    printf(\"Is Adult? %d\\n\", isAdult);\n\n    // Inline usage\n    int a = 100, b = 200;\n    int max = (a > b) ? a : b;\n    printf(\"Maximum is: %d\", max);\n    \n    return 0;\n}\n```\n\n### Expected Output\n```text\nIs Adult? 1\nMaximum is: 200\n```\n\n### Code Explanation\n1.  `int isAdult = (age >= 18) ? 1 : 0;`: The condition is `age >= 18` (which is 20 >= 18, so **True**). The operator picks the first value after the `?` (which is `1`) and assigns it to `isAdult`.\n2.  `int max = (a > b) ? a : b;`: The condition is `a > b` (100 > 200, so **False**). The operator skips the first value `a` and picks the second value after the `:` (which is `b`, so 200) and assigns it to `max`.\n\n---\n\n## The `sizeof` Operator\n\n`sizeof` is a compile-time Unary operator that is crucial for memory management. It tells you exactly how much memory (in bytes) a specific data type or variable occupies on your system. This is essential for writing portable code that works across different hardware architectures.\n\n### Example\n```c\n#include <stdio.h>\n\nint main() {\n    int myInt;\n    double myDouble;\n    \n    printf(\"Size of int: %lu bytes\\n\", sizeof(myInt));\n    printf(\"Size of double: %lu bytes\\n\", sizeof(myDouble));\n    printf(\"Size of explicit char: %lu byte\", sizeof(char));\n    return 0;\n}\n```\n\n*(Note: Output may vary by system, typically int is 4 bytes)*\n\n### Code Explanation\n1.  `sizeof(myInt)`: You are asking C, \"How many memory bytes does this integer perform?\" On most modern systems, the answer is **4 bytes**.\n2.  `sizeof(myDouble)`: Doubles need more precision, so they take up more space. The answer is usually **8 bytes**.\n3.  `sizeof(char)`: A `char` is the smallest storage unit for text, taking up exactly **1 byte**.\n\n---\n\n## Common Pitfall: The Equality Trap\n\nA very common bug is confusing Assignment (`=`) with Equality (`==`).\n\n### The Bug\n```c\nint x = 5;\nif (x = 10) {  // BUG! Assigns 10 to x. 10 is Non-Zero (True).\n    printf(\"x is 10\");\n}\n```\n*This code will ALWAYS print, and `x` will be changed to 10.*\n\n### The Fix\n```c\nint x = 5;\nif (x == 10) { // CORRECT. Checks if x is equal to 10.\n   printf(\"x is 10\");\n}\n```\n\n> [!TIP]\n> **Yoda Conditions**: Some new programmers write `if (10 == x)` so that if they accidentally write `if (10 = x)`, the compiler creates an error (you can't assign to 10).\n\n---\n\n## Code Lab: Leap Year Calculator\n\nLet's build a real tool! A year is a **Leap Year** if:\n1.  It is divisible by 4 **AND** not divisible by 100.\n2.  **OR** it is divisible by 400.\n\n```c\n#include <stdio.h>\n\nint main() {\n    int year = 2024;\n\n    // Detailed Logic\n    // (year % 4 == 0) -> Divisible by 4\n    // (year % 100 != 0) -> NOT divisible by 100\n    // (year % 400 == 0) -> Divisible by 400\n\n    if ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)) {\n        printf(\"%d is a Leap Year!\", year);\n    } else {\n        printf(\"%d is NOT a Leap Year.\", year);\n    }\n    return 0;\n}\n```\n\n### Expected Output\n```text\n2024 is a Leap Year!\n```\n\n---\n\n## Code Explanation\n\n1.  **`(year % 4 == 0 && year % 100 != 0)`**: This checks the primary rule. A year must be divisible by 4 (remainder is 0) AND not divisible by 100.\n2.  **`|| (year % 400 == 0)`**: This is the exception rule. If a year is divisible by 400, it is ALWAYS a leap year, even if it's a century year.\n3.  **if-else block**: The program evaluates the combined logical expression. If it results in 1 (True), the first block runs; otherwise, the `else` block runs.\n4.  **Modulo (%)**: Used to find the remainder. `year % 4 == 0` means there is no remainder when divided by 4.\n",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What is the result of `(5 > 3) ? 10 : 20`?",
                        "options": [
                            "20",
                            "10",
                            "5",
                            "Error"
                        ],
                        "correctAnswer": 1,
                        "explanation": "The condition (5 > 3) is True, so the ternary operator evaluates the first expression (before the colon), which is 10."
                    },
                    {
                        "id": 2,
                        "text": "What is the result of casting `(int)3.99`?",
                        "options": [
                            "4",
                            "3.99",
                            "3",
                            "0"
                        ],
                        "correctAnswer": 2,
                        "explanation": "Casting a float to an int truncates the decimal part completely. It does NOT round up. So 3.99 becomes 3."
                    },
                    {
                        "id": 3,
                        "text": "Which operator has the HIGHEST precedence among these?",
                        "options": [
                            "&&",
                            "+",
                            "==",
                            "*"
                        ],
                        "correctAnswer": 3,
                        "explanation": "Multiplication (*) happens before addition (+), comparison (==), and logical AND (&&)."
                    },
                    {
                        "id": 4,
                        "text": "In `(1 || x++)`, does `x` get incremented?",
                        "options": [
                            "Yes",
                            "No",
                            "Only if x is 0",
                            "Runtime Error"
                        ],
                        "correctAnswer": 1,
                        "explanation": "NO. This is short-circuiting. Since the left side `1` (True) is already true, C skips the right side `x++` entirely."
                    },
                    {
                        "id": 5,
                        "text": "What happens if you use `if(x = 10)` instead of `if(x == 10)` in C?",
                        "options": [
                            "It causes a compilation error",
                            "It assigns 10 to x and evaluates as True",
                            "It checks if x is equal to 10",
                            "It evaluates as False"
                        ],
                        "correctAnswer": 1,
                        "explanation": "This is a common bug. It performs an ASSIGNMENT, not a comparison. x becomes 10, which is non-zero (True)."
                    }
                ]
            }
        ],
        "problems": [
            {
                "id": "c-l1-p1",
                "title": "Hello GenSpark",
                "difficulty": "easy",
                "description": "Write a C program that prints 'Hello GenSpark' followed by a newline.",
                "starter_code": "#include <stdio.h>\n\nint main() {\n    // Your code here\n    printf(\"Hello GenSpark\\n\");\n    return 0;\n}",
                "test_cases": [
                    {
                        "stdin": "",
                        "expected_output": "Hello GenSpark\n"
                    }
                ]
            },
            {
                "id": "c-l1-p2",
                "title": "Sum of Two Numbers",
                "difficulty": "easy",
                "description": "Write a program that takes two integers as input and prints their sum.",
                "starter_code": "#include <stdio.h>\n\nint main() {\n    int a, b;\n    // Input two numbers using scanf\n    // Print the sum\n    return 0;\n}",
                "test_cases": [
                    {
                        "stdin": "10 20",
                        "expected_output": "30"
                    },
                    {
                        "stdin": "5 -3",
                        "expected_output": "2"
                    }
                ]
            },
            {
                "id": "c-l1-p3",
                "title": "Circle Area",
                "difficulty": "easy",
                "description": "Calculate the area of a circle given its radius. Use 3.14 for PI. Area = PI * r * r. Print result with 2 decimal places.",
                "starter_code": "#include <stdio.h>\n\nint main() {\n    float radius, area;\n    // Read radius\n    // Calculate and print area\n    return 0;\n}",
                "test_cases": [
                    {
                        "stdin": "5",
                        "expected_output": "78.50"
                    }
                ]
            },
            {
                "id": "c-l1-p4",
                "title": "Celsius to Fahrenheit",
                "difficulty": "easy",
                "description": "Convert temperature from Celsius to Fahrenheit. Formula: F = (C * 9/5) + 32. Print result with 2 decimal places.",
                "starter_code": "#include <stdio.h>\n\nint main() {\n    float celsius, fahrenheit;\n    // Read celsius\n    // Calculate and print fahrenheit\n    return 0;\n}",
                "test_cases": [
                    {
                        "stdin": "37",
                        "expected_output": "98.60"
                    }
                ]
            },
            {
                "id": "c-l1-p5",
                "title": "Print ASCII Value",
                "difficulty": "easy",
                "description": "Read a character from the user and print its ASCII value.",
                "starter_code": "#include <stdio.h>\n\nint main() {\n    char ch;\n    // Read character\n    // Print ASCII value\n    return 0;\n}",
                "test_cases": [
                    {
                        "stdin": "A",
                        "expected_output": "65"
                    }
                ]
            }
        ]
    },
    {
        "id": "c-l2",
        "title": "LEVEL 2: Flow Control",
        "lessons": [
            {
                "id": "c7",
                "title": "Lesson 7: if-else statements",
                "duration": "30 mins",
                "content": "Programs aren't just a linear list of instructions; they need to make decisions and react to different situations. Control flow is the spinal cord of programming, allowing your code to choose different paths based on logic and data.\n\n---\n\n## The `if` Statement\n\nThe `if` statement is the most fundamental decision-making tool. It evaluates a condition (a question that asks \"True or False?\"). If the answer is **True**, the code block behaves like a gate opening, allowing the instructions inside to run. If **False**, the gate stays closed, and the program skips over that block.\n\n### Syntax\n```c\nif (condition) {\n    // Code runs ONLY if condition is true\n}\n```\n\n### Example\n```c\nint score = 85;\nif (score >= 50) {\n    // This runs because 85 is greater than 50\n    printf(\"You Passed!\\n\");\n}\n```\n\n---\n\n## The `else` Clause\n\nThe `else` clause allows you to provide a \"Plan B\" or alternative path. It pairs with an `if` statement to handle the \"False\" case. Think of it as a fork in the road: you MUST go one way or the other. If the `if` condition is true, the first block runs. If it's false, the `else` block runs automatically.\n\n### Syntax\n```c\nif (condition) {\n    // Runs if True\n} else {\n    // Runs if False\n}\n```\n\n### Example\n```c\nint age = 16;\nif (age >= 18) {\n    printf(\"Adult\\n\");\n} else {\n    printf(\"Minor\\n\"); // Runs because 16 is NOT >= 18\n}\n```\n\n---\n\n## The `else if` Ladder\n\nWhat if you have more than two options? You can stack conditions using `else if`. This creates a ladder of logic. The computer checks them in order (top to bottom).\n*   It runs the **first** block where the condition is True.\n*   Once a match is found, it skips the rest of the ladder (it's mutually exclusive).\n*   The final `else` (optional) catches anything that didn't match above.\n\n### Example\n```c\nint temp = 25;\n\nif (temp > 30) {\n    printf(\"It's Hot\\n\");\n} else if (temp > 20) {\n    printf(\"It's Warm\\n\"); // 25 > 20, so this runs!\n} else {\n    printf(\"It's Cold\\n\"); // Skipped\n}\n```\n\n> [!IMPORTANT]\n> **Compiler Insight: The Truth About True**\n> In older C standards, there was no built-in Boolean type. From C99 onward, you can use #include <stdbool.h> and the bool type. However, C still treats **0 as False** and **any non-zero value (1, -5, 100) as True**.\n> `if (10) { ... }` will always run!\n\n---\n\n## Short-Circuit Logic\n\nWhen using logical operators `&&` (AND) and `||` (OR) inside `if` statements, C is lazy (efficient).\n- **`&&` (AND)**: If the first condition is False, C stops checking. Why? Because `False && Anything` is always False.\n- **`||` (OR)**: If the first condition is True, C stops checking. Why? Because `True || Anything` is always True.\n\n---\n\n## Nested If-Else\n\nYou can place an `if` statement **inside** another `if` statement. This is known as nesting. It allows you to check for \"prerequisite\" conditions. For example, you only check if a password is valid IF the username was found first.\n\n### Example: Login System\n```c\nint userValid = 1;\nint passwordValid = 0;\n\nif (userValid) {\n    // Outer 'if' passed\n    if (passwordValid) {\n        printf(\"Login Successful\");\n    } else {\n        printf(\"Wrong Password\");\n    }\n} else {\n    printf(\"User not found\");\n}\n```\n\n---\n\n## Common Pitfalls\n\n### The Dangling Else\nIn C, an `else` always belongs to the **nearest** preceding `if` that doesn't already have an `else`. Indentation doesn't matter to the compiler!\n\n```c\nif (a)\n    if (b)\n        printf(\"B\");\nelse\n    printf(\"A\"); // This 'else' pairs with 'if (b)', NOT 'if (a)'!\n```\n**Fix:** Always use braces `{}` to make your intent clear.\n\n### The Semicolon Trap\nPutting a semicolon `;` immediately after an `if` statement is a disaster. It tells C: \"If true, do nothing.\" The code block following it will then run *no matter what*.\n\n```c\nif (score > 100); {  // <-- BUG! The ';' ends the if statement.\n    printf(\"Invalid Score\"); // This always prints!\n}\n```\n\n---\n\n## Code Lab: Max of Three Numbers\n\nLet's use what we learned to find the largest of three numbers. This uses the `else if` ladder logic effectively.\n\n```c\n#include <stdio.h>\n\nint main() {\n    int a = 10, b = 25, c = 15;\n\n    // We check 'a' first\n    if (a >= b && a >= c) {\n        printf(\"%d is largest\", a);\n    } \n    // If 'a' wasn't the largest, we check 'b'\n    else if (b >= a && b >= c) {\n        printf(\"%d is largest\", b);\n    } \n    // If neither 'a' nor 'b' were largest, it MUST be 'c'\n    else {\n        printf(\"%d is largest\", c);\n    }\n    return 0;\n}\n```\n\n### Expected Output\n```text\n25 is largest\n```\n\n\n### Code Explanation\n1.  `int a = 10, b = 25, c = 15;`: We declare three integer variables with different values.\n2.  `if (a >= b && a >= c)`: **The First Check**. We ask: \"Is 'a' the king?\" This line checks if `a` is greater than or equal to BOTH `b` AND `c`. If true, `a` is the largest, and we are done.\n3.  `else if (b >= a && b >= c)`: **The Second Check**. If the first check failed (meaning `a` is NOT the largest), we move here. We ask: \"Is 'b' the king?\" We check if `b` is greater than or equal to the others.\n4.  `else`: **The Final Resort**. If `a` wasn't the largest, AND `b` wasn't the largest, logic dictates that `c` MUST be the largest. We don't even need to check a condition here!\n",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "In C, what does the following condition evaluate to: `if (-5)` ?",
                        "options": [
                            "True",
                            "False",
                            "Error",
                            "Undefined"
                        ],
                        "correctAnswer": 0,
                        "explanation": "In C, any non-zero value (including negative numbers) is treated as True. Only exactly 0 is False."
                    },
                    {
                        "id": 2,
                        "text": "What is the fatal flaw in this code? `if (x == 10); { printf(\"Hi\"); }`",
                        "options": [
                            "Missing quotes",
                            "Semicolon after 'if' kills the logic",
                            "Invalid comparison",
                            "Nothing is wrong"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Putting a semicolon immediately after `if(...)` creates an empty statement. The code inside `{}` becomes a separate block that runs every time, ignoring the condition."
                    },
                    {
                        "id": 3,
                        "text": "To which 'if' does an 'else' belong in nested structures?",
                        "options": [
                            "The first 'if' in the block",
                            "The nearest preceding 'if' without an 'else'",
                            "The 'if' with the same indentation",
                            "To all 'if' statements"
                        ],
                        "correctAnswer": 1,
                        "explanation": "This is the 'Dangling Else' rule: an else always pairs with the nearest unmatched if, regardless of indentation."
                    },
                    {
                        "id": 4,
                        "text": "What is the output of the Nested If example if `userValid=1` but `passwordValid=0`?",
                        "options": [
                            "Login Successful",
                            "User not found",
                            "Wrong Password",
                            "No output"
                        ],
                        "correctAnswer": 2,
                        "explanation": "The outer if (userValid) is true, entering the block. The inner if (passwordValid) is false, so it goes to the inner else: 'Wrong Password'."
                    },
                    {
                        "id": 5,
                        "text": "What happens if you omit braces `{}` but have two lines of code under an `if`?",
                        "options": [
                            "Both lines run only if true",
                            "Only the first line depends on the if, the second runs always",
                            "Compiler Error",
                            "Both lines form a block automatically"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Without braces, an `if` statement only controls the immediate next statement. The specific second line is outside the `if` and runs regardless of the condition."
                    }
                ]
            },
            {
                "id": "c8",
                "title": "Lesson 8: switch Statement",
                "duration": "25 mins",
                "content": "The `switch` statement is a specialized control structure used for multi-way decision making. While `if-else if` ladders are great for ranges (like grades or temperatures), `switch` is designed for selecting one option from a fixed list of discrete values, like a menu system or a vending machine.\n\n---\n\n## Syntax Breakdown\n\nThe structure is clean and organized. It tests a single variable against multiple \"cases\".\n\n```c\nswitch (expression) {\n    case constant1:\n        // Code runs if expression == constant1\n        break; // Stops execution!\n    case constant2:\n        // Code runs if expression == constant2\n        break;\n    default:\n        // Code runs if no cases match (Automatic \"else\")\n}\n```\n\n### Key Components:\n1.  **Expression**: The variable you are testing (e.g., `choice`).\n2.  **Case**: A specific value to check against (e.g., `case 1:`, `case 'A':`).\n3.  **Break**: Crucial! It tells C to jump out of the switch block. Without it, the code \"falls through\".\n4.  **Default**: Optional but recommended. It handles unexpected values.\n\n---\n\n## The Rules of Switch\n\nUnlike `if` statements, `switch` has strict rules:\n*   **Integers & Chars Only**: The expression MUST result in an integer or character. You **cannot** switch on `float`, `double`, or strings.\n*   **Constant Cases**: Case labels must be fixed values (like `5` or `'x'`). You cannot use variables like `case x:` or conditions like `case > 10:`.\n*   **Unique Cases**: You cannot have two cases with the same value.\n\n---\n\n## The \"Fall-Through\" Behavior\n\nOne of C's most famous (and dangerous) features is **Fall-Through**. If you omit the `break` statement, C doesn't stop. It blindly executes the code for the *next* case as well, until it hits a break or the end of the switch.\n\n### Example: Fall-Through\n```c\nint x = 1;\nswitch(x) {\n    case 1: printf(\"One \"); // No break!\n    case 2: printf(\"Two \");\n    case 3: printf(\"Three \");\n}\n```\n**Output**: `One Two Three `\n*(Because it started at 1 and just kept going!)*\n\n> [!TIP]\n> **When is this useful?**\n> You can stack cases to handle multiple values with the same code:\n> ```c\n> case 'a':\n> case 'e':\n> case 'i':\n>     printf(\"It is a vowel\");\n>     break;\n> ```\n\n---\n\n## Common Pitfalls\n\n### Comparison in Case\nYou cannot write `case > 10:`. Switch checks for **Equality Only**.\n\n### Duplicate Cases\n```c\ncase 5: ...\ncase 1+4: ... // Error! 1+4 is also 5. Duplicate case.\n```\n\n> [!IMPORTANT]\n> **Compiler Insight: Jump Tables vs. Ladders**\n> When you have a switch statement with many cases, the compiler doesn't just check them one by one like an if-else ladder. Instead, it often creates a **Jump Table**. This is like an index in a book—the CPU can jump directly to the correct case in a single step (O(1) time), making it much faster than checking 20 different `if` conditions individually.\n\n---\n\n## Code Lab: Simple Calculator\n\nLet's build a mini-calculator that takes an operator and two numbers. This is the perfect use case for `switch`.\n\n```c\n#include <stdio.h>\n\nint main() {\n    char operator;\n    double n1, n2;\n\n    operator = '+'; // Hardcoded for demo, usually user input\n    n1 = 10.0;\n    n2 = 5.0;\n\n    switch (operator) {\n        case '+':\n            printf(\"%.1lf + %.1lf = %.1lf\", n1, n2, n1 + n2);\n            break;\n        case '-':\n            printf(\"%.1lf - %.1lf = %.1lf\", n1, n2, n1 - n2);\n            break;\n        case '*':\n            printf(\"%.1lf * %.1lf = %.1lf\", n1, n2, n1 * n2);\n            break;\n        case '/':\n            printf(\"%.1lf / %.1lf = %.1lf\", n1, n2, n1 / n2);\n            break;\n        default:\n            printf(\"Error! Operator is not correct\");\n    }\n\n    return 0;\n}\n```\n\n### Expected Output\n```text\n10.0 + 5.0 = 15.0\n```\n\n### Code Explanation\n1.  **The Inputs**: We have an operator `+` and two numbers `10.0` and `5.0`.\n2.  **The Switch**: We check the `operator` variable.\n3.  **Matching**: C looks for a match. It finds `case '+':`.\n4.  **Execution**: It runs the `printf` statement for addition.\n5.  **The Break**: It hits `break;` and immediately exits the switch block, ignoring the subtraction, multiplication, and division cases.\n",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What happens if you forget the `break` statement in a case?",
                        "options": [
                            "Compiler Error",
                            "The program crashes",
                            "It executes the next case's code automatically (Fall-through)",
                            "It restarts the switch"
                        ],
                        "correctAnswer": 2,
                        "explanation": "This is known as 'fall-through'. Execution continues into the subsequent cases until a break is found or the switch ends."
                    },
                    {
                        "id": 2,
                        "text": "Which data type is INVALID for a switch expression?",
                        "options": [
                            "int",
                            "char",
                            "float",
                            "long"
                        ],
                        "correctAnswer": 2,
                        "explanation": "Switch statements require integral types (integers, chars, enums). Floating-point numbers (float, double) are not allowed."
                    },
                    {
                        "id": 3,
                        "text": "When does the `default` case execute?",
                        "options": [
                            "Always",
                            "Only if no other case matches",
                            "Only if checks for NULL",
                            "Before any other case"
                        ],
                        "correctAnswer": 1,
                        "explanation": "The default execution path is taken only when none of the specified cases match the expression."
                    },
                    {
                        "id": 4,
                        "text": "Can you check ranges in a standard C switch case (e.g., `case 1..5:`)?",
                        "options": [
                            "Yes, using two dots",
                            "No, standard C only supports single constant values",
                            "Yes, using a dash",
                            "Yes, using the 'range' keyword"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Standard ANSI C does NOT support ranges. Some compilers (like GCC) have extensions for it, but standard C requires distinct cases: `case 1: case 2: ...`."
                    },
                    {
                        "id": 5,
                        "text": "Is this valid? `case x:` (where x is a variable)",
                        "options": [
                            "Yes",
                            "No, case labels must be constants",
                            "Yes, if x is const",
                            "Yes, if x is global"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Case labels must be Compile-Time Constants (like `5` or `'A'`). You cannot use variables that change at runtime."
                    }
                ]
            },
            {
                "id": "c9",
                "title": "Lesson 9: for Loop",
                "duration": "30 mins",
                "content": "The `for` loop is the workhorse of C iteration. It is specifically designed for scenarios where you know **exactly how many times** you want to repeat a block of code. It packages the initialization, condition, and update logic into a single, concise line.\n\n---\n\n## Syntax Breakdown\n\n```c\nfor (initialization; condition; update) {\n    // Body of the loop\n}\n```\n\n### The Three Pillars:\n1.  **Initialization** (`int i = 0`): Runs **once** at the very start. It sets up your counter variable.\n2.  **Condition** (`i < 5`): Checked **before** every single iteration. If true, the loop body runs. If false, the loop dies immediately.\n3.  **Update** (`i++`): Runs **after** the loop body execution. It updates your counter to prepare for the next check.\n\n---\n\n## The Loop Lifecycle\n\nLet's trace `for (int i = 0; i < 3; i++)`:\n\n1.  **Start**: `i` becomes 0.\n2.  **Check**: Is `0 < 3`? Yes. Run body.\n3.  **Update**: `i` becomes 1.\n4.  **Check**: Is `1 < 3`? Yes. Run body.\n5.  **Update**: `i` becomes 2.\n6.  **Check**: Is `2 < 3`? Yes. Run body.\n7.  **Update**: `i` becomes 3.\n8.  **Check**: Is `3 < 3`? **No**. Stop!\n\n---\n\n## Advanced Features\n\n### Infinite Loops\nIf you leave the parts empty, they default to \"True\". This creates a loop that runs forever.\n```c\nfor (;;) {\n    printf(\"Forever...\\n\");\n    // You usually need a 'break' inside to stop this\n}\n```\n\n### Multiple Variables\nYou can initialize and update multiple variables at once using the comma operator.\n```c\nfor (int i = 0, j = 10; i < j; i++, j--) {\n    printf(\"%d %d\\n\", i, j);\n}\n// Output: 0 10, 1 9, 2 8... until they meet\n```\n\n---\n\n## Common Pitfalls\n\n### The Semicolon Trap (Again!)\nJust like with `if`, putting a semicolon after `for(...)` isolates the loop. It will run the *empty* statement N times, and then run your block once.\n```c\nfor (int i = 0; i < 5; i++); // <-- BUG!\n{\n    printf(\"Hi\"); // Prints \"Hi\" only once, after i reaches 5.\n}\n```\n\n### Off-By-One Errors\nConfusing `<` with `<=`.\n-   `for (i=0; i < 5; i++)` runs **5 times** (0,1,2,3,4).\n-   `for (i=0; i <= 5; i++)` runs **6 times** (0,1,2,3,4,5).\n\n---\n\n## Code Lab: Factorial Calculator\n\nThe \"Hello World\" of loops is calculating a factorial (e.g., 5! = 5 * 4 * 3 * 2 * 1).\n\n```c\n#include <stdio.h>\n\nint main() {\n    int n = 5;\n    long long factorial = 1;\n\n    // Loop from 1 up to n\n    for (int i = 1; i <= n; i++) {\n        factorial *= i; // Same as: factorial = factorial * i;\n    }\n\n    printf(\"Factorial of %d is %lld\", n, factorial);\n    return 0;\n}\n```\n\n### Expected Output\n```text\nFactorial of 5 is 120\n```\n\n### Code Explanation\n1.  **Setup**: We declare `factorial` as `long long` because factorials grow HUGE very quickly. We start it at `1` (starting at 0 would kill the multiplication).\n2.  **The Loop**: `for (int i = 1; i <= n; i++)`. It starts `i` at 1 and keeps going until `i` is greater than 5.\n3.  **Iteration 1**: `factorial` (1) * `i` (1) = 1.\n4.  **Iteration 2**: `factorial` (1) * `i` (2) = 2.\n5.  **Iteration 3**: `factorial` (2) * `i` (3) = 6.\n6.  **Iteration 4**: `factorial` (6) * `i` (4) = 24.\n7.  **Iteration 5**: `factorial` (24) * `i` (5) = 120.\n8.  **Stop**: Loop ends because `i` becomes 6.\n",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "In `for(A; B; C)`, when does 'C' (the update) execute?",
                        "options": [
                            "At the start of the loop",
                            "Before the condition check",
                            "After the loop body executes",
                            "Whenever the variable changes"
                        ],
                        "correctAnswer": 2,
                        "explanation": "The update step (like `i++`) always happens at the very end of an iteration, after the code block has run but before the next condition check."
                    },
                    {
                        "id": 2,
                        "text": "How do you write an infinite loop using `for`?",
                        "options": [
                            "for(1)",
                            "for(;;)",
                            "for(true)",
                            "for(infinite)"
                        ],
                        "correctAnswer": 1,
                        "explanation": "The syntax `for(;;)` leaves all three parts empty. The condition defaults to true, creating an infinite loop."
                    },
                    {
                        "id": 3,
                        "text": "What is the output of `for(int i=0; i<3; i++); printf(\"%d\", i);`?",
                        "options": [
                            "012",
                            "0 1 2",
                            "3",
                            "Compiler Data"
                        ],
                        "correctAnswer": 2,
                        "explanation": "The semicolon after the `for` makes the loop empty. It increments `i` until 3, then stops. The `printf` runs once with `i` as 3."
                    },
                    {
                        "id": 4,
                        "text": "If `i` is declared inside `for(int i=0;...)`, can you use `i` outside the loop in C99+?",
                        "options": [
                            "Yes, it persists",
                            "No, it is out of scope",
                            "Only if it was static",
                            "Yes, but it resets to 0"
                        ],
                        "correctAnswer": 1,
                        "explanation": "In standard C99 and later, a variable declared in the `for` initialization is limited to the scope of that loop block."
                    },
                    {
                        "id": 5,
                        "text": "Which loop is correct to run exactly 10 times (0 to 9)?",
                        "options": [
                            "for(i=0; i<=10; i++)",
                            "for(i=1; i<10; i++)",
                            "for(i=0; i<10; i++)",
                            "for(i=0; i!=9; i++)"
                        ],
                        "correctAnswer": 2,
                        "explanation": "`i=0; i<10` runs for 0, 1, ..., 9. That is exactly 10 iterations."
                    }
                ]
            },
            {
                "id": "c10",
                "title": "Lesson 10: while Loop",
                "duration": "25 mins",
                "content": "The `while` loop is the simplest looping structure in C. It repeats a block of code as long as a specific condition remains **True**. Unlike the `for` loop, which is built for fixed counts, `while` is perfect for scenarios where you don't know in advance how many times you need to loop (e.g., \"keep reading user input until they type 'exit'\").\n\n---\n\n## Syntax Breakdown\n\n```c\nwhile (condition) {\n    // Code to run\n    // UPDATE step usually happens here\n}\n```\n\n### The Flow:\n1.  **Check**: C checks the `condition` first.\n2.  **Execute**: If True, the code inside the braces runs.\n3.  **Repeat**: C goes back to step 1.\n4.  **Exit**: If False, the loop terminates immediately.\n\n> [!NOTE]\n> **Pre-Test Loop**: Because the condition is checked *before* the body runs, it is possible for a `while` loop to run **zero times** if the condition is false from the start.\n\n---\n\n## While vs For\n\n| Feature | `for` Loop | `while` Loop |\n| :--- | :--- | :--- |\n| **Best For** | Known number of iterations (e.g., \"Run 10 times\") | Unknown iterations (e.g., \"Run until file ends\") |\n| **Structure** | Compact (Init, Condition, Update in one line) | Loose (Update is inside the body) |\n| **Readability** | High for counting | High for logic states |\n\n---\n\n## Common Pitfalls\n\n### The Infinite Loop\nSince the \"Update\" step isn't forced into the syntax like in a `for` loop, it is VERY common to forget it.\n\n```c\nint i = 0;\nwhile (i < 5) {\n    printf(\"%d\", i);\n    // Forgot i++!\n    // Result: Prints \"00000...\" forever.\n}\n```\n\n### Off-By-One\nBe careful with your condition.\n*   `while (i < 10)` runs until `i` is 10 (stops at 10).\n*   `while (i <= 10)` runs UNTIL `i` is 11 (runs FOR 10).\n\n---\n\n## Code Lab: Digit Counter\n\nLet's write a program that counts how many digits are in a number (e.g., `12345` has 5 digits). We do this by repeatedly dividing the number by 10 until it becomes 0.\n\n```c\n#include <stdio.h>\n\nint main() {\n    long long n = 12345;\n    int count = 0;\n\n    printf(\"Number: %lld\\n\", n);\n\n    // Handle 0 case explicity if needed, though loop works for n > 0\n    if (n == 0) count = 1;\n\n    // The Logic: Chop off last digit, count it, repeat.\n    while (n != 0) {\n        n = n / 10; // Removes the last digit (integer division)\n        count++;    // Count satisfied\n    }\n\n    printf(\"Digit Count: %d\", count);\n    return 0;\n}\n```\n\n### Expected Output\n```text\nNumber: 12345\nDigit Count: 5\n```\n\n### Code Explanation\n1.  **Start**: `n` is 12345. `count` is 0.\n2.  **Pass 1**: `12345 != 0`. Divide by 10 -> `1234`. Increment count -> `1`.\n3.  **Pass 2**: `1234 != 0`. Divide by 10 -> `123`. Increment count -> `2`.\n4.  **...**: This continues until `n` becomes `0` (after 5 divisions).\n5.  **Stop**: `0 != 0` is False. Loop ends. We print the count.\n",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What is the minimum number of times a `while` loop can execute?",
                        "options": [
                            "One time",
                            "Infinity",
                            "Zero times",
                            "Depends on the variable"
                        ],
                        "correctAnswer": 2,
                        "explanation": "If the condition is false initially, the while loop will skip the body entirely and run 0 times."
                    },
                    {
                        "id": 2,
                        "text": "What is the most common cause of an infinite `while` loop?",
                        "options": [
                            "Using a negative number",
                            "Forgetting to update the loop variable",
                            "Using too many brackets",
                            "Variable overflow"
                        ],
                        "correctAnswer": 1,
                        "explanation": "If the variable used in the condition never changes (e.g., you forget `i++`), the condition remains true forever."
                    },
                    {
                        "id": 3,
                        "text": "When is the condition checked in a `while` loop?",
                        "options": [
                            "After the body runs",
                            "Before the body runs",
                            "In the middle of the body",
                            "Never"
                        ],
                        "correctAnswer": 1,
                        "explanation": "`while` is a pre-test loop. It evaluates the condition BEFORE entering the code block."
                    },
                    {
                        "id": 4,
                        "text": "What happens if you run `while(0) { printf(\"Hi\"); }`?",
                        "options": [
                            "It prints 'Hi' once",
                            "It prints 'Hi' forever",
                            "It prints nothing",
                            "Compiler error"
                        ],
                        "correctAnswer": 2,
                        "explanation": "In C, 0 means False. The condition is false from the start, so the body is skipped entirely."
                    },
                    {
                        "id": 5,
                        "text": "Which loop is better when you DO NOT know how many iterations you need?",
                        "options": [
                            "for loop",
                            "while loop",
                            "if statement",
                            "switch statement"
                        ],
                        "correctAnswer": 1,
                        "explanation": "`while` loops are semantically designed for state-based or unknown-count iteration (e.g., reading a file until EOF)."
                    }
                ]
            },
            {
                "id": "c11",
                "title": "Lesson 11: do-while Loop",
                "duration": "25 mins",
                "content": "The `do-while` loop is the final member of the C loop trio. It is unique because it is an **exit-controlled loop**. While the `for` and `while` loops check their conditions *before* running anything, the `do-while` loop executes its body first and checks the condition *after*.\n\n---\n\n## Syntax Breakdown\n\nThe syntax is slightly different from other loops, most notably because it **requires a semicolon** at the very end.\n\n```c\ndo {\n    // Body of the loop (Runs at least once!)\n    // Update step usually happens here\n} while (condition); // CRITICAL: Semicolon required here!\n```\n\n### The Flow:\n1.  **Execute**: C runs the code inside the `do` block immediately.\n2.  **Check**: After the body runs, C evaluates the `condition`.\n3.  **Repeat**: If True, it goes back to step 1.\n4.  **Exit**: If False, the loop ends.\n\n> [!IMPORTANT]\n> **The One-Time Guarantee**: Because the body runs *before* the check, a `do-while` loop will ALWAYS execute its code at least **once**, even if the condition is false from the start.\n\n---\n\n## While vs Do-While\n\n| Feature | `while` Loop | `do-while` Loop |\n| :--- | :--- | :--- |\n| **Check Time** | Pre-test (Before body) | Post-test (After body) |\n| **Min. Iterations** | 0 times | 1 time |\n| **Semicolon** | Not at the end | **Required** at the end |\n| **Best For** | Counting or general logic | Menus or Input Validation |\n\n---\n\n## Common Pitfalls\n\n### The Missing Semicolon\nThis is the only loop structure in C that ends with a semicolon. Forgetting it is a common syntax error.\n\n```c\ndo {\n    printf(\"Hi\");\n} while (x < 5) // <-- BUG! Missing ;\n```\n\n### Infinite Entry\nBe careful if your condition depends on something that only happens *after* the first pass.\n\n---\n\n## Code Lab: Positive Number Validator\n\nA perfect use for `do-while` is asking a user for data and forcing them to retry if they enter something invalid. Since you have to ask *at least once*, the logic fits `do-while` perfectly.\n\n```c\n#include <stdio.h>\n\nint main() {\n    int number;\n\n    // We want a positive number from the user\n    do {\n        printf(\"Enter a positive number: \");\n        // Imagine user enters -5, then 0, then 10\n        number = 10; // For demo purposes, hardcoding valid input\n        \n        if (number <= 0) {\n            printf(\"Invalid! Try again.\\n\");\n        }\n    } while (number <= 0);\n\n    printf(\"Thank you! You entered %d\", number);\n    return 0;\n}\n```\n\n### Expected Output\n```text\nEnter a positive number: 10\nThank you! You entered 10\n```\n\n### Code Explanation\n1.  **The Goal**: We need a number greater than 0.\n2.  **The First Pass**: C enters the loop automatically and asks for the number.\n3.  **The Check**: If the user entered something `<= 0`, the condition `while(number <= 0)` is True, so it loops back to ask again.\n4.  **The Exit**: Once a positive number is entered, the condition becomes False, and the loop releases the user.\n",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What is the key difference between 'while' and 'do-while'?",
                        "options": [
                            "while runs at least once",
                            "do-while runs at least once",
                            "There is no difference",
                            "while is only for integers"
                        ],
                        "correctAnswer": 1,
                        "explanation": "A do-while loop is an exit-controlled loop, meaning it executes the body first and then checks the condition, guaranteeing at least one run."
                    },
                    {
                        "id": 2,
                        "text": "What character is mandatory after the condition in a `do-while` loop?",
                        "options": [
                            "A bracket }",
                            "A colon :",
                            "A semicolon ;",
                            "Nothing"
                        ],
                        "correctAnswer": 2,
                        "explanation": "Standard C requires a semicolon after the `while(condition)` in a `do-while` statement."
                    },
                    {
                        "id": 3,
                        "text": "When is the condition in a `do-while` loop evaluated?",
                        "options": [
                            "Before the body starts",
                            "After each execution of the body",
                            "Only at the very end of the program",
                            "In every other iteration"
                        ],
                        "correctAnswer": 1,
                        "explanation": "It is a post-test loop, so the condition is checked AFTER the code inside the braces has finished executing."
                    },
                    {
                        "id": 4,
                        "text": "What is the output of `int i=5; do { printf(\"Hi\"); } while(i<5);`?",
                        "options": [
                            "No output",
                            "Hi",
                            "Hi Hi",
                            "Infinite HIs"
                        ],
                        "correctAnswer": 1,
                        "explanation": "The loop runs once first, prints 'Hi', then checks if 5 < 5. Since 5 < 5 is false, it stops. 'Hi' is printed exactly once."
                    },
                    {
                        "id": 5,
                        "text": "Which scenario is a `do-while` loop best suited for?",
                        "options": [
                            "Reading a file from start to finish",
                            "Iterating over an array of fixed size",
                            "Displaying a menu and getting user choice",
                            "Infinite background task"
                        ],
                        "correctAnswer": 2,
                        "explanation": "Menus and input validation are classic use cases because you always want to show the menu or ask for input at least once before checking the user's response."
                    }
                ]
            },
            {
                "id": "c12",
                "title": "Lesson 12: break and continue",
                "duration": "25 mins",
                "content": "While loops usually run until their condition becomes false, sometimes you need more surgical control. C provides two powerful keywords to disrupt the normal flow of a loop: `break` and `continue`.\n\n---\n\n## The break Statement: The Emergency Exit\n\nThe `break` statement immediately **terminates** the loop it is inside. It doesn't matter if the loop condition is still true; `break` forces the program to jump completely out of the loop block.\n\n### Analogy: The Ejection Seat\nImagine a pilot flying a mission (the loop). If the engine fails (a specific condition), they pull the eject lever (`break`). They don't finish the mission; they leave the plane immediately.\n\n### Example\n```c\nfor (int i = 1; i <= 10; i++) {\n    if (i == 5) break; \n    printf(\"%d \", i);\n}\n// Output: 1 2 3 4\n// (When i becomes 5, it breaks and stops everything)\n```\n\n---\n\n## The continue Statement: The Skip Button\n\nThe `continue` statement skips the **rest of the current iteration** and jumps directly to the next condition check (or the increment in a `for` loop). It doesn't end the loop; it just \"skips a turn\".\n\n### Analogy: The Skip Turn Card\nIn a game of Uno, a \"Skip\" card doesn't end the game. It just means the current player doesn't get to play their turn, and the game moves to the next person.\n\n### Example\n```c\nfor (int i = 1; i <= 5; i++) {\n    if (i == 3) continue; \n    printf(\"%d \", i);\n}\n// Output: 1 2 4 5\n// (When i is 3, printf is skipped, but it continues with 4)\n```\n\n---\n\n## Scope and Nesting\n\nA critical rule to remember: `break` and `continue` only affect the **innermost** loop they are in. If you have a loop inside a loop, breaking the inner one will **not** stop the outer one.\n\n---\n\n## Code Lab: Prime Number Checker\n\nA prime number is only divisible by 1 and itself. We can check if a number is prime by trying to divide it by every number from 2 up to its half. If we find even **one** divisor, we know it's not prime, and we can `break` early!\n\n```c\n#include <stdio.h>\n\nint main() {\n    int n = 29; // Number to check\n    int isPrime = 1; // Assume it's prime initially\n\n    for (int i = 2; i <= n / 2; i++) {\n        if (n % i == 0) {\n            isPrime = 0; // Found a factor!\n            break;       // No need to keep checking!\n        }\n    }\n\n    if (isPrime) printf(\"%d is Prime\", n);\n    else printf(\"%d is not Prime\", n);\n\n    return 0;\n}\n```\n\n### Expected Output\n```text\n29 is Prime\n```\n\n### Code Explanation\n1.  **The Strategy**: We check numbers from 2 to `n/2`.\n2.  **The Test**: `if (n % i == 0)` checks if the number is divisible.\n3.  **The Break**: As soon as we find a factor (like 2 dividing 10), we set `isPrime = 0`. There is no reason to check 3, 4, or 5, so we pull the `break` lever to save time.\n4.  **The Result**: If the loop finished without ever hitting `break`, `isPrime` stays 1.\n",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What is the primary difference between `break` and `continue`?",
                        "options": [
                            "break skips one turn, continue ends loop",
                            "break ends the loop, continue skips only the current iteration",
                            "There is no difference in loops",
                            "break is for 'if', continue is for 'switch'"
                        ],
                        "correctAnswer": 1,
                        "explanation": "break exits the loop entirely, while continue only skips the remaining code in the current pass and moves to the next iteration."
                    },
                    {
                        "id": 2,
                        "text": "In a nested loop (loop inside a loop), what does a `break` statement affect?",
                        "options": [
                            "All loops in the program",
                            "Only the innermost loop it is inside",
                            "Only the outermost loop",
                            "It causes a compiler error"
                        ],
                        "correctAnswer": 1,
                        "explanation": "In C, break and continue only apply to the immediate (innermost) loop structure containing them."
                    },
                    {
                        "id": 3,
                        "text": "Where is `break` used outside of loops?",
                        "options": [
                            "In 'if' statements",
                            "In 'switch' statements",
                            "In 'printf' statements",
                            "In variable declarations"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Break is mandatory in switch-case blocks to prevent 'fall-through' execution into the next cases."
                    },
                    {
                        "id": 4,
                        "text": "What happens in a `for` loop after a `continue` executes?",
                        "options": [
                            "The program crashes",
                            "It jumps immediately to the increment statement (e.g., i++)",
                            "It jumps back to initialization",
                            "It skips the next 5 lines"
                        ],
                        "correctAnswer": 1,
                        "explanation": "In a for loop, continue jumps to the increment step, then checks the condition again."
                    },
                    {
                        "id": 5,
                        "text": "In the Prime Checker example, why do we use `break`?",
                        "options": [
                            "To make the code look better",
                            "To avoid unnecessary calculations once a factor is found",
                            "Because C requires it in for loops",
                            "To print the result"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Once we prove a number is NOT prime (by finding a divisor), there is no point in checking more numbers. Breaking saves processing power."
                    }
                ]
            }
        ],
        "problems": [
            {
                "id": "c-l2-p1",
                "title": "Even or Odd",
                "difficulty": "easy",
                "description": "Write a C program that takes an integer and prints 'Even' if it is even and 'Odd' otherwise.",
                "starter_code": "#include <stdio.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    if (n % 2 == 0) printf(\"Even\"); else printf(\"Odd\");\n    return 0;\n}",
                "test_cases": [
                    {
                        "stdin": "4",
                        "expected_output": "Even"
                    },
                    {
                        "stdin": "7",
                        "expected_output": "Odd"
                    }
                ]
            },
            {
                "id": "c-l2-p2",
                "title": "Largest of Three",
                "difficulty": "easy",
                "description": "Take three integers as input and print the largest among them.",
                "starter_code": "#include <stdio.h>\n\nint main() {\n    int a, b, c;\n    scanf(\"%d %d %d\", &a, &b, &c);\n    // Logic here\n    return 0;\n}",
                "test_cases": [
                    {
                        "stdin": "10 25 15",
                        "expected_output": "25"
                    }
                ]
            },
            {
                "id": "c-l2-p3",
                "title": "Factorial",
                "difficulty": "medium",
                "description": "Calculate the factorial of a given non-negative integer using a loop.",
                "starter_code": "#include <stdio.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    // Logic here\n    return 0;\n}",
                "test_cases": [
                    {
                        "stdin": "5",
                        "expected_output": "120"
                    }
                ]
            }
        ]
    },
    {
        "id": "c-l3",
        "title": "LEVEL 3: Arrays & Strings",
        "lessons": [
            {
                "id": "c13",
                "title": "Lesson 13: Arrays",
                "duration": "35 mins",
                "content": "An array is a collection of elements where all items are stored using the same declared data type in contiguous memory. Instead of creating numerous separate variables for related items (like `temp1`, `temp2`, `temp3`), an array allows you to manage multiple values under a single, meaningful variable name. This structure is fundamental for organizing and processing large data sets efficiently in C.\n\n---\n\n## What is an Array?\n\nAn array is a data structure that allows you to store a fixed-size, sequential collection of elements of the same type. It acts as a single container for multiple values. This homogeneity is strict: every item in an array must share the same data type. You cannot mix integers and floats in a single array.\n\n---\n\n## Memory Layout and Addressing\n\nArray elements are stored in **contiguous** (side-by-side) memory locations. This physical layout is what makes arrays extremely fast for data access.\n\n### How Memory is Calculated\nThe compiler determines the address of any element using a simple formula:  \n`Address = Base Address + (Index * Size of Data Type)`\n\nFor example, if you declare `int a[5];` on a system where an `int` is 4 bytes:\n- The array occupies a total of **20 bytes** (5 elements × 4 bytes).\n- If the first element (`a[0]`) is at memory address `1000`:\n    - `a[1]` will be at `1004`\n    - `a[2]` will be at `1008`\n    - ...and so on.\n\n---\n\n## Why Use Arrays in C?\n\n- **Data Organization**: Keep related information grouped together logically (e.g., storing 30 daily temperatures rather than 30 separate variables).\n- **Efficient Processing**: Use loops to process hundreds or thousands of elements with just a few lines of code.\n- **Direct Access**: Since memory is contiguous, the computer can jump directly to any element instantly using its index.\n\n---\n\n## Declaration and Memory Allocation\n\nDeclaring an array is a request to the compiler to reserve a specific block of memory based on the declared size. The compiler calculates the space required by multiplying the size of the data type by the number of elements. \n\n**Warning on Size**: If an array is declared too large (especially inside a function), it may cause a **stack overflow** at runtime, causing your program to crash.\n\n### Syntax\n```c\ndatatype name[size];\n```\n\n### Uninitialized Arrays and Garbage Values\nThe initial contents of an array depend on where it is declared:\n- **Local Arrays**: Declared inside a function, these contain \"garbage values\" (random bits from previous memory usage).\n- **Global or Static Arrays**: Declared outside functions (or with the `static` keyword), these are automatically initialized to **0** by the compiler.\n\n---\n\n## Initialization Rules\n\nInitialization is the process of assigning values to an array at the precise moment of its declaration using an **initializer list** (values inside `{}`). The compiler maps these values sequentially, starting from index 0. This \"batch assignment\" is an exclusive privilege of the declaration line; once the array is declared, you must update elements individually.\n\n### Full Initialization\n```c\nint scores[5] = {90, 85, 88, 92, 95};\n```\n\n### Partial Initialization and the Zero-Fill Rule\nIf you provide fewer values than the declared size:\n```c\nint numbers[10] = {1, 2, 3};\n```\nIndices 0 to 2 are set to 1, 2, and 3. **The remaining elements are automatically initialized to 0.** This is a common shortcut: `int arr[100] = {0};` zeros the entire array.\n\n---\n\n## Accessing Elements: The Indexing Rule\n\nTo interact with an array, you use an **index** (offset) inside square brackets.\n- **First Element**: `arr[0]`\n- **Last Element**: `arr[size - 1]`\n\n### Warning: The Deceptive Nature of Undefined Behavior\nC does not provide \"bounds checking.\" Accessing `arr[size]` or `arr[-1]` leads to **Undefined Behavior**. \n\n**Critical Warning**: Out-of-bounds access may sometimes \"appear to work,\" which makes it extremely dangerous. The program might not crash immediately, but it can silently corrupt unrelated memory, leading to bugs that are incredibly difficult to find.\n\n---\n\n## Example: Processing User Data\n\nThis example demonstrates reading data into an array, calculating a sum, and validating indices.\n\n```c\n#include <stdio.h>\n\nint main() {\n    int numbers[5];\n    int sum = 0;\n\n    printf(\"Enter 5 integers to calculate their sum:\\n\");\n\n    for(int i = 0; i < 5; i++) {\n        printf(\"Value %d: \", i + 1);\n        // Note: In production code, always check the return value of scanf\n        scanf(\"%d\", &numbers[i]);\n    }\n\n    for(int i = 0; i < 5; i++) {\n        sum += numbers[i];\n    }\n\n    printf(\"\\nThe total sum is: %d\\n\", sum);\n    return 0;\n}\n```\n\n### Sample Output\n```text\nEnter 5 integers to calculate their sum:\nValue 1: 10\nValue 2: 20\nValue 3: 30\nValue 4: 40\nValue 5: 50\n\nThe total sum is: 150\n```\n\n### Code Breakdown\n- **Array Declaration**: `int numbers[5];` reserves space for 5 integers. Since it's a local variable, it initially contains garbage values.\n- **The Input Loop**: The first `for` loop executes 5 times. In each iteration, `scanf(\"%d\", &numbers[i])` stores a user-provided integer into the array at position `i`.\n- **The Processing Loop**: The second `for` loop traverses the array. The line `sum += numbers[i]` adds the value at the current index to the `sum` variable.\n- **Final Result**: The `printf` command outside the loops displays the calculated total stored in `sum`.\n\n---\n\n## Common Errors\n- **Off-by-One Error**: Accessing index `size` instead of `size - 1`.\n- **Missing Address-of (&)**: Forgetting `&` in `scanf(\"%d\", &arr[i])`.\n- **Invalid Re-assignment**: Attempting `arr = {1, 2};` after declaration.\n- **Uninitialized Logic**: Using local array values before filling them.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What is the index of the very first element in an array?",
                        "options": [
                            "1",
                            "0",
                            "-1",
                            "It depends on the array size"
                        ],
                        "correctAnswer": 1,
                        "explanation": "In C (and most programming languages), array indexing is 0-based, meaning the first element is always at index 0."
                    },
                    {
                        "id": 2,
                        "text": "If you declare `int arr[5];`, what is the index of the last element?",
                        "options": [
                            "5",
                            "4",
                            "0",
                            "Unknown"
                        ],
                        "correctAnswer": 1,
                        "explanation": "The indices are 0, 1, 2, 3, 4. So the last index is always (size - 1), which is 4."
                    },
                    {
                        "id": 3,
                        "text": "What happens if you try to access `arr[10]` in an array declared as `int arr[5];`?",
                        "options": [
                            "It returns 0",
                            "It automatically expands the array",
                            "It causes undefined behavior (often a crash or garbage value)",
                            "It prints an error message gracefully"
                        ],
                        "correctAnswer": 2,
                        "explanation": "Accessing an index outside the declared size is 'undefined behavior'. It might crash your program or read invalid memory."
                    },
                    {
                        "id": 4,
                        "text": "Which of these is a valid array declaration?",
                        "options": [
                            "array int marks[5];",
                            "int marks[];",
                            "int marks[5];",
                            "marks[5] int;"
                        ],
                        "correctAnswer": 2,
                        "explanation": "Correct syntax is `datatype name[size];`. `int marks[];` is invalid unless you initialize it immediately."
                    },
                    {
                        "id": 5,
                        "text": "Can an array store different data types (e.g., an int and a float) at the same time?",
                        "options": [
                            "Yes, always",
                            "No, never",
                            "Only if declared as 'mixed'",
                            "Yes, in newer versions of C"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Arrays are homogeneous collections, meaning all elements must be of the exact same data type."
                    }
                ]
            },
            {
                "id": "c14",
                "title": "Lesson 14: Types of Arrays",
                "duration": "40 mins",
                "content": "Arrays are classified based on the number of **indices (dimensions)** used to access their elements. A dimension is simply an independent direction in which data can be organized. Understanding these types is essential because different problems require different data structures: from a simple shopping list to a complex climate simulation grid.\n\n---\n\n## One-Dimensional Array (1-D)\n\n### What is it?\nA 1-D array is the most common and simplest form of an array. You can think of it as a **\"Single Row\"** or a **\"Linear List\"**. It is used to store data that follows a natural sequence, like the names of students in a class, daily temperatures for a month, or a series of prices in a store.\n\nImagine a row of identical lockers in a hallway. Each locker has a number (an index) starting from 0, and each locker can hold one piece of information. To get to a specific piece of data, you only need to know its locker number. In C, you access this data using exactly **one index**.\n\n### Declaration & Memory\n```c\nint arr[5];\n```\n- **Visual Layout:** `[ 10 | 20 | 30 | 40 | 50 ]`\n- **Memory Addressing Formula:**\n  `Address of arr[i] = Base Address + (i × Size of int)`\n\n  For `arr[0]` at address 1000:\n  - `arr[0]` → 1000\n  - `arr[1]` → 1004\n  - `arr[4]` → 1016\n\n### Initialization Rules\n- **Full Initialization:** `int arr[5] = {10, 20, 30, 40, 50};`\n- **Auto-Size:** `int arr[] = {10, 20, 30};` — Compiler infers size as 3.\n- **Partial Initialization:** `int arr[5] = {10, 20};` — Remaining elements are auto-set to **0**.\n\n---\n\n## Two-Dimensional Array (2-D)\n\n### What is it?\nA 2-D array is like a **Table, Grid, or Spreadsheet** with Rows and Columns. It is essentially an **\"Array of Arrays\"** — imagine a shelf with multiple rows, where each row contains several identical slots for data.\n\nIn the real world, we use 2-D structures everywhere: a **Chessboard** (8x8 grid), a **Digital Screen** (composed of rows and columns of pixels), or a **Classroom Seating Chart**. To find a specific student in a seating chart, you need two pieces of information: the **Row** they are sitting in and the **Column** (or Seat number) in that row. This is why C requires two indices to access data in a 2-D array.\n\n### Visualizing `int matrix[2][3];`\nThis creates a table with 2 Rows (index 0–1) and 3 Columns (index 0–2):\n\n| | Col 0 | Col 1 | Col 2 |\n| :--- | :---: | :---: | :---: |\n| **Row 0** | `matrix[0][0]` | `matrix[0][1]` | `matrix[0][2]` |\n| **Row 1** | `matrix[1][0]` | `matrix[1][1]` | `matrix[1][2]` |\n\n### Mathematical Addressing (2D)\nBecause the computer's physical memory is linear (one long row), the compiler must \"flatten\" the table using a formula:\n`Address = Base + ((i × total_columns) + j) × sizeof(datatype)`\n\nThis explains why the **column count is mandatory** in C declarations: the computer needs to know how many slots to \"skip\" to get from the start of Row 0 to the start of Row 1.\n\n### Initialization & The Column Rule\n```c\nint grid[2][3] = { {1, 2, 3}, {4, 5, 6} };   // OK\nint grid[][3]  = { {1, 2, 3}, {4, 5, 6} };   // OK (Rows = 2)\n// int grid[2][] = { ... };                  // ERROR: Columns unknown\n```\n\n### Example: Matrix Transpose\nA transpose operation effectively \"flips\" a matrix over its diagonal, turning rows into columns.\n\n```c\n#include <stdio.h>\n\nint main() {\n    int mat[2][3] = {{1, 2, 3}, {4, 5, 6}};\n    int trans[3][2];\n\n    for(int i = 0; i < 2; i++) {\n        for(int j = 0; j < 3; j++) {\n            trans[j][i] = mat[i][j];\n        }\n    }\n\n    printf(\"Transposed Matrix:\\n\");\n    for(int i = 0; i < 3; i++) {\n        for(int j = 0; j < 2; j++) {\n            printf(\"%d \", trans[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n```\n\n---\n\n## Three-Dimensional Array (3-D)\n\n### What is it?\nThink of a 3-D array as a **Collection of Tables**, or like **Pages in a Book** where each individual page is a 2-D table. It extends our data organization into **Depth**.\n\nImagine an apartment building:\n1. First, you specify which **Floor (Layer)** you are on.\n2. Then, you specify which **Row (Corridor)** you are walking down.\n3. Finally, you specify which **Room (Column)** you are entering.\n\nIn technical fields, 3-D arrays are used for **Volumetric Data**, such as **3D Game Maps** (X, Y, and Z coordinates), **Medical MRI Scans** (slices of the body), or **Scientific Simulations** representing a 3D block of air or water.\n\n### Declaration Syntax\n```c\ndatatype name[layers][rows][columns];\n```\n\n### Mathematical Addressing (3D)\nTo find the location of `cube[k][i][j]` (Layer k, Row i, Col j):\n`Address = Base + ((k × rows × cols) + (i × cols) + j) × sizeof(type)`\n\nThis formula tells the computer to skip `k` full tables, then skip `i` full rows on the current table, and finally move `j` positions across the target row.\n\n### Example: Volume Summation\nThis example calculates the total sum of values stored in a small 3-D data \"cube\".\n\n```c\n#include <stdio.h>\n\nint main() {\n    int cube[2][2][2] = {\n        {{1, 1}, {1, 1}},  // Page 0 (Top layer)\n        {{2, 2}, {2, 2}}   // Page 1 (Bottom layer)\n    };\n    int total = 0;\n\n    for (int k = 0; k < 2; k++) {\n        for (int i = 0; i < 2; i++) {\n            for (int j = 0; j < 2; j++) {\n                total += cube[k][i][j];\n            }\n        }\n    }\n    printf(\"Total Volume Sum: %d\\n\", total);\n    return 0;\n}\n```\n\n---\n\n## Summary Comparison\n\n| Property | 1-D Array | 2-D Array | 3-D Array |\n| :--- | :---: | :---: | :---: |\n| **Physical Analogy** | Locker Row | Seating Chart | Apartment Building |\n| **Logic** | List | Table | Cube / Book |\n| **Indices Needed** | 1 | 2 | 3 |\n| **Real Use Case** | Scores, Names | Chessboard, images | 3D Maps, voxels |\n\n---\n\n## Common Errors & Performance Tips\n\n- **Mandatory Dimensions:** You can omit the *first* dimension during initialization, but all subsequent dimensions (**Columns in 2D**, **Rows/Columns in 3D**) are required so the compiler can calculate memory jumps.\n- **Memory Locality (Row-Major):** C always stores data row-by-row. Accessing data row-wise (`matrix[0][0], [0][1], [0][2]`) is much faster than column-wise because the data is physically next to each other in memory.\n- **Index Sensitivity:** Remember that **Size 5** means indices go from **0 to 4**. Accessing index 5 is a common \"Off-by-One\" error that can crash your program.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Which real-world analogy best describes a 3-Dimensional (3-D) array?",
                        "options": [
                            "A single row of school lockers",
                            "A seating chart in a single classroom",
                            "An apartment building with Floors, Corridors, and Rooms",
                            "A simple shopping list"
                        ],
                        "correctAnswer": 2,
                        "explanation": "A 3-D array adds a third dimension (depth), much like an apartment building where you need a Floor (Layer), Corridor (Row), and Room (Column) to find a specific location."
                    },
                    {
                        "id": 2,
                        "text": "In the 2-D addressing formula `Addr = Base + ((i * cols) + j) * size`, why is 'cols' part of the calculation?",
                        "options": [
                            "To find the start of the entire array",
                            "To skip the correct number of elements to reach row 'i'",
                            "To determine how many rows are in the array",
                            "To calculate the size of a single integer"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Because memory is linear, the computer must skip every element in all rows preceding row 'i'. Each row contains exactly 'cols' elements."
                    },
                    {
                        "id": 3,
                        "text": "What happens if you omit the column count in a 2-D array declaration like `int arr[2][];`?",
                        "options": [
                            "The compiler automatically sets it to 1",
                            "It creates a 1-D array instead",
                            "A compilation error occurs because the compiler cannot calculate row sizes",
                            "The program runs but accesses random memory"
                        ],
                        "correctAnswer": 2,
                        "explanation": "In C, the compiler MUST know the size of all dimensions except the first one to calculate memory addresses correctly. Omitting the column count is an error."
                    },
                    {
                        "id": 4,
                        "text": "Why is it faster to access a large 2-D array row-by-row rather than column-by-column in C?",
                        "options": [
                            "The CPU prefers to count rows",
                            "C uses Row-Major Order, so row elements are physically next to each other in memory",
                            "Column-wise access is actually faster",
                            "Row-wise access uses less memory"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Due to Row-Major Order, elements in the same row are stored contiguously. Accessing them in order (locality) allows the CPU cache to work efficiently, making it much faster."
                    },
                    {
                        "id": 5,
                        "text": "If you have a 3-D array `int book[5][10][20]`, how many total elements are in the 'depth' (first) dimension?",
                        "options": [
                            "10",
                            "20",
                            "5",
                            "1000"
                        ],
                        "correctAnswer": 2,
                        "explanation": "In `book[5][10][20]`, the first index (5) represents the number of layers or pages (depth). The total elements in the array would be 5 * 10 * 20 = 1000."
                    }
                ]
            },
            {
                "id": "c15",
                "title": "Lesson 15: Arrays and Functions",
                "duration": "45 mins",
                "content": "A key feature of C is the ability to pass arrays to functions. However, unlike regular variables, arrays behave differently when passed.\n\n---\n\n## The \"Pass by Pointer\" Rule\n\nWhen you pass an array to a function, you are NOT passing a copy of the entire array. Instead, you are passing the **address** (pointer) of the first element.\n\n### Implications\n1.  **Efficiency:** It saves memory (no copying of big data).\n2.  **Modifiable:** The function **CAN modify** the original array.\n3.  **Size Loss:** The function doesn't know the array's size, so you usually pass `size` as a separate argument.\n\n---\n\n## Passing 1-D Arrays\n\n### Syntax\nBoth syntax styles below mean the same thing: \"I expect an integer address\".\n```c\nvoid func(int arr[], int size); // Style 1 (Preferred for readability)\nvoid func(int *arr, int size);  // Style 2 (Shows it's a pointer)\n```\n\n### Example: Doubling Array Values\nThis example shows how a function can change the original array's data.\n\n```c\n#include <stdio.h>\n\n// Function to double every number\nvoid doubleValues(int arr[], int size) {\n    for(int i = 0; i < size; i++) {\n        arr[i] = arr[i] * 2;\n    }\n}\n\nint main() {\n    int numbers[] = {1, 2, 3, 4};\n    \n    printf(\"Before: %d %d\\n\", numbers[0], numbers[1]);\n    \n    doubleValues(numbers, 4); // Pass array + size\n    \n    printf(\"After:  %d %d\\n\", numbers[0], numbers[1]);\n    return 0;\n}\n```\n\n### Expected Output\n```text\nBefore: 1 2\nAfter:  2 4\n```\n\n** How it Works:**\n- `doubleValues` receives the address of `numbers`.\n- It loops through the memory, multiplying each value by 2.\n- Since it modified the original memory, `main` sees the changed values.\n\n---\n\n## Protecting Arrays with `const`\n\nSometimes you want to pass an array to a function just to **read** it (e.g., printing), and you want to ensure the function doesn't accidentally change it. Use the `const` keyword.\n\n### Syntax\n```c\nvoid printArray(const int arr[], int size);\n```\n\n### Example\n```c\nvoid printArray(const int arr[], int size) {\n    // arr[0] = 100;   ERROR: Cannot modify a const array\n    printf(\"%d\", arr[0]); //  OK: Reading is allowed\n}\n```\n\n---\n\n## Passing Single Elements (Pass by Value)\n\nIf you pass just one index (e.g., `arr[2]`), it behaves like a normal variable (Pass by Value). The function gets a **copy**, so the original stays unchanged.\n\n### Syntax\n```c\nvoid func(int value); // Receives a copy, not the array\n```\n\n### Example\n```c\nvoid tryToChange(int x) {\n    x = 999;\n}\n\nint main() {\n    int arr[] = {10, 20};\n    tryToChange(arr[0]);\n    printf(\"%d\", arr[0]);\n    return 0;\n}\n```\n\n### Expected Output\n\n```text\n10\n```\n\n---\n\n## Passing 2-D Arrays\n\nWhen passing a multidimensional array, you **MUST specify the number of columns** (the second dimension). The compiler needs this to calculate memory addresses correctly.\n\n### Syntax\n```c\nvoid printGrid(int arr[][3], int rows);\n```\n- `[]` (Rows): Optional / Ignored.\n- `[3]` (Cols): **Mandatory**.\n\n### Example: Printing a 2D Array\n```c\n#include <stdio.h>\n\nvoid print2D(int arr[][2], int rows) {\n    for(int i = 0; i < rows; i++) {\n        printf(\"[%d, %d] \\n\", arr[i][0], arr[i][1]);\n    }\n}\n\nint main() {\n    int points[2][2] = {{5, 5}, {10, 10}};\n    print2D(points, 2);\n    return 0;\n}\n```\n\n### Expected Output\n```text\n[5, 5] \n[10, 10] \n```\n\n---\n\n## Can we Return an Array?\n\nThis is a common interview question. **NO**, you cannot directly return a local array from a function.\n\n### Syntax\n```c\nint* getArray(); // Returns a pointer (address)\n```\n\n### The Mistake\n```c\nint* getArray() {\n    int arr[5] = {1, 2, 3, 4, 5};\n    return arr; // ️ DANGER: Returning address of local variable\n}\n```\n**Why?** The local array `arr` is destroyed when `getArray()` finishes. The pointer you return points to \"dead\" memory.\n\n### The Fix (Static)\nOne simple way is to use `static`, so the memory lasts for the whole program.\n```c\nint* getArray() {\n    static int arr[5] = {1, 2, 3, 4, 5};\n    return arr; //  Safe\n}\n```\n\n---\n\n## Common Pitfalls: The `sizeof` Trap\n\nOne of the biggest mistakes beginners make is using `sizeof` on an array parameter.\n\n```c\nvoid func(int arr[]) {\n    printf(\"%lu\", sizeof(arr)); \n}\n```\n\n### Expected Output\n\n```text\n8\n```\n\n*(Note: 8 is the size of a pointer on most 64-bit systems)*\n```\n**Always pass the size as a separate argument!**\n\n---\n\n## Key Takeaways\n- **Pass as Pointer**: Arrays always decay to pointers when passed.\n- **Use `const`**: To protect arrays from modification.\n- **Size Argument**: Always pass size explicitly.\n- **2-D Arrays**: Columns must be specified.\n- **Returning**: Never return a local array variable.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Why is `sizeof(arr)` unreliable inside a function that receives array `arr`?",
                        "options": [
                            "It returns the size of the first element only",
                            "It returns the size of the pointer (usually 8 bytes), not the full array",
                            "It returns 0",
                            "It causes a compilation error"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Because array parameters decay to pointers, `sizeof` measures the pointer, not the memory block."
                    },
                    {
                        "id": 2,
                        "text": "What happens if you try to modify an array passed as `const int arr[]`?",
                        "options": [
                            "The program crashes at runtime",
                            "The compiler generates an error",
                            "It works fine, constraints are just suggestions",
                            "It creates a local copy and modifies that"
                        ],
                        "correctAnswer": 1,
                        "explanation": "The `const` keyword tells the compiler to enforce read-only access. Any attempt to modify it is a syntax error."
                    },
                    {
                        "id": 3,
                        "text": "What is the danger of returning a local array (non-static) from a function?",
                        "options": [
                            "The values become 0",
                            "The array is promoted to global scope",
                            "It returns a pointer to deallocated/dead memory (Dangling Pointer)",
                            "It works perfectly fine"
                        ],
                        "correctAnswer": 2,
                        "explanation": "Local variables are destroyed when the function exits. The returned pointer points to memory that may be overwritten immediately."
                    },
                    {
                        "id": 4,
                        "text": "Which declaration correctly creates a read-only 2-D array parameter?",
                        "options": [
                            "void func(int arr[][3] const)",
                            "void func(int const arr[][3])",
                            "void func(const int arr[][3])",
                            "void func(const int arr[2])"
                        ],
                        "correctAnswer": 2,
                        "explanation": "`const int arr[][3]` ensures that the integers inside the array cannot be changed."
                    },
                    {
                        "id": 5,
                        "text": "When passing `int arr[5]` to `void func(int x[])`, what is `x`?",
                        "options": [
                            "A full copy of the array",
                            "A pointer to the first integer of arr",
                            "A special array reference type",
                            "The value of the first element"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Technically, `x` is `int*` (a pointer), pointing to `&arr[0]`."
                    }
                ]
            },
            {
                "id": "c16",
                "title": "Lesson 16: Strings in C",
                "duration": "45 mins",
                "content": "The C language does not have a built-in string data type like C++ or Java.\nInstead, **strings in C are stored as arrays of characters**, terminated by a \"null byte\".\n\n---\n\n## Internal Representation\n\nA string is just a sequence of characters followed by a special `\\0` character.\n\n### Memory View\nIf we store `\"HELLO\"`:\n| Index | 0 | 1 | 2 | 3 | 4 | 5 |\n| :--- | :---: | :---: | :---: | :---: | :---: | :---: |\n| **Char** | 'H' | 'E' | 'L' | 'L' | 'O' | **'\\0'** |\n\n- **Valuable Payload:** 5 characters.\n- **Micro-Manager:** The `\\0` (Null Terminator) tells functions like `printf` where to stop.\n\n---\n\n## Declaration and Initialization\n\nYou can create strings in two main distinct ways.\n\n### Syntax\n```c\nchar str[] = \"Value\"; // Mutable Array\nchar *str = \"Value\";  // Read-Only Literal\n```\n\n### Method A: Character Array (Mutable)\nThis creates a copy of the string in memory that you can change.\n```c\nchar name[] = \"Alice\";\nname[0] = 'B'; //  OK: Becomes \"Blice\"\n```\n\n### Method B: String Literal (Read-Only)\nThis points to a fixed storage location.\n```c\nchar *name = \"Alice\";\n// name[0] = 'B'; //  ERROR: Crash (Undefined Behavior)\n```\n\n---\n\n## Reading Strings (Input)\n\nReading strings is trickier than numbers because of spaces.\n\n### Method A: `scanf` (The Simple Way)\nGood for single words. Stops at the first space.\n```c\nchar name[20];\nprintf(\"Enter name: \");\nscanf(\"%s\", name); // ️ No & needed for arrays\n```\n*Input: \"John Doe\"  Stored: \"John\"*\n\n### Method B: `fgets` (The Safe Way)\nBest for sentences. Reads spaces and prevents overflow.\n```c\nchar buffer[50];\nprintf(\"Enter full name: \");\nfgets(buffer, 50, stdin);\n```\n*Input: \"John Doe\"  Stored: \"John Doe\"*\n\n### Example: Safe String Input\n```c\n#include <stdio.h>\n\nint main() {\n    char name[20];\n    \n    printf(\"Who are you? \");\n    fgets(name, 20, stdin); // Safe reading\n    \n    printf(\"Hello, %s\", name);\n    return 0;\n}\n```\n\n**Expected Output:**\n```text\nWho are you? Gen Spark\nHello, Gen Spark\n```\n\n** How it Works:**\n- `fgets` reads up to 19 characters + 1 null terminator.\n- It includes the space in \"Gen Spark\".\n- It reads from simple standard input (`stdin`).\n\n---\n\n## Common Operations\n\n| Operation | Function | Example |\n| :--- | :--- | :--- |\n| **Length** | `strlen(s)` | Count chars (excludes `\\0`) |\n| **Copy** | `strcpy(dest, src)` | Copy `src` to `dest` |\n| **Compare** | `strcmp(s1, s2)` | Returns 0 if equal |\n| **Combine** | `strcat(dest, src)` | Append `src` into `dest` |\n\n---\n\n## Key Takeaways\n- **Null Terminator**: Strings MUST end with `\\0`.\n- **Space Allocation**: Always allocate `length + 1` for the null byte.\n- **Input**: Use `fgets` for text with spaces, `scanf` for single words.\n- **Mutability**: Arrays (`char[]`) are editable; Literals (`char*`) are not.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "How many bytes of memory are required to store the string \"Cat\"?",
                        "options": [
                            "3 bytes",
                            "4 bytes",
                            "8 bytes",
                            "Unknown"
                        ],
                        "correctAnswer": 1,
                        "explanation": "You need 3 bytes for 'C', 'a', 't' plus 1 byte for the null terminator '\\0'. Total = 4."
                    },
                    {
                        "id": 2,
                        "text": "Which method should you use to read a sentence with spaces (e.g., \"Hello World\")?",
                        "options": [
                            "scanf(\"%s\", str);",
                            "fgets(str, size, stdin);",
                            "read(str);",
                            "cin >> str;"
                        ],
                        "correctAnswer": 1,
                        "explanation": "`scanf` stops reading at the first whitespace. `fgets` reads until the newline character, capturing the full sentence."
                    },
                    {
                        "id": 3,
                        "text": "What happens if you try: char *s = \"Hi\"; s[0] = 'B'; ?",
                        "options": [
                            "The string becomes \"Bi\"",
                            "Compiler Error",
                            "Runtime Crash (Undefined Behavior)",
                            "Nothing happens"
                        ],
                        "correctAnswer": 2,
                        "explanation": "String literals defined with `char *` are usually stored in read-only memory. Modifying them causes undefined behavior (often a crash)."
                    },
                    {
                        "id": 4,
                        "text": "What is the index of the null terminator in `char s[] = \"CODE\"`?",
                        "options": [
                            "3",
                            "4",
                            "5",
                            "0"
                        ],
                        "correctAnswer": 1,
                        "explanation": "C=0, O=1, D=2, E=3, \\0=4."
                    },
                    {
                        "id": 5,
                        "text": "Why do we use `strcpy` instead of `str1 = str2` for arrays?",
                        "options": [
                            "Because arrays cannot be assigned directly in C",
                            "Because strcpy is faster",
                            "Because = is for numbers only",
                            "Because it looks cooler"
                        ],
                        "correctAnswer": 0,
                        "explanation": "Arrays in C are not first-class objects that support direct assignment. You must copy them element-by-element or use `strcpy`."
                    }
                ]
            },
            {
                "id": "c17",
                "title": "Lesson 17: String Functions in C",
                "duration": "50 mins",
                "content": "To work with strings efficiently, C provides standard functions in the **`<string.h>`** library. These functions rely on one critical rule: **The string must end with a `\\0`**.\n\n```c\n#include <string.h>\n```\n\n---\n\n## strlen (String Length)\n\nCalculates the length of a string, **excluding** the null terminator.\n\n### Syntax\n```c\nsize_t strlen(const char *str);\n```\n\n### Example\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char s[] = \"Code\";\n    printf(\"Length: %d\\n\", strlen(s));\n    printf(\"Size: %d\\n\", sizeof(s));\n    return 0;\n}\n```\n\n**Expected Output:**\n```text\nLength: 4\nSize: 5\n```\n\n** How it Works:**\n- `strlen` counts 'C', 'o', 'd', 'e' (4).\n- `sizeof` counts all bytes including `\\0` (5).\n\n---\n\n## strcpy (String Copy)\n\nCopies a string from specific source to destination. **Unsafe** if destination is too small.\n\n### Syntax\n```c\nchar* strcpy(char *dest, const char *src);\n```\n\n### Example\n```c\nchar src[] = \"Hello\";\nchar dest[20]; // Ensure this is big enough!\n\nstrcpy(dest, src);\nprintf(\"Copied: %s\", dest);\n```\n\n**Expected Output:**\n```text\nCopied: Hello\n```\n\n** How it Works:**\n- Copies 'H', 'e', 'l', 'l', 'o', and the null byte `\\0` to `dest`.\n\n---\n\n## strncpy (Safe String Copy)\n\nCopies AT MOST `n` characters. Safer, but tricky with null termination.\n\n### Syntax\n```c\nchar* strncpy(char *dest, const char *src, size_t n);\n```\n\n### Example\n```c\nchar src[] = \"Hello World\";\nchar dest[6];\n\nstrncpy(dest, src, 5); // Copy only 5 chars\ndest[5] = '\\0';       // ️ Manual termination needed!\n\nprintf(\"Safe Copy: %s\", dest);\n```\n\n**Expected Output:**\n```text\nSafe Copy: Hello\n```\n\n** How it Works:**\n- Copies only first 5 chars.\n- Since `n` was reached before `\\0`, it stops **without** adding `\\0`.\n- We manually add `dest[5] = '\\0'` to make it a valid string.\n\n---\n\n## strcat (String Concatenation)\n\nAppends (joins) source to the end of destination.\n\n### Syntax\n```c\nchar* strcat(char *dest, const char *src);\n```\n\n### Example\n```c\nchar dest[20] = \"Hello \";\nchar src[] = \"World\";\n\nstrcat(dest, src);\nprintf(\"Joined: %s\", dest);\n```\n\n**Expected Output:**\n```text\nJoined: Hello World\n```\n\n** How it Works:**\n- Finds the `\\0` in \"Hello \".\n- Overwrites it with 'W' from \"World\".\n- Copies the rest and adds a new `\\0`.\n\n---\n\n## strncat (Safe Concatenation)\n\nAppends at most `n` characters. Automatically adds `\\0`.\n\n### Syntax\n```c\nchar* strncat(char *dest, const char *src, size_t n);\n```\n\n### Example\n```c\nchar dest[20] = \"Hello \";\nstrncat(dest, \"Beautiful World\", 9);\nprintf(\"%s\", dest);\n```\n\n**Expected Output:**\n```text\nHello Beautiful\n```\n\n** How it Works:**\n- Takes only first 9 characters from source.\n- ALWAYS adds a `\\0` at the end (unlike `strncpy`).\n\n---\n\n## strcmp (String Compare)\n\nCompares two strings character by character (ASCII).\n\n### Syntax\n```c\nint strcmp(const char *s1, const char *s2);\n```\n\n### Example\n```c\nif(strcmp(\"Apple\", \"Banana\") < 0) {\n    printf(\"Apple comes first\");\n}\n```\n\n**Expected Output:**\n```text\nApple comes first\n```\n\n** How it Works:**\n- 'A' (65) - 'B' (66) = -1 (Negative).\n- Negative means `s1` is alphabetically smaller.\n\n---\n\n## strncmp (Safe Compare)\n\nCompares only the first `n` characters.\n\n### Syntax\n```c\nint strncmp(const char *s1, const char *s2, size_t n);\n```\n\n### Example\n```c\nif(strncmp(\"ApplePie\", \"AppleSauce\", 5) == 0) {\n    printf(\"First 5 chars match\");\n}\n```\n\n**Expected Output:**\n```text\nFirst 5 chars match\n```\n\n** How it Works:**\n- Checks 'A', 'p', 'p', 'l', 'e'. All match.\n- Returns 0 (Equal).\n\n---\n\n## strchr (Find Character)\n\nFinds the **first** occurrence of a character.\n\n### Syntax\n```c\nchar* strchr(const char *str, int c);\n```\n\n### Example\n```c\nchar s[] = \"google.com\";\nchar *ptr = strchr(s, '.');\nprintf(\"Domain: %s\", ptr);\n```\n\n**Expected Output:**\n```text\nDomain: .com\n```\n\n** How it Works:**\n- Scans for '.'.\n- Returns pointer to that '.' in memory.\n- Printing `ptr` prints from '.' onwards.\n\n---\n\n## strrchr (Find Last Character)\n\nFinds the **last** occurrence of a character.\n\n### Syntax\n```c\nchar* strrchr(const char *str, int c);\n```\n\n### Example\n```c\nchar s[] = \"/home/user/docs/file.txt\";\nchar *file = strrchr(s, '/');\nprintf(\"Filename: %s\", file + 1); // +1 skip '/'\n```\n\n**Expected Output:**\n```text\nFilename: file.txt\n```\n\n** How it Works:**\n- Finds the *last* slash.\n- `file` points to `/file.txt`.\n- `file + 1` skips the slash.\n\n---\n\n## strstr (Find Substring)\n\nFinds the first occurrence of a substring.\n\n### Syntax\n```c\nchar* strstr(const char *haystack, const char *needle);\n```\n\n### Example\n```c\nchar s[] = \"C Programming is fun\";\nchar *ptr = strstr(s, \"gram\");\nprintf(\"Found: %s\", ptr);\n```\n\n**Expected Output:**\n```text\nFound: gramming is fun\n```\n\n** How it Works:**\n- Looks for sequence \"gram\".\n- Returns pointer to 'g'.\n\n---\n\n## strtok (String Tokenize)\n\nSplits a string into tokens. **Destructive** (modifies original string).\n\n### Syntax\n```c\nchar* strtok(char *str, const char *delim);\n```\n\n### Example\n```c\nchar s[] = \"HTML,CSS,JS\";\nchar *token = strtok(s, \",\");\n\nwhile (token != NULL) {\n    printf(\"Lang: %s\\n\", token);\n    token = strtok(NULL, \",\"); // Pass NULL to continue\n}\n```\n\n**Expected Output:**\n```text\nLang: HTML\nLang: CSS\nLang: JS\n```\n\n** How it Works:**\n- Finds first `,` and replaces it with `\\0`.\n- Returns pointer to \"HTML\".\n- `NULL` tells it to continue from where it left off (using static memory).\n\n---\n\n## Key Takeaways\n- **Safety**: Prefer `n` versions (`strncpy`, `strncat`) to avoid overflows.\n- **Termination**: `strncpy` might NOT add `\\0`; do it manually.\n- **Destruction**: `strtok` modifies your string; use a copy if needed.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What is the key difference between `strcpy` and `strncpy`?",
                        "options": [
                            "strcpy is faster",
                            "strncpy copies a limited number of chars, preventing some overflows",
                            "They are the same",
                            "strcpy works on numbers"
                        ],
                        "correctAnswer": 1,
                        "explanation": "`strncpy` takes a size limit `n`, which helps prevent writing past the destination buffer, although you must be careful with null termination."
                    },
                    {
                        "id": 2,
                        "text": "Why must you manually add `\\0` after `strncpy` sometimes?",
                        "options": [
                            "Because C is annoying",
                            "If the source length >= n, strncpy stops strictly at n without adding \\0",
                            "strncpy never adds \\0",
                            "It is a compiler bug"
                        ],
                        "correctAnswer": 1,
                        "explanation": "If the source string length is equal to or greater than the limit `n`, `strncpy` will fill the buffer but won't append the null terminator."
                    },
                    {
                        "id": 3,
                        "text": "What does `strrchr` do differently from `strchr`?",
                        "options": [
                            "Finds the first occurrence",
                            "Finds the last occurrence",
                            "Finds random occurrences",
                            "Nothing, they are aliases"
                        ],
                        "correctAnswer": 1,
                        "explanation": "The extra 'r' stands for 'reverse' or 'right'. It searches for the **last** occurrence of the character."
                    },
                    {
                        "id": 4,
                        "text": "Which function modifies the original string by inserting null bytes?",
                        "options": [
                            "strstr",
                            "strcmp",
                            "strtok",
                            "strlen"
                        ],
                        "correctAnswer": 2,
                        "explanation": "`strtok` breaks strings by replacing delimiters (e.g., comma) with `\\0` to isolate tokens."
                    },
                    {
                        "id": 5,
                        "text": "If `strcmp(A, B)` returns -5, what does it mean?",
                        "options": [
                            "A is equal to B",
                            "A is greater than B",
                            "A is smaller than B",
                            "String A has 5 chars"
                        ],
                        "correctAnswer": 2,
                        "explanation": "Any negative value means the first string is lexicographically (alphabetically) smaller than the second."
                    }
                ]
            }
        ],
        "problems": [
            {
                "id": "c-l3-p1",
                "title": "Array Sum",
                "difficulty": "easy",
                "description": "Read 5 integers into an array and print their sum.",
                "starter_code": "#include <stdio.h>\n\nint main() {\n    int arr[5];\n    // Read 5 elements\n    // Calculate and print sum\n    return 0;\n}",
                "test_cases": [
                    {
                        "stdin": "1 2 3 4 5",
                        "expected_output": "15"
                    }
                ]
            },
            {
                "id": "c-l3-p2",
                "title": "Find Maximum in Array",
                "difficulty": "easy",
                "description": "Read size `n` and then `n` elements into an array. Find and print the maximum element.",
                "starter_code": "#include <stdio.h>\n\nint main() {\n    int n;\n    // Read n\n    // Read array elements\n    // Find max and print\n    return 0;\n}",
                "test_cases": [
                    {
                        "stdin": "5\n10 20 5 40 30",
                        "expected_output": "40"
                    }
                ]
            },
            {
                "id": "c-l3-p3",
                "title": "Linear Search",
                "difficulty": "easy",
                "description": "Search for a number `x` in an array of size `n`. Print the index if found, else print -1.",
                "starter_code": "#include <stdio.h>\n\nint main() {\n    int n, x;\n    // Read n\n    // Read array\n    // Read x\n    // Search and print index or -1\n    return 0;\n}",
                "test_cases": [
                    {
                        "stdin": "5\n1 2 3 4 5\n4",
                        "expected_output": "3"
                    },
                    {
                        "stdin": "3\n10 20 30\n50",
                        "expected_output": "-1"
                    }
                ]
            },
            {
                "id": "c-l3-p4",
                "title": "String Palindrome",
                "difficulty": "medium",
                "description": "Check if a given string is a palindrome (same forwards and backwards). Print 'Palindrome' or 'Not Palindrome'.",
                "starter_code": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[100];\n    // Read string\n    // Check palindrome\n    return 0;\n}",
                "test_cases": [
                    {
                        "stdin": "madam",
                        "expected_output": "Palindrome"
                    },
                    {
                        "stdin": "hello",
                        "expected_output": "Not Palindrome"
                    }
                ]
            },
            {
                "id": "c-l3-p5",
                "title": "Matrix Transpose",
                "difficulty": "medium",
                "description": "Given a 2x2 matrix, print its transpose.",
                "starter_code": "#include <stdio.h>\n\nint main() {\n    int matrix[2][2];\n    // Read matrix\n    // Print transpose\n    return 0;\n}",
                "test_cases": [
                    {
                        "stdin": "1 2\n3 4",
                        "expected_output": "1 3\n2 4"
                    }
                ]
            }
        ]
    },
    {
        "id": "c-l4",
        "title": "LEVEL 4: Functions",
        "lessons": [
            {
                "id": "c18",
                "title": "Lesson 18: Functions in C",
                "duration": "35 mins",
                "content": "Functions are the building blocks of modular C programs. A function is a named sequence of instructions that performs a specific task, isolated by its own memory context called a **Stack Frame**.\n\n---\n\n## Anatomy of a Function\n\nA function has two main parts: the **Header** and the **Body**.\n\n### The Function Header\nThe header defines the interface of the function:\n```c\nreturn_type function_name(parameter_list)\n```\n*   **Return Type**: The type of data sent back to the caller (e.g., `int`, `float`). Use `void` if nothing is returned.\n*   **Function Name**: A unique identifier for the function.\n*   **Parameter List**: Variables that receive input data from the caller.\n\n### The Function Body\nThe code inside the braces `{ }` that performs the actual work.\n\n---\n\n## Memory Mechanics: The Call Stack\n\nWhen you call a function, C creates a **Stack Frame** in memory.\n\n### What is in a Stack Frame?\n*   **Local Variables**: Variables declared inside the function.\n*   **Parameters**: Copies of the values passed into the function.\n*   **Return Address**: The location to jump back to after the function finishes.\n\n### The Lifecycle\n1.  **Push**: When a function is called, its frame is \"pushed\" onto the stack.\n2.  **Execute**: The function runs using its own private memory.\n3.  **Pop**: When the function returns, its frame is \"popped\" (deleted), and memory is freed.\n\n---\n\n## Data Flow: Pass-by-Value\n\nIn C, data is passed by **value**. This means the function receives a **copy** of the variable, not the original.\n\n*   **Isolation**: Changes made to a parameter inside a function do not affect the original variable in `main()`.\n*   **Scope**: Local variables only exist while the function is running.\n\n---\n\n## Code Lab: Math Utility\n\nThis example shows how to declare, define, and call functions properly.\n\n```c\n#include <stdio.h>\n\n// 1. Declaration (Prototype)\nint calculateSum(int a, int b);\nint calculateSquare(int n);\n\nint main() {\n    int x = 10, y = 20;\n\n    // 2. Calling Functions\n    int total = calculateSum(x, y);\n    int sq = calculateSquare(x);\n\n    printf(\"Sum: %d | Square: %d\\n\", total, sq);\n    return 0;\n}\n\n// 3. Definition\nint calculateSum(int a, int b) {\n    return a + b;\n}\n\nint calculateSquare(int n) {\n    return n * n;\n}\n```\n\n### Execution Trace\n1.  **Start**: `main()` starts. Space for `x` and `y` is created.\n2.  **Call**: `calculateSum` is called. A new frame is created with copies of 10 and 20.\n3.  **Result**: The function calculates 30 and returns it.\n4.  **End**: The sum frame is destroyed. `main` receives 30 and continues.\n",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What is contained in a function's Stack Frame?",
                        "options": [
                            "Global variables only",
                            "Local variables, parameters, and return address",
                            "The entire program source code",
                            "Library headers"
                        ],
                        "correctAnswer": 1,
                        "explanation": "The stack frame holds everything unique to a specific function call, including its private variables and where to return to."
                    },
                    {
                        "id": 2,
                        "text": "What does 'Pass-by-Value' mean in C?",
                        "options": [
                            "The function gets the original variable",
                            "A copy of the value is sent to the function",
                            "Variables are moved to the hard drive",
                            "Function cannot use any variables"
                        ],
                        "correctAnswer": 1,
                        "explanation": "C copies the value of the argument into the function's parameter. The original variable remains unchanged."
                    },
                    {
                        "id": 3,
                        "text": "When is a function's memory (Stack Frame) destroyed?",
                        "options": [
                            "As soon as the program starts",
                            "When the function hits a 'return' statement",
                            "Only when the computer restarts",
                            "It is never destroyed"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Memory is reclaimed (the frame is 'popped') as soon as the function finishes its execution."
                    },
                    {
                        "id": 4,
                        "text": "Where should a Function Prototype normally be placed?",
                        "options": [
                            "Inside the function body",
                            "After the main function",
                            "At the top of the file, before main",
                            "In a separate text file"
                        ],
                        "correctAnswer": 2,
                        "explanation": "Prototypes are placed at the top so the compiler knows the function exists before it is called in main."
                    },
                    {
                        "id": 5,
                        "text": "What is the scope of a local variable?",
                        "options": [
                            "The entire program",
                            "Only the function where it is declared",
                            "Only the main function",
                            "Any file in the project"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Local variables are only 'visible' and usable within the braces of the function where they were created."
                    }
                ]
            },
            {
                "id": "c19",
                "title": "Lesson 19: User-Defined Functions",
                "duration": "30 mins",
                "content": "Previously, we learned the basics of functions. Now, let's learn how to make them dynamic! A **User-Defined Function** is a custom tool you build to handle specific data. To do this, you must understand two key concepts: **Parameters** and **Return Values**.\n\n---\n\n## The Data Flow: Input & Output\n\nTo make a function useful, it needs to receive information from `main()` and send a result back. \n\n### Parameters (Input)\nParameters are variables listed in the function's parentheses. They act like \"placeholders\" for the values you pass when calling the function.\n```c\nvoid showSquare(int n) { ... }\n```\nHere, `n` is a parameter that allows any number to be passed in to be squared.\n\n### The Return Value (Output)\nThe `return` keyword is used to send a value back to the place where the function was called. It's like a delivery person bringing a package to your door.\n```c\nreturn result;\n```\n\n---\n\n## Example: The Adder (Args + Return)\n\nThis function takes two integers, adds them, and **returns** the sum back to `main()`.\n\n```c\n#include <stdio.h>\n\n// Step 1: Declaration (Above main)\nint add(int a, int b);\n\nint main() {\n    int sum;\n\n    // Step 3: Call (Passing 10 and 20)\n    sum = add(10, 20); \n\n    printf(\"The sum is: %d\\n\", sum);\n    return 0;\n}\n\n// Step 2: Definition (Below main)\nint add(int a, int b) {\n    int result = a + b;\n    return result; // Delivery back to main!\n}\n```\n\n**Expected Output:**\n```text\nThe sum is: 30\n```\n\n### How it Works\n1. `int add(int a, int b);`: This tells C that a function named `add` exists, which takes two integers as input and gives an integer as output.\n2. `add(10, 20)`: When this is called, C copies the value **10** into the variable `a` and **20** into the variable `b` inside the function.\n3. `return result;`: This line exits the function and carries the number **30** back to `main()`, where it gets stored in the `sum` variable.\n\n---\n\n## Example: Logic Checker (Decision Making)\n\nLet's follow the standard 3-part structure to check if a number is Even or Odd.\n\n```c\n#include <stdio.h>\n\n// 1. Declaration\nint isEven(int n);\n\nint main() {\n    int num = 7;\n\n    // 3. Call inside a condition\n    if (isEven(num))\n        printf(\"%d is Even\\n\", num);\n    else\n        printf(\"%d is Odd\\n\", num);\n\n    return 0;\n}\n\n// 2. Definition\nint isEven(int n) {\n    if (n % 2 == 0)\n        return 1; // 1 means True (Even)\n    else\n        return 0; // 0 means False (Odd)\n}\n```\n\n**Expected Output:**\n```text\n7 is Odd\n```\n\n### How it Works\n1. `isEven(num)`: When this is called with the number **7**, the variable `n` inside the function becomes **7**.\n2. `n % 2 == 0`: The function checks if 7 is divisible by 2. Since it's not, it jumps to the `else` block.\n3. `return 0;`: The function returns **0** to the `if` statement in `main()`. Since 0 is considered \"False\" in C, the `else` part in `main()` executes, printing \"7 is Odd\".\n\n---\n\n## How it Works: The Logic Flow\n\n1.  **Preparation**: C sets aside memory for the function's parameters (`a` and `b`).\n2.  **Passing**: When you call `add(10, 20)`, the value **10** is copied into `a`, and **20** is copied into `b`.\n3.  **Execution**: The function runs its code using these local variables.\n4.  **Terminating**: The `return` statement terminates the function and sends the result back to `main()`.\n\n---\n\n## Summary of Terms\n\n| Term | Purpose |\n| :--- | :--- |\n| **Arguments** | The actual values you send (e.g., `10, 20`) |\n| **Parameters** | The variables that receive them (e.g., `int a, int b`) |\n| **Return Type** | The type of data the function sends back (e.g., `int`) |\n| **void** | Used if the function sends nothing back |",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What is the primary purpose of a 'return' statement in a function?",
                        "options": [
                            "To stop the program entirely",
                            "To send a result back to the caller and exit the function",
                            "To print a message to the console",
                            "To create a loop"
                        ],
                        "correctAnswer": 1,
                        "explanation": "The 'return' statement sends a specific value back to the function that called it and immediately terminates the current function."
                    },
                    {
                        "id": 2,
                        "text": "In the call `result = add(5, 8);`, the numbers 5 and 8 are technically known as:",
                        "options": [
                            "Parameters",
                            "Arguments",
                            "Constants",
                            "Returns"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Actual values passed during a call are 'Arguments'. The variables receiving them in the definition are 'Parameters'."
                    },
                    {
                        "id": 3,
                        "text": "Which keyword is used to indicate that a function does not return any value?",
                        "options": [
                            "int",
                            "null",
                            "void",
                            "empty"
                        ],
                        "correctAnswer": 2,
                        "explanation": "'void' in the return type position tells the compiler that this function performs a task but provides no output value."
                    },
                    {
                        "id": 4,
                        "text": "If a function is declared as `int getVal();`, what is mandatory inside its definition?",
                        "options": [
                            "A printf statement",
                            "A return statement with an integer value",
                            "At least two parameters",
                            "A call to main()"
                        ],
                        "correctAnswer": 1,
                        "explanation": "A function with an 'int' return type must return an integer value back to the caller."
                    },
                    {
                        "id": 5,
                        "text": "When are parameters assigned their values?",
                        "options": [
                            "When the program starts",
                            "When the function is declared",
                            "When the function is called",
                            "When the compiler runs"
                        ],
                        "correctAnswer": 2,
                        "explanation": "Parameters are assigned (or 'passed') the values of the arguments at the exact moment the function is called."
                    }
                ]
            },
            {
                "id": "c20",
                "title": "Lesson 20: Types of Functions",
                "duration": "40 mins",
                "content": "Functions can be classified into four types based on whether they take **Arguments** (Input) and whether they send back a **Return Value** (Output). Understanding these differences helps you decide how to structure your code efficiently.\n\n---\n\n## 1. No Arguments and No Return Value\n\nThis type of function neither accepts data from the calling function nor sends any value back. It is typically used for simple tasks like printing a fixed message.\n\n### Syntax\n```c\nvoid function_name();\n```\n\n### Example\n```c\n#include <stdio.h>\n\nvoid greet(); // Declaration\n\nint main() {\n    greet(); // Call\n    return 0;\n}\n\n// Definition\nvoid greet() {\n    printf(\"Hello, Welcome to C Programming!\\n\");\n}\n```\n\n**Expected Output:**\n```text\nHello, Welcome to C Programming!\n```\n\n**How it Works**\n- `main()` calls `greet()`, but passes no data.\n- `greet()` executes its code (printing the message) and finishes.\n- Control returns to `main()` without carrying any value back.\n\n---\n\n## 2. No Arguments and With Return Value\n\nThis function doesn't take input but sends a result back to the caller. This is useful when a function generates a value internally (like reading a sensor or getting user input).\n\n### Syntax\n```c\nint function_name();\n```\n\n### Example\n```c\n#include <stdio.h>\n\nint getNumber();\n\nint main() {\n    int num = getNumber();\n    printf(\"Number received: %d\", num);\n    return 0;\n}\n\nint getNumber() {\n    return 100; // Returns 100 to the caller\n}\n```\n\n**Expected Output:**\n```text\nNumber received: 100\n```\n\n**How it Works**\n- `getNumber()` is called without arguments.\n- It executes and returns the integer `100`.\n- `main()` receives this value and stores it in the variable `num`.\n\n---\n\n## 3. With Arguments and No Return Value\n\nThis function accepts input data to perform a task but returns nothing. It allows you to pass data *into* the function.\n\n### Syntax\n```c\nvoid function_name(int arg);\n```\n\n### Example\n```c\n#include <stdio.h>\n\nvoid printSum(int a, int b);\n\nint main() {\n    printSum(10, 20);\n    return 0;\n}\n\nvoid printSum(int a, int b) {\n    printf(\"Sum: %d\", a + b);\n}\n```\n\n**Expected Output:**\n```text\nSum: 30\n```\n\n**How it Works**\n- `main()` passes the values `10` and `20` to `printSum`.\n- The function receives them as `a` and `b`.\n- It calculates `10 + 20` and prints `30` directly.\n- It returns nothing (`void`) to `main()`.\n\n---\n\n## 4. With Arguments and With Return Value\n\nThis is the most strictly \"functional\" type. It takes input, processes it, and returns the result. This is ideal for calculations.\n\n### Syntax\n```c\nint function_name(int arg);\n```\n\n### Example\n```c\n#include <stdio.h>\n\nint multiply(int a, int b);\n\nint main() {\n    int product = multiply(5, 4);\n    printf(\"Product: %d\", product);\n    return 0;\n}\n\nint multiply(int a, int b) {\n    return a * b;\n}\n```\n\n**Expected Output:**\n```text\nProduct: 20\n```\n\n**How it Works**\n- `main()` sends `5` and `4` to `multiply`.\n- `multiply()` calculates `5 * 4 = 20`.\n- It returns `20` back to `main()`, which is stored in `product`.\n\n---\n\n## Summary Table\n\n| Type | Input (Args) | Output (Return) | Example Use Case |\n| :--- | :--- | :--- | :--- |\n| **1. No Arg / No Return** |  No |  No | Displaying a menu or welcome message |\n| **2. No Arg / With Return** |  No |  Yes | Getting a random number or user input |\n| **3. With Arg / No Return** |  Yes |  No | Displaying formatted data |\n| **4. With Arg / With Return** |  Yes |  Yes | Mathematical calculations |",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Which function type returns a value but takes no arguments?",
                        "options": [
                            "No Arguments, No Return",
                            "With Arguments, With Return",
                            "No Arguments, With Return",
                            "With Arguments, No Return"
                        ],
                        "correctAnswer": 2,
                        "explanation": "The 'No Arguments, With Return' type does not accept input but sends a result back to the caller."
                    },
                    {
                        "id": 2,
                        "text": "In the function declaration `void printSum(int a, int b);`, what does `void` indicate?",
                        "options": [
                            "The function takes no arguments",
                            "The function returns an integer",
                            "The function returns nothing",
                            "The function is empty"
                        ],
                        "correctAnswer": 2,
                        "explanation": "`void` as the return type specifies that the function does not return any value to the caller."
                    },
                    {
                        "id": 3,
                        "text": "Which type of function is `int square(int n);`?",
                        "options": [
                            "No Arguments, With Return",
                            "With Arguments, No Return",
                            "With Arguments, With Return",
                            "No Arguments, No Return"
                        ],
                        "correctAnswer": 2,
                        "explanation": "It takes an argument (`int n`) and returns a value (`int`), so it is 'With Arguments, With Return'."
                    },
                    {
                        "id": 4,
                        "text": "If a function is declared as `void greet();`, is `int x = greet();` valid?",
                        "options": [
                            "Yes, x will be 0",
                            "No, it will cause a compilation error",
                            "Yes, x will be undefined",
                            "Yes, if greet returns a number"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Since `greet` is `void` (returns nothing), you cannot assign its result to a variable. This causes a compilation error."
                    },
                    {
                        "id": 5,
                        "text": "What is the best function type for calculating the area of a circle where you provide the radius and need the area back?",
                        "options": [
                            "With Arguments, With Return",
                            "With Arguments, No Return",
                            "No Arguments, With Return",
                            "No Arguments, No Return"
                        ],
                        "correctAnswer": 0,
                        "explanation": "You need to provide input (radius) and receive output (area), so 'With Arguments, With Return' is the correct choice."
                    }
                ]
            },
            {
                "id": "c21",
                "title": "Lesson 21: Call by Value vs. Call by Reference",
                "duration": "35 mins",
                "content": "When you pass a variable to a function, C needs to know how to handle the data. There are two primary ways: **Call by Value** (the default) and **Call by Reference** (using pointers).\n\n---\n\n## Call by Value (Copying)\n\nIn Call by Value, the function receives a **copy** of the variable's value. It does NOT get the original variable itself.\n\n### Key Facts\n-   **Safe**: The original variable in `main()` cannot be accidentally changed.\n-   **Memory**: Uses more memory for large data because it creates copies.\n-   **Default**: This is how C normally passes data (int, float, char).\n\n### Example: The Failed Attempt\n\n```c\n#include <stdio.h>\n\nvoid changeValue(int x) {\n    x = 100;\n}\n\nint main() {\n    int num = 10;\n    changeValue(num);\n    printf(\"num is still: %d\", num);\n    return 0;\n}\n```\n\n### Expected Output\n\n```text\nnum is still: 10\n```\n\n**Why it failed?**\n> The function `changeValue` got a copy of `10`. It changed its local `x` to `100`, but the original `num` in `main()` remained untouched.\n\n---\n\n## Call by Reference (Sharing)\n\nIn Call by Reference, you pass the **address** of the variable to the function using a pointer. The function now knows exactly where the original variable lives in memory.\n\n### Key Facts\n-   **Powerful**: Allows a function to modify the caller's variables.\n-   **Efficient**: No copying needed (great for large structures or arrays).\n-   **Pointers**: Requires using `*` (dereference) inside the function.\n\n### Example: The Success\n\n```c\n#include <stdio.h>\n\nvoid actualChange(int *ptr) {\n    *ptr = 100; // Go to the address and change it\n}\n\nint main() {\n    int num = 10;\n    actualChange(&num); // Pass the address\n    printf(\"num is now: %d\", num);\n    return 0;\n}\n```\n\n### Expected Output\n\n```text\nnum is now: 100\n```\n\n---\n\n## The Classic Example: Swapping\n\nSwapping two numbers is the standard way to understand the difference. To swap two variables in `main()` from inside a function, you **MUST** use Call by Reference.\n\n```c\n#include <stdio.h>\n\n// Correct Swapping using Pointers\nvoid swap(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint main() {\n    int x = 10, y = 20;\n    swap(&x, &y);\n    printf(\"x: %d, y: %d\", x, y);\n    return 0;\n}\n```\n\n### Expected Output\n\n```text\nx: 20, y: 10\n```\n\n---\n\n## Quick Comparison\n\n| Feature | Call by Value | Call by Reference |\n| :--- | :--- | :--- |\n| **Arguments** | Copies are passed | Addresses are passed |\n| **Modification** | Original stays safe | Original is changed |\n| **Syntax** | Normal variables | Pointers (`*`) and Addresses (`&`) |\n| **Performance** | Slower for big data | Faster (no copying) |\n\n---\n\n## Key Takeaways\n- Use **Call by Value** when you just need to *read* data.\n- Use **Call by Reference** when you need to *modify* or return multiple values.\n- Arrays in C are always passed by reference (decay to pointers).",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What is the default way C passes integer arguments to a function?",
                        "options": [
                            "Call by Reference",
                            "Call by Value",
                            "Call by Address",
                            "Call by Global"
                        ],
                        "correctAnswer": 1,
                        "explanation": "C uses 'Call by Value' by default for all standard data types like int, float, and char, meaning it passes a copy of the data."
                    },
                    {
                        "id": 2,
                        "text": "To implement 'Call by Reference' in C, what must you pass to the function?",
                        "options": [
                            "The variable name",
                            "A copy of the value",
                            "The memory address of the variable",
                            "The variable type"
                        ],
                        "correctAnswer": 2,
                        "explanation": "Call by reference requires passing the address (using & operator) so the function can access the original memory location."
                    },
                    {
                        "id": 3,
                        "text": "In Call by Value, if you modify a parameter inside the function, what happens to the original variable in main()?",
                        "options": [
                            "It changes to the new value",
                            "It remains unchanged",
                            "It becomes zero",
                            "The program crashes"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Because the function is working on a separate copy, changes made inside the function do not affect the original variable."
                    },
                    {
                        "id": 4,
                        "text": "What does the `swap(int *a, int *b)` function header indicate?",
                        "options": [
                            "It swaps two values using Call by Value",
                            "It takes two pointers and uses Call by Reference",
                            "It is a recursive function",
                            "It returns an integer"
                        ],
                        "correctAnswer": 1,
                        "explanation": "The asterisks (*) indicate that the function accepts pointers, which is the mechanism for Call by Reference in C."
                    },
                    {
                        "id": 5,
                        "text": "Which of these is a benefit of using Call by Reference?",
                        "options": [
                            "It is always safer for calculations",
                            "It avoids creating large copies of data in memory",
                            "It makes variables global automatically",
                            "It doesn't require any special syntax"
                        ],
                        "correctAnswer": 1,
                        "explanation": "By passing only the address (usually 4 or 8 bytes), you avoid copying large amounts of data, making the program more memory-efficient."
                    }
                ]
            },
            {
                "id": "c22",
                "title": "Lesson 22: Recursion in C",
                "duration": "60 mins",
                "content": "Recursion is one of the most elegant and powerful concepts in computer science. It occurs when a function calls itself, directly or indirectly, to solve a complex problem by breaking it down into smaller, manageable sub-problems.\n\n---\n\n## Anatomy of Recursion\n\nEvery recursive function MUST have two essential parts. Without these, your program will either not work or crash.\n\n### Base Case (The Exit Strategy)\nThis is the stopping condition. It tells the function when to stop calling itself and start returning values. Without a base case, recursion continues forever, leading to a **Stack Overflow**.\n\n### Recursive Case (The Logic)\nThis is the part where the function calls itself, but with a **reduced** or modified input that brings it closer to the base case.\n\n```c\nvoid count(int n) {\n    if (n <= 0) {       //  Base Case\n        return;\n    }\n    printf(\"%d \", n);\n    count(n - 1);       //  Recursive Case\n}\n```\n\n---\n\n## How it Works: The Call Stack\n\nTo understand recursion, you must understand the **Call Stack**. Each time a function is called, C creates an \"Activation Record\" (or Stack Frame) in memory to store its local variables and return address.\n\n### ️ Winding & Unwinding Phase\n1.  **Winding Phase**: The function keeps calling itself, pushing new frames onto the stack. No work is finished yet.\n2.  **Unwinding Phase**: Once the base case is hit, the stack begins to \"pop\" (remove) frames one by one, returning results back up the chain.\n\n> [!CAUTION]\n> **Stack Overflow**: If your recursion is too deep (e.g., calling a function 1 million times), the stack memory runs out, and your program crashes instantly.\n\n---\n\n## Types of Recursion\n\nProfessionals distinguish between different \"flavors\" of recursion:\n\n### Direct vs Indirect\n- **Direct**: Function A calls Function A.\n- **Indirect**: Function A calls Function B, which then calls Function A. They form a circular chain.\n\n### Tail vs Non-Tail Recursion\n- **Tail Recursion**: The recursive call is the **very last** thing the function does. There is no pending work after the call. This is highly efficient because some compilers can optimize it into a simple loop.\n- **Non-Tail Recursion**: There is still code to execute (like a calculation or print) *after* the recursive call returns.\n\n---\n\n## Iconic Examples\n\n### Example: Calculating Factorial (Mathematical)\nFactorial of $n$ ($n!$) is $n \\times (n-1) \\times (n-2) \\dots \\times 1$.\n\n```c\nint factorial(int n) {\n    if (n == 0 || n == 1) return 1; // Base case\n    return n * factorial(n - 1);    // Recursive case\n}\n```\n\n### Example: Fibonacci Sequence (Multiple Recursion)\nEach number is the sum of the two preceding ones: 0, 1, 1, 2, 3, 5, 8...\n\n```c\nint fib(int n) {\n    if (n <= 1) return n;         // Base cases (0 and 1)\n    return fib(n-1) + fib(n-2);   // Two recursive calls!\n}\n```\n\n---\n\n## Recursion vs Iteration\n\n| Feature | Recursion | Iteration (Loops) |\n| :--- | :--- | :--- |\n| **Performance** | Slower (Function call overhead) | Faster (Direct execution) |\n| **Memory** | Higher (Uses Stack memory) | Lower (Uses fixed memory) |\n| **Readability** | Elegant for complex structures | Clear for simple counting |\n| **Failure** | Can cause Stack Overflow | Can cause Infinite Loops |\n\n---\n\n## Key Takeaways\n- Always ensure your input **progresses** towards the base case.\n- Use recursion for problems that are \"recursive by nature\" (like Tree traversal or Factorials).\n- For simple counting or linear tasks, prefer loops to save memory.\n",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What is the result of missing a base case in a recursive function?",
                        "options": [
                            "The program finishes faster",
                            "Stack Overflow error",
                            "Syntax error during compilation",
                            "The function returns 0 automatically"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Without a base case, the function calls itself infinitely, filling up the call stack until memory runs out, causing a stack overflow."
                    },
                    {
                        "id": 2,
                        "text": "In recursion, what is the 'Unwinding Phase'?",
                        "options": [
                            "The phase where new functions are pushed to the stack",
                            "The phase where functions reach the base case and start returning",
                            "The compiler optimizing the code",
                            "The initialization of local variables"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Unwinding is the process where functions finish their execution and return values back to their callers, 'popping' their records off the stack."
                    },
                    {
                        "id": 3,
                        "text": "Which type of recursion is generally easier for a compiler to optimize?",
                        "options": [
                            "Direct Recursion",
                            "Non-Tail Recursion",
                            "Tail Recursion",
                            "Indirect Recursion"
                        ],
                        "correctAnswer": 2,
                        "explanation": "Tail recursion is optimized by many compilers because the recursive call is the final action, allowing the compiler to reuse the current stack frame instead of creating a new one."
                    },
                    {
                        "id": 4,
                        "text": "What is the value of fib(4) in the Fibonacci sequence (starting 0, 1, 1, 2, 3...)?",
                        "options": [
                            "2",
                            "3",
                            "5",
                            "8"
                        ],
                        "correctAnswer": 1,
                        "explanation": "fib(0)=0, fib(1)=1, fib(2)=1, fib(3)=2, fib(4)=3."
                    },
                    {
                        "id": 5,
                        "text": "Which is a major disadvantage of recursion compared to iteration?",
                        "options": [
                            "It is always more complex to write",
                            "It uses more memory due to stack frames",
                            "It cannot be used with integers",
                            "It requires a 64-bit computer"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Each recursive call adds a new layer to the stack memory. For very deep recursion, this uses significantly more memory than a simple for/while loop."
                    }
                ]
            },
            {
                "id": "c23",
                "title": "Lesson 23: Scope of Variables",
                "duration": "30 mins",
                "content": "Scope refers to the region of the program where a specific variable is visible and can be used. If you try to access a variable outside its scope, the compiler will return an error because it \"doesn't exist\" there.\n\nIn C, there are two primary scopes you need to understand:\n1.  **Local Variables**\n2.  **Global Variables**\n\n---\n\n## Local Variables\n\n### Definition\nA variable declared **inside** a function or a block `{ }` is called a local variable.\n\n### Key Characteristics\n-   **Visibility**: Only visible inside the function/block where they are created.\n-   **Lifetime**: Created when the function starts, destroyed when it ends.\n-   **Safety**: Other functions cannot accidentally change them.\n\n### Syntax\n```c\nvoid function_name() {\n    int x; // x is local to this function\n}\n```\n\n### Example: Local Scope\n\n```c\n#include <stdio.h>\n\nvoid fun() {\n    int x = 10; // Local variable\n    printf(\"Inside fun(): x = %d\\n\", x);\n}\n\nint main() {\n    fun();\n\n    // printf(\"%d\", x); //  Error: x is not known here\n    return 0;\n}\n```\n\n**Expected Output:**\n```text\nInside fun(): x = 10\n```\n\n** How it Works:**\n- `x` is created when `fun()` is called.\n- Inside `fun()`, we can print `x`.\n- Once `fun()` finishes, `x` is deleted from memory.\n- `main()` cannot see `x`, so trying to print it would cause an error.\n\n---\n\n## Global Variables\n\n### Definition\nA variable declared **outside** of all functions (usually at the top of the file) is called a global variable.\n\n### Key Characteristics\n-   **Visibility**: Visible to **all** functions in the program.\n-   **Lifetime**: Stays in memory as long as the program is running.\n-   **Risk**: Any function can change its value, which can lead to bugs.\n\n### Syntax\n```c\nint g; // Declared outside any function\n\nint main() {\n    // ...\n}\n```\n\n### Example: Global Scope\n\n```c\n#include <stdio.h>\n\nint myScore = 100; // Global variable\n\nvoid displayScore() {\n    printf(\"Score inside function: %d\\n\", myScore);\n}\n\nint main() {\n    printf(\"Score inside main: %d\\n\", myScore);\n    displayScore();\n    return 0;\n}\n```\n\n**Expected Output:**\n```text\nScore inside main: 100\nScore inside function: 100\n```\n\n** How it Works:**\n- `myScore` is declared at the top, so it is Global.\n- `main()` can access `myScore`.\n- `displayScore()` can also access the exact same `myScore`.\n\n---\n\n## Local vs Global (Name Conflict)\n\n### ️ What if they have the same name?\nIf a local variable has the same name as a global variable, the **Local Variable takes priority** (it \"shadows\" the global one).\n\n### Example: Shadowing\n\n```c\n#include <stdio.h>\n\nint x = 50; // Global x\n\nint main() {\n    int x = 10; // Local x (Shadows global x)\n    printf(\"Value of x: %d\", x);\n    return 0;\n}\n```\n\n**Expected Output:**\n```text\nValue of x: 10\n```\n\n** How it Works:**\n- Generally, the compiler looks for variables nearby first.\n- Inside `main()`, it sees a local `x` (10), so it uses that.\n- It completely ignores the global `x` (50) inside this specific function.\n\n---\n\n## Comparison Summary\n\n| Feature | Local Variable | Global Variable |\n| :--- | :--- | :--- |\n| **Where to declare?** | Inside function/block | Outside all functions |\n| **Who can see it?** | Only that function | Everyone |\n| **When does it die?** | When function ends | When program ends |\n| **Default Value** | Garbage (random value) | Zero (0) |",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What happens if a local variable has the same name as a global variable?",
                        "options": [
                            "The program crashes",
                            "The global variable takes priority",
                            "The local variable takes priority",
                            "Both values are added together"
                        ],
                        "correctAnswer": 2,
                        "explanation": "When a local variable has the same name as a global variable, the local variable takes priority within its scope (shadowing the global variable)."
                    },
                    {
                        "id": 2,
                        "text": "Where can a global variable be accessed?",
                        "options": [
                            "Only inside main()",
                            "Only inside the function where it is declared",
                            "Anywhere in the program",
                            "Only inside loops"
                        ],
                        "correctAnswer": 2,
                        "explanation": "Global variables are declared outside of all functions and can be accessed from any function in the program."
                    },
                    {
                        "id": 3,
                        "text": "What is the lifetime of a local variable?",
                        "options": [
                            "The entire duration of the program",
                            "Only while the function it is in is executing",
                            "It is deleted immediately after declaration",
                            "It persists until the computer is turned off"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Local variables are created when the function enters and destroyed automatically when the function exits."
                    },
                    {
                        "id": 4,
                        "text": "Why is overuse of global variables generally discouraged?",
                        "options": [
                            "They take up too much memory",
                            "Any function can change them, leading to unpredictable bugs",
                            "They are slower to access",
                            "Compilers cannot handle them well"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Since any part of the program can modify a global variable, tracking who changed it becomes difficult, making debugging harder."
                    },
                    {
                        "id": 5,
                        "text": "If you declare `int x;` inside a function without initializing it, what is its value?",
                        "options": [
                            "0",
                            "1",
                            "Null",
                            "A garbage (random) value"
                        ],
                        "correctAnswer": 3,
                        "explanation": "In C, uninitialized local variables contain unpredictable 'garbage' values from memory."
                    }
                ]
            }
        ],
        "problems": [
            {
                "id": "c-l4-p1",
                "title": "Sum Function",
                "difficulty": "easy",
                "description": "Write a function `int add(int a, int b)` that returns the sum of two numbers. Call this function from `main` with inputs from the user.",
                "starter_code": "#include <stdio.h>\n\n// Declare function\n\nint main() {\n    int x, y;\n    // Read x and y\n    // Call add and print result\n    return 0;\n}\n\n// Define function",
                "test_cases": [
                    {
                        "stdin": "5 7",
                        "expected_output": "12"
                    }
                ]
            },
            {
                "id": "c-l4-p2",
                "title": "Square of a Number",
                "difficulty": "easy",
                "description": "Write a function `float square(float n)` that returns the square of a number. Print the result with 2 decimal places.",
                "starter_code": "#include <stdio.h>\n\n// Declare square function\n\nint main() {\n    float num;\n    // Read num\n    // Call square and print result\n    return 0;\n}\n\n// Define function",
                "test_cases": [
                    {
                        "stdin": "4",
                        "expected_output": "16.00"
                    }
                ]
            },
            {
                "id": "c-l4-p3",
                "title": "Check Prime Number",
                "difficulty": "medium",
                "description": "Write a function `int isPrime(int n)` that returns 1 if a number is prime and 0 otherwise. Use this in `main` to print 'Prime' or 'Not Prime'.",
                "starter_code": "#include <stdio.h>\n\n// Declare isPrime\n\nint main() {\n    int n;\n    // Read n\n    // Call isPrime and print 'Prime' or 'Not Prime'\n    return 0;\n}\n\n// Define function",
                "test_cases": [
                    {
                        "stdin": "7",
                        "expected_output": "Prime"
                    },
                    {
                        "stdin": "10",
                        "expected_output": "Not Prime"
                    }
                ]
            },
            {
                "id": "c-l4-p4",
                "title": "Power Function",
                "difficulty": "medium",
                "description": "Write a function `long long power(int base, int exp)` that calculates `base` raised to the power `exp` using a loop.",
                "starter_code": "#include <stdio.h>\n\n// Declare power function\n\nint main() {\n    int b, e;\n    // Read base and exponent\n    // Print result\n    return 0;\n}\n\n// Define function",
                "test_cases": [
                    {
                        "stdin": "2 3",
                        "expected_output": "8"
                    }
                ]
            },
            {
                "id": "c-l4-p5",
                "title": "Recursive Fibonacci",
                "difficulty": "hard",
                "description": "Write a recursive function `int fib(int n)` that returns the nth Fibonacci number (starting from 0, 1, 1, 2, 3...).",
                "starter_code": "#include <stdio.h>\n\n// Recursive function fib\n\nint main() {\n    int n;\n    // Read n\n    // Print nth fibonacci number\n    return 0;\n}\n\n// Define function",
                "test_cases": [
                    {
                        "stdin": "6",
                        "expected_output": "8"
                    }
                ]
            }
        ]
    },
    {
        "id": "c-l5",
        "title": "LEVEL 5: Pointers",
        "lessons": [
            {
                "id": "c24",
                "title": "Lesson 24: Pointers",
                "duration": "45 mins",
                "content": "Pointers are one of the most powerful and distinctive features of C. While normal variables store **values** (like `10` or `'A'`), pointers store **memory addresses** (like `0x7ffee4` or `1002`).\n\nUnderstanding pointers gives you direct control over memory, which is essential for advanced programming.\n\n---\n\n## The Concept of Memory\n\nEvery variable you declare lives at a specific location in your computer's memory (RAM). This location has a unique number called an **Address**.\n\n### Visualization\nImagine memory as a street with houses. Each house has an address.\n- **Variable**: The house itself.\n- **Value**: The people inside the house.\n- **Address**: The house number (e.g., House No. 104).\n\nIf you want to find the people (Value), you go to the address.\n\n---\n\n## Key Operators\n\nTo work with pointers, you need two special operators:\n\n### Address-of Operator (`&`)\nReturns the memory address of a variable.\n- Syntax: `&x` gives the address of x.\n\n### Dereference Operator (`*`)\nAccesses the value stored at a specific address.\n- Syntax: `*p` gives the value stored at the address `p`.\n\n---\n\n## Declaring and Using Pointers\n\n### Syntax\n```c\ndatatype *pointer_name;\n```\n- `int *p`: A pointer that stores the address of an integer.\n- `char *c`: A pointer that stores the address of a character.\n\n### Example: The Basics\n\n```c\n#include <stdio.h>\n\nint main() {\n    int num = 100;\n    int *ptr = &num; // ptr now holds the address of num\n\n    printf(\"Value of num: %d\\n\", num);\n    printf(\"Address of num: %p\\n\", &num);\n    printf(\"Value stored in ptr: %p\\n\", ptr);\n    printf(\"Value pointed to by ptr: %d\\n\", *ptr);\n\n    return 0;\n}\n```\n\n**Expected Output:**\n```text\nValue of num: 100\nAddress of num: 0061FF1C (This changes every run)\nValue stored in ptr: 0061FF1C\nValue pointed to by ptr: 100\n```\n\n** How it Works:**\n1.  `int num = 100;`: Creates an integer variable at address `X`.\n2.  `int *ptr = &num;`: Creates a pointer `ptr` and stores `X` in it.\n3.  `*ptr`: Goes to address `X` and reads the value `100`.\n\n---\n\n## The Syntax Confusion: `*` vs `*`\n\nThe asterisk `*` has two different meanings depending on where it is used. This is a common source of confusion!\n\n### A. In Declaration\nWhen you see `*` during variable creation, it means **\"I am a pointer\"**.\n\n```c\nint *p; // Create a pointer named p\n```\n\n### B. In Usage (Dereference)\nWhen you see `*` before an existing variable, it means **\"Go to the address\"**.\n\n```c\n*p = 50; // Go to the address in p and store 50\n```\n\n**Simple Rule:**\n- `int *p` -> Type definition (Noun)\n- `*p` -> Action (Verb)\n\n---\n\n## Pointer Size\n\nQ: How big is a pointer? \nA: It depends on your computer's architecture (CPU).\n\n- **32-bit system**: Pointers are **4 bytes** (32 bits).\n- **64-bit system**: Pointers are **8 bytes** (64 bits).\n\nInterestingly, `sizeof(char*)`, `sizeof(int*)`, and `sizeof(double*)` are **ALL THE SAME**. Why? Because they all store an address, and an address is just a number. The data type only tells the compiler *how much* data to read once it gets there.\n\n---\n\n## Modifying Values via Pointers\n\nYou can change a variable's value through its pointer using the dereference operator.\n\n```c\n#include <stdio.h>\n\nint main() {\n    int x = 10;\n    int *p = &x;\n\n    *p = 20; // Go to address 'p' and put 20 there\n    \n    printf(\"x is now: %d\", x);\n    return 0;\n}\n```\n\n**Expected Output:**\n```text\nx is now: 20\n```\n\n---\n\n## Common Pitfalls: Wild Pointers\n\nNever declare a pointer without initializing it!\n\n```c\nint *p; // DANGER! Points to a random random memory location\n*p = 10; // CRASH! You just wrote to an unknown address\n```\n\n**Best Practice**: Always initialize to `NULL` if you don't have an address yet.\n```c\nint *ptr = NULL; // Safe\n```\n\n---\n\n## Key Takeaways\n- **& (Ampersand)**: Get the address.\n- **\\* (Asterisk)**: Get the value at the address.\n- **Size**: All pointers are the same size (4 or 8 bytes) regardless of type.\n- **Safety**: Uninitialized pointers are dangerous. Use `NULL`.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What does the `&` operator return?",
                        "options": [
                            "The value of a variable",
                            "The memory address of a variable",
                            "The size of a variable",
                            "The data type of a variable"
                        ],
                        "correctAnswer": 1,
                        "explanation": "The & (ampersand) is the 'Address-of' operator. &x returns the memory location where x is stored."
                    },
                    {
                        "id": 2,
                        "text": "If `int x = 10;` and `int *p = &x;`, what is the value of `*p`?",
                        "options": [
                            "The address of x",
                            "10",
                            "Garbage value",
                            "0"
                        ],
                        "correctAnswer": 1,
                        "explanation": "`*p` (Dereference) goes to the address stored in p (which is x's address) and retrieves the value stored there (10)."
                    },
                    {
                        "id": 3,
                        "text": "What is proper syntax to declare a pointer to an integer?",
                        "options": [
                            "pointer int p;",
                            "int p*;",
                            "int *p;",
                            "int &p;"
                        ],
                        "correctAnswer": 2,
                        "explanation": "The correct syntax is `datatype *name;`. For example, `int *p;`."
                    },
                    {
                        "id": 4,
                        "text": "What happens if you try to dereference a NULL pointer?",
                        "options": [
                            "It returns 0",
                            "It creates a new variable",
                            "The program crashes (Segmentation Fault)",
                            "It returns a random value"
                        ],
                        "correctAnswer": 2,
                        "explanation": "A NULL pointer leads to nowhere. Attempting to read/write to address 0 causes the OS to stop the program for safety."
                    },
                    {
                        "id": 5,
                        "text": "Which statement sets the value of x to 50 using pointer p (where p = &x)?",
                        "options": [
                            "p = 50;",
                            "&p = 50;",
                            "*p = 50;",
                            "p* = 50;"
                        ],
                        "correctAnswer": 2,
                        "explanation": "`*p = 50` means 'Go to the address p points to, and store 50 there'. `p = 50` would change the address itself."
                    }
                ]
            },
            {
                "id": "c25",
                "title": "Lesson 25: Pointer Arithmetic",
                "duration": "35 mins",
                "content": "Pointers don't just point to fixed memory locations; they can effectively \"move\" through memory. This is called **Pointer Arithmetic**, and it is the foundation of how C handles arrays and strings efficiently.\n\n---\n\n## How Pointers Move (Scaling)\n\nWhen you add `1` to a pointer (`ptr++`), it doesn't just increase the address by 1 byte. C automatically scales the movement based on the **size of the data type** it points to.\n\n- **char** pointer increments by **1 byte**.\n- **int** pointer increments by **4 bytes** (usually).\n- **double** pointer increments by **8 bytes**.\n\n### Example: Scaling Visualization\n```c\n#include <stdio.h>\n\nint main() {\n    int num = 10;\n    int *ptr = &num;\n\n    printf(\"Initial Address: %p\\n\", ptr);\n    ptr++; // Moves to next integer slot\n    printf(\"After ptr++:     %p\\n\", ptr);\n\n    return 0;\n}\n```\n\n**Expected Output:**\n```text\nInitial Address: 0061FF10\nAfter ptr++:     0061FF14 (Notice the +4 jump)\n```\n\n---\n\n## Supported Operations\n\nC allows only specific arithmetic operations on pointers:\n\n### Addition (`ptr + n`)\nMoves the pointer `n` positions forward in memory.\n\n### Subtraction (`ptr - n`)\nMoves the pointer `n` positions backward in memory.\n\n### Distance (`ptr2 - ptr1`)\nSubtracting two pointers of the **same type** gives the number of **elements** (not bytes) between them.\n\n---\n\n## Pointer Comparison\n\nYou can compare two pointers using relational operators (`<`, `>`, `==`, etc.). This is useful when you want to check if a pointer is within the bounds of an array or if two pointers point to the same location.\n\n```c\nif (p1 == p2) {\n    printf(\"Both point to the same address\");\n}\n\nif (p1 > p2) {\n    printf(\"p1 is further ahead in memory than p2\");\n}\n```\n\n---\n\n## Illegal Operations \n\nNot everything is allowed in pointer arithmetic. You **CANNOT**:\n- Add two pointers (`ptr1 + ptr2` is illegal).\n- Multiply or divide pointers.\n- Add a floating-point number to a pointer.\n\n---\n\n## Practical Use: Array Traversal\n\nUsing pointer arithmetic, you can access array elements without using the square bracket `[]` syntax.\n\n```c\n#include <stdio.h>\n\nint main() {\n    int arr[] = {10, 20, 30};\n    int *p = arr; // Points to first element\n\n    for(int i = 0; i < 3; i++) {\n        printf(\"Element %d: %d\\n\", i, *(p + i));\n    }\n    return 0;\n}\n```\n\n** How it Works:**\n- `*(p + 0)` is the same as `arr[0]`.\n- `*(p + 1)` moves forward 4 bytes to `arr[1]`.\n- `*(p + 2)` moves forward 8 bytes to `arr[2]`.\n\n---\n\n## Key Takeaways\n- **Scaling**: Movement is proportional to the size of the data type.\n- **Distance**: Subtraction returns the count of items between pointers.\n- **Bounds**: Always ensure your arithmetic doesn't move the pointer outside valid memory bounds.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "If `int` is 4 bytes, and pointer `p` is at address 1000, what is the address after `p++`?",
                        "options": [
                            "1001",
                            "1004",
                            "1008",
                            "1002"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Since `int` takes 4 bytes, incrementing an int pointer moves it forward by 4 memory locations (1000 -> 1004)."
                    },
                    {
                        "id": 2,
                        "text": "Subtracting two pointers (`ptr2 - ptr1`) results in:",
                        "options": [
                            "The sum of their addresses",
                            "The number of bytes between them",
                            "The number of elements between them",
                            "A compilation error"
                        ],
                        "correctAnswer": 2,
                        "explanation": "Pointer subtraction returns the number of elements fitting between the two addresses, not the raw byte count."
                    },
                    {
                        "id": 3,
                        "text": "If you have `char *c` at 2000, what is the address of `c + 2`?",
                        "options": [
                            "2001",
                            "2002",
                            "2004",
                            "2008"
                        ],
                        "correctAnswer": 1,
                        "explanation": "`char` is 1 byte. Adding 2 moves the pointer by 2 * 1 = 2 bytes. 2000 + 2 = 2002."
                    },
                    {
                        "id": 4,
                        "text": "Which of the following operations is ILLEGAL on pointers?",
                        "options": [
                            "ptr + 5",
                            "ptr1 - ptr2",
                            "ptr1 + ptr2",
                            "ptr--"
                        ],
                        "correctAnswer": 2,
                        "explanation": "Adding two pointers is illegal in C because the result would be a memory address that has no logical meaning."
                    },
                    {
                        "id": 5,
                        "text": "If `ptr1` points to `arr[0]` and `ptr2` points to `arr[5]`, what is the result of `ptr1 < ptr2`?",
                        "options": [
                            "1 (True)",
                            "0 (False)",
                            "Compilation Error",
                            "Random value"
                        ],
                        "correctAnswer": 0,
                        "explanation": "Relational operators work on pointers. Since `arr[0]` comes before `arr[5]` in memory, `ptr1 < ptr2` is true (evaluates to 1)."
                    }
                ]
            },
            {
                "id": "c26",
                "title": "Lesson 26: Pointers & Arrays",
                "duration": "40 mins",
                "content": "In C, arrays and pointers are so closely related that they are often used interchangeably. However, understanding their subtle differences is key to mastering memory management.\n\n---\n\n## The Decay Rule\n\nThe name of an array acts as a **constant pointer** to its first element. When you use an array name in an expression, it \"decays\" into a pointer.\n\n```c\nint arr[3] = {10, 20, 30};\nint *p = arr; // Equivalent to p = &arr[0];\n```\n\n### Visualization\nImagine `arr` is the starting point of a block of memory. \n- `arr` is the address of the first house.\n- `arr + 1` is the address of the next house (4 bytes away if it's an int).\n\n---\n\n## Notation Equivalence\n\nYou can access array elements using either indexing `[]` or pointer notation `*`. They are exactly the same in C.\n\n| Index Notation | Pointer Notation | Result |\n| :--- | :--- | :--- |\n| `arr[0]` | `*arr` | 10 |\n| `arr[1]` | `*(arr + 1)` | 20 |\n| `arr[i]` | `*(arr + i)` | Value at index i |\n\n### Fun Fact: `i[arr]`\nBecause `arr + i` is the same as `i + arr`, the syntax `i[arr]` is also valid! \n`2[arr]` is same as `arr[2]`. While valid, it is usually avoided for clarity.\n\n---\n\n## Arrays as Function Arguments\n\nWhen you pass an array to a function, C **always** passes it as a pointer. This is why the function doesn't know the size of the array unless you pass it as a second argument.\n\n```c\nvoid printArray(int *ptr, int size) {\n    for(int i = 0; i < size; i++) {\n        printf(\"%d \", *(ptr + i));\n    }\n}\n```\n\n---\n\n## Array Name vs. Pointer Variable\n\nWhile they behave similarly, there is one giant difference: **An array name is a constant, while a pointer is a variable.**\n\n```c\nint arr[5];\nint *p = arr;\n\np++;   //  LEGAL: p is a variable that stores an address\narr++; //  ILLEGAL: arr is the name of the memory block\n```\n\n---\n\n## The `sizeof` Distinction\n\nThis is a common interview trap:\n- `sizeof(array)` returns the size of the **entire block**.\n- `sizeof(pointer)` returns the size of the **address** (usually 8 bytes on 64-bit systems).\n\n```c\nint arr[10]; // 10 ints * 4 bytes = 40 bytes\nint *p = arr;\n\nprintf(\"Array size: %zu\\n\", sizeof(arr));   // Output: 40\nprintf(\"Pointer size: %zu\\n\", sizeof(p));   // Output: 8\n```\n\n---\n\n## Key Takeaways\n- **Decay**: Arrays decay to pointers when used or passed to functions.\n- **Constant**: You cannot change where an array name points (`arr++` fails).\n- **Size**: `sizeof` behaves differently for arrays vs. pointers.\n- **Access**: `arr[i]` is just a shortcut for `*(arr + i)`.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Which expression is equivalent to `arr[2]`?",
                        "options": [
                            "*(arr + 2)",
                            "*arr + 2",
                            "&arr + 2",
                            "arr + 2"
                        ],
                        "correctAnswer": 0,
                        "explanation": "`arr[2]` accesses the value at index 2. In pointer notation, this is `*(arr + 2)`."
                    },
                    {
                        "id": 2,
                        "text": "What is the relationship between an array name and a pointer?",
                        "options": [
                            "They are unrelated",
                            "An array name acts as a constant pointer to the first element",
                            "A pointer is always larger",
                            "Array names cannot be used as pointers"
                        ],
                        "correctAnswer": 1,
                        "explanation": "In most contexts, the array name evaluates to the address of the first element (it decays to a pointer)."
                    },
                    {
                        "id": 3,
                        "text": "Why is `arr++` illegal if `arr` is an array name?",
                        "options": [
                            "Because arrays are too large",
                            "Because array names are constant pointers",
                            "Because pointers cannot be incremented",
                            "It is actually legal"
                        ],
                        "correctAnswer": 1,
                        "explanation": "An array name is a label for a fixed block of memory. You cannot change what address it refers to."
                    },
                    {
                        "id": 4,
                        "text": "If an array `int arr[5]` is passed to a function, what does `sizeof(arr)` inside the function return?",
                        "options": [
                            "20 bytes (total array size)",
                            "The size of a pointer (4 or 8 bytes)",
                            "5 (number of elements)",
                            "0"
                        ],
                        "correctAnswer": 1,
                        "explanation": "When passed to a function, an array decays to a pointer. `sizeof` will therefore return the size of that pointer, not the original array."
                    },
                    {
                        "id": 5,
                        "text": "Is `i[arr]` a valid expression in C?",
                        "options": [
                            "No, it's a syntax error",
                            "Yes, it's equivalent to arr[i]",
                            "Only for character arrays",
                            "Only in C++"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Because internally `arr[i]` is `*(arr + i)`, and addition is commutative, `i[arr]` (which is `*(i + arr)`) works perfectly."
                    }
                ]
            },
            {
                "id": "c27",
                "title": "Lesson 27: Advanced Pointers (Pointer to Pointer)",
                "duration": "45 mins",
                "content": "Pointers allow us to manipulate memory addresses. But what happens when we need to store the address of a pointer itself? This is known as **Multiple Indirection** or a **Double Pointer**.\n\n---\n\n## The Chain of Indirection\n\nTo understand a double pointer, think of a chain where each level points to the next:\n\n1.  **Level 0 (Value)**: An actual data value (e.g., `int x = 10;`).\n2.  **Level 1 (Pointer)**: Stores the address of the value (`int *p1 = &x;`).\n3.  **Level 2 (Double Pointer)**: Stores the address of the pointer (`int **p2 = &p1;`).\n\n### Visualization\nSuppose memory addresses are simplified numbers:\n- `x` is at address `1000`, value is `10`.\n- `p1` is at address `2000`, value is `1000` (address of x).\n- `p2` is at address `3000`, value is `2000` (address of p1).\n\nTo get back to `10` using `p2`, you use two asterisks: `**p2` (Go to 2000, then go to 1000, find 10).\n\n---\n\n## Why Use Double Pointers?\n\nWhile they seem complex, double pointers are essential for two main tasks in C:\n\n### A. Modifying a Pointer inside a Function\nIn C, if you pass a pointer to a function, the function receives a **copy** of that pointer. If you want the function to change where the *original* pointer in the caller points, you must pass its address.\n\n```c\nvoid allocateValue(int **ptr) {\n    static int val = 50;\n    *ptr = &val; // Modifies the original pointer to point to 'val'\n}\n\nint main() {\n    int *p = NULL;\n    allocateValue(&p); // Pass address of the pointer\n    printf(\"%d\", *p); // Output: 50\n}\n```\n\n### B. Dynamic 2D Arrays\nA 2D array can be managed as an \"array of pointers.\" In this case, each element of an array is a pointer to another array (a row). To store the address of such an array of pointers, you need a double pointer.\n\n```c\nint **matrix = malloc(rows * sizeof(int *));\nfor(int i = 0; i < rows; i++) {\n    matrix[i] = malloc(cols * sizeof(int));\n}\n```\n\n---\n\n## Beyond Double Pointers\n\nCan you have `int ***p`? **Yes**. This is a **Triple Pointer** (Pointer to a Pointer to a Pointer). While C allows any number of levels (`****p`), anything beyond 2 or 3 levels is rarely used because it becomes extremely difficult to read and manage.\n\n---\n\n## Key Takeaways\n- **Syntax**: `int **p` is a pointer that points to another `int *`.\n- **Dereferencing**: `**p` gives the final integer value.\n- **Functions**: Use double pointers to let a function modify a pointer defined in `main`.\n- **2D Memory**: Essential for creating dynamic matrices and complex data structures.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What does `int **p;` declare?",
                        "options": [
                            "A pointer to an integer",
                            "A pointer to a pointer to an integer",
                            "A function returning an integer",
                            "Two integer pointers"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Two asterisks (`**`) indicate a pointer to a pointer. It holds the address of another pointer variable."
                    },
                    {
                        "id": 2,
                        "text": "If `p2` is a double pointer and `*p2` is a pointer, what does `**p2` represent?",
                        "options": [
                            "An address of a pointer",
                            "An address of a variable",
                            "The final value stored in the variable",
                            "A compilation error"
                        ],
                        "correctAnswer": 2,
                        "explanation": "Double dereferencing (`**`) follows both addresses in the chain to reach the actual data value."
                    },
                    {
                        "id": 3,
                        "text": "Why would you pass `&ptr` (address of a pointer) to a function?",
                        "options": [
                            "To make the function run faster",
                            "To allow the function to change where the original 'ptr' points",
                            "To protect the pointer from being changed",
                            "Because C requires it for all pointers"
                        ],
                        "correctAnswer": 1,
                        "explanation": "To modify a variable (even a pointer) in the caller's scope, you must pass its address. For a pointer variable, that means passing a double pointer."
                    },
                    {
                        "id": 4,
                        "text": "What is the correct way to initialize a double pointer `pp` to point to pointer `p`?",
                        "options": [
                            "pp = p;",
                            "pp = *p;",
                            "pp = &p;",
                            "*pp = &p;"
                        ],
                        "correctAnswer": 2,
                        "explanation": "Since `pp` stores the address of a pointer, you must use the address-of operator `&` on the pointer `p`."
                    },
                    {
                        "id": 5,
                        "text": "Is there a limit to the levels of indirection (e.g., `*****p`) in C?",
                        "options": [
                            "Yes, maximum 2 levels",
                            "Yes, maximum 3 levels",
                            "No, but excessive levels are rare and hard to read",
                            "Only pointers to integers can have multiple levels"
                        ],
                        "correctAnswer": 2,
                        "explanation": "C allows multiple levels of indirection, though more than 3 is rarely seen in professional code."
                    }
                ]
            }
        ],
        "problems": [
            {
                "id": "c-l5-p1",
                "title": "Swap with Pointers",
                "difficulty": "easy",
                "description": "Write a function `void swap(int *a, int *b)` that swaps the values of two variables using pointers.",
                "starter_code": "#include <stdio.h>\n\n// Declare swap\n\nint main() {\n    int x, y;\n    // Read x and y\n    // Swap x and y using swap(&x, &y)\n    // Print swapped x and y\n    return 0;\n}\n\n// Define swap",
                "test_cases": [
                    {
                        "stdin": "10 20",
                        "expected_output": "20 10"
                    }
                ]
            },
            {
                "id": "c-l5-p2",
                "title": "Pointer to Max",
                "difficulty": "easy",
                "description": "Write a function that takes two integer pointers and returns a pointer to the larger value.",
                "starter_code": "#include <stdio.h>\n\nint* findMax(int *a, int *b) {\n    // Return pointer to larger value\n}\n\nint main() {\n    int x, y;\n    // Read x, y\n    // Call findMax and print the value it points to\n    return 0;\n}",
                "test_cases": [
                    {
                        "stdin": "15 30",
                        "expected_output": "30"
                    }
                ]
            },
            {
                "id": "c-l5-p3",
                "title": "Array Pointer Traversal",
                "difficulty": "medium",
                "description": "Read 5 integers and print them using a pointer instead of array indexing.",
                "starter_code": "#include <stdio.h>\n\nint main() {\n    int arr[5];\n    int *ptr = arr;\n    // Read 5 elements\n    // Print using *ptr and ptr++\n    return 0;\n}",
                "test_cases": [
                    {
                        "stdin": "1 2 3 4 5",
                        "expected_output": "1 2 3 4 5"
                    }
                ]
            },
            {
                "id": "c-l5-p4",
                "title": "Calculate Length with Pointers",
                "difficulty": "medium",
                "description": "Write a function `int getLen(char *s)` that calculates the length of a string using pointers (without `strlen`).",
                "starter_code": "#include <stdio.h>\n\nint getLen(char *s) {\n    // Calculate length using pointer\n}\n\nint main() {\n    char s[100];\n    // Read string\n    // Print length\n    return 0;\n}",
                "test_cases": [
                    {
                        "stdin": "Genspark",
                        "expected_output": "8"
                    }
                ]
            },
            {
                "id": "c-l5-p5",
                "title": "Double Pointer Basics",
                "difficulty": "hard",
                "description": "Create a double pointer and use it to change the value of an integer. Print the value of the integer.",
                "starter_code": "#include <stdio.h>\n\nint main() {\n    int a = 10;\n    int *p = &a;\n    int **pp = &p;\n    // Change 'a' to 50 using 'pp'\n    // Print a\n    return 0;\n}",
                "test_cases": [
                    {
                        "stdin": "",
                        "expected_output": "50"
                    }
                ]
            }
        ]
    },
    {
        "id": "c-l6",
        "title": "LEVEL 6: Dynamic Memory Allocation",
        "lessons": [
            {
                "id": "c28",
                "title": "Lesson 28: DMA",
                "duration": "35 mins",
                "content": "In C, memory can be allocated in two main ways: **Static** and **Dynamic**. Understanding the difference is crucial for writing efficient programs that can handle variable amounts of data.\n\n---\n\n## 1. Static vs. Dynamic Memory\n\n### Static Memory (Stack)\nWhen you declare an array like `int arr[10];`, the size is fixed at compile time. This memory is managed by the **Stack**.\n- **Pros**: Very fast, automatic management.\n- **Cons**: Fixed size, cannot be changed during runtime.\n\n### Dynamic Memory (Heap)\nDynamic allocation allows you to request memory **while the program is running**. This memory is managed in a region called the **Heap**.\n- **Pros**: Flexible size, grows/shrinks as needed.\n- **Cons**: Slightly slower, must be manually managed (and freed).\n\n---\n\n## 2. Deep Dive: The C Memory Layout ️\n\nA professional C program divides RAM into four specific segments:\n- **Text Segment**: Stores the compiled machine code (read-only).\n- **Data Segment**: Stores global and static variables initialized by the programmer.\n- **Stack**: Stores local variables and function call information (auto-managed).\n- **Heap**: The area used for Dynamic Memory Allocation (programmer-managed).\n\n---\n\n## 3. The Problem of Fragmentation \n\nWhen you allocate and free many small blocks of memory on the **Heap**, it can become \"fragmented.\"\n- **External Fragmentation**: Total free memory is enough, but it's split into small, non-contiguous holes, so a large request fails.\n- **Internal Fragmentation**: Extra memory is allocated but not used (e.g., asking for 3 bytes but getting 4 due to alignment).\n\nProfessional developers use DMA carefully to avoid these issues by allocating larger blocks or using specialized memory pools.\n\n---\n\n## 4. Requirement: `<stdlib.h>`\n\nTo use dynamic memory functions in C, you must include the standard library header:\n```c\n#include <stdlib.h>\n```\n\n---\n\n## Key Takeaways\n- **Static** is for data whose size you know beforehand.\n- **Dynamic** is for data whose size changes or is unknown until runtime.\n- **The Heap** is the \"warehouse\" where dynamic memory lives.\n- **Memory Layout**: Understanding Stack vs Heap is fundamental to avoiding crashes.\n- **Fragmentation**: Reusing heap memory efficiently is a hallmark of a senior developer.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Where is dynamic memory allocated in C?",
                        "options": [
                            "The Stack",
                            "The Heap",
                            "The CPU Cache",
                            "The Hard Drive"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Dynamic memory is allocated from a pool of memory called the Heap, which is separate from the Stack used for static variables."
                    },
                    {
                        "id": 2,
                        "text": "Which of these is a disadvantage of static memory allocation?",
                        "options": [
                            "It is slower than dynamic allocation",
                            "The size cannot be changed during runtime",
                            "It requires manual freeing",
                            "It is stored on the Heap"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Static allocation (like normal arrays) must have a size determined at compile time, which makes it inflexible if data size changes."
                    },
                    {
                        "id": 3,
                        "text": "Which header file is required to use DMA functions in C?",
                        "options": [
                            "<stdio.h>",
                            "<string.h>",
                            "<stdlib.h>",
                            "<math.h>"
                        ],
                        "correctAnswer": 2,
                        "explanation": "The `<stdlib.h>` header contains the declarations for malloc, calloc, realloc, and free."
                    },
                    {
                        "id": 4,
                        "text": "In the context of memory, what does 'Lifetime' refer to in the Heap?",
                        "options": [
                            "It expires when the function ends",
                            "It lasts until the programmer calls free()",
                            "It lasts exactly 10 minutes",
                            "It depends on the CPU speed"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Unlike stack variables that die when a function returns, heap memory stays allocated until you explicitly release it using free()."
                    },
                    {
                        "id": 5,
                        "text": "What happens if you allocate memory on the heap but never free it?",
                        "options": [
                            "The computer runs faster",
                            "The memory is automatically freed by the OS immediately",
                            "A memory leak occurs",
                            "The variable becomes global"
                        ],
                        "correctAnswer": 2,
                        "explanation": "Failing to free heap memory results in a 'Memory Leak', where your program consumes more and more RAM over time."
                    }
                ]
            },
            {
                "id": "c29",
                "title": "Lesson 29: malloc() and free()",
                "duration": "45 mins",
                "content": "The most common way to request and release memory in C is using the dynamic duo: `malloc()` and `free()`.\n\n---\n\n## 1. What is malloc()?\n\n`malloc` stands for **Memory Allocation**. It requests a block of raw memory of a specific size from the Heap.\n\n### Syntax\n```c\nvoid* malloc(size_t size);\n```\n- **Parameter**: Total number of **bytes** to allocate.\n- **Returns**: A `void*` pointer to the first byte of the allocated block.\n- **Initialization**: The memory contains **garbage values** (it is not cleaned).\n\n---\n\n## 2. Sizing and Memory Alignment \n\nYou should **never** hardcode the number of bytes (e.g., `malloc(4)`). Different systems have different sizes for types.\n\n```c\n//  Professional Practice\nint *ptr = malloc(5 * sizeof(int)); \n```\n> [!TIP]\n> **Memory Alignment**: CPUs often access memory in \"chunks\" (usually 4 or 8 bytes). `malloc` automatically ensures the memory it gives you is properly aligned for any built-in type to ensure maximum performance.\n\n---\n\n## 3. The Casting Debate: (int*) vs. No Cast\n\nIn older C (C89), you had to cast the return of `malloc`. In modern C (C99 onwards), you don't need to because `void*` converts to any pointer automatically.\n\n- **With Cast**: `int *p = (int*)malloc(sizeof(int));` (Required for C++ compatibility).\n- **Without Cast**: `int *p = malloc(sizeof(int));` (Cleaner, preferred by many Linux/C experts).\n\n---\n\n## 4.  Full Example: Dynamic Array\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n, i, *ptr;\n\n    printf(\"Enter number of elements: \");\n    scanf(\"%d\", &n);\n\n    // 1. ALLOCATE: Request space\n    ptr = malloc(n * sizeof(int));\n\n    // 2. CHECK: Safety First\n    if (ptr == NULL) {\n        perror(\"Failed to allocate memory\");\n        return 1;\n    }\n\n    // 3. USE and FREE\n    for (i = 0; i < n; i++) ptr[i] = i + 1;\n    for (i = 0; i < n; i++) printf(\"%d \", ptr[i]);\n\n    free(ptr);\n    return 0;\n}\n```\n\n### Expected Output\n```text\nEnter number of elements: 3\n1 2 3 \n```\n\n### How it Works\n1.  **`perror`**: A professional way to print the exact reason for failure (e.g., \"Out of memory\").\n2.  **`free(ptr)`**: This returns the memory. If you lose the pointer `ptr` before calling this, that memory is gone forever until the program ends (a **Leak**).\n\n---\n\n## Key Takeaways\n- **Raw Memory**: `malloc` gives you bytes; it doesn't care about types.\n- **Alignment**: Use `sizeof` to let the compiler handle architecture differences.\n- **Cleanup**: Every `malloc` call is a debt you must pay back with `free`.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What does 'malloc' stand for?",
                        "options": [
                            "Main Allocation",
                            "Memory Allocation",
                            "Manual Allocation",
                            "Managed Allocation"
                        ],
                        "correctAnswer": 1,
                        "explanation": "malloc is short for Memory Allocation, the primary function for requesting heap memory."
                    },
                    {
                        "id": 2,
                        "text": "What is the return type of `malloc()`?",
                        "options": [
                            "int*",
                            "float*",
                            "void*",
                            "char*"
                        ],
                        "correctAnswer": 2,
                        "explanation": "malloc returns a `void*` (generic pointer) so that it can be used to allocate memory for any data type."
                    },
                    {
                        "id": 3,
                        "text": "What does `malloc` do if the system runs out of memory?",
                        "options": [
                            "It crashes the program automatically",
                            "It returns a pointer to address 0 (NULL)",
                            "It deletes other variables to make room",
                            "It returns a random address"
                        ],
                        "correctAnswer": 1,
                        "explanation": "On failure, malloc returns `NULL`. It is the programmer's job to check for this and handle it gracefully."
                    },
                    {
                        "id": 4,
                        "text": "Which expression allocates space for an array of 10 doubles correctly?",
                        "options": [
                            "malloc(10);",
                            "malloc(10 * sizeof(double));",
                            "malloc(sizeof(double));",
                            "malloc(10 + sizeof(double));"
                        ],
                        "correctAnswer": 1,
                        "explanation": "You must multiply the number of elements by the size of the data type to get the total byte count."
                    },
                    {
                        "id": 5,
                        "text": "What happens to a block of memory after you call `free(ptr)`?",
                        "options": [
                            "The pointer `ptr` is set to NULL automatically",
                            "The memory is returned to the OS",
                            "The value at that address is deleted",
                            "The program terminates"
                        ],
                        "correctAnswer": 1,
                        "explanation": "free() marks the block as available for the OS to reuse. It DOES NOT set the pointer itself to NULL; you should do that manually if needed."
                    }
                ]
            },
            {
                "id": "c30",
                "title": "Lesson 30: calloc() function",
                "duration": "40 mins",
                "content": "While `malloc` gives you raw memory with \"garbage\" values, `calloc` (**Contiguous Allocation**) gives you a clean slate by initializing all bits to zero.\n\n---\n\n## 1. Syntax and Parameters\n\n```c\nvoid* calloc(size_t n, size_t size);\n```\n- **n**: Number of elements.\n- **size**: Size of each element.\n\n---\n\n## 2. Strategic Use-Case: Struct Initialization ️\n\n`calloc` is highly professional when dynamically creating structures. It ensures all members (including strings and pointers) start as `0` or `NULL`, preventing crashes from uninitialized pointers.\n\n```c\ntypedef struct {\n    char name[50];\n    int score;\n    void *data_ptr; // Starts as NULL thanks to calloc!\n} Player;\n\nPlayer *p = calloc(1, sizeof(Player));\n```\n\n---\n\n## 3. Performance vs. Safety \n\n- **malloc**: Faster. It just marks memory as used without touching the bits. Use it when you plan to immediately overwrite every byte anyway (like in `strcpy`).\n- **calloc**: Slower. It must write zeros to every single bit. Use it when you need a predictable, clean state or when you won't initialize every field immediately.\n\n---\n\n## 4.  Example: Dynamic Array with calloc\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    // Allocate for 3 integers, all initialized to 0\n    int *arr = calloc(3, sizeof(int));\n\n    if (arr == NULL) return 1;\n\n    // Verify zero-initialization\n    printf(\"Value at index 0: %d\", arr[0]);\n    \n    free(arr);\n    return 0;\n}\n```\n\n### How it Works?\n> **Security**: `calloc` clears sensitive data that might have been left behind by a previous program in that memory location.\n> **Predictability**: It eliminates the \"it worked on my machine but crashed on yours\" bugs caused by random garbage values.\n\n### Expected Output\n```text\nValue at index 0: 0\n```\n\n---\n\n## Key Takeaways\n- **Clean Memory**: Guaranteed zero-initialization.\n- **Structs**: The safest choice for complex data types.\n- **Arguments**: Takes `(count, size)` instead of just total bytes.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What is the primary difference between malloc and calloc?",
                        "options": [
                            "malloc is for integers, calloc is for floats",
                            "calloc initializes memory to zero, malloc does not",
                            "malloc requires free(), calloc does not",
                            "calloc is only for 2D arrays"
                        ],
                        "correctAnswer": 1,
                        "explanation": "calloc (contiguous allocation) explicitly sets all bits of the allocated memory to zero, while malloc leaves whatever garbage was there before."
                    },
                    {
                        "id": 2,
                        "text": "How many arguments does `calloc()` take?",
                        "options": [
                            "1",
                            "2",
                            "3",
                            "4"
                        ],
                        "correctAnswer": 1,
                        "explanation": "calloc takes two arguments: the number of elements to allocate and the size of each element."
                    },
                    {
                        "id": 3,
                        "text": "Which call is equivalent to `malloc(5 * sizeof(int))` but with zero-initialization?",
                        "options": [
                            "calloc(5 * sizeof(int));",
                            "calloc(5, sizeof(int));",
                            "calloc(sizeof(int), 5, 0);",
                            "calloc(5 + sizeof(int));"
                        ],
                        "correctAnswer": 1,
                        "explanation": "The correct syntax for calloc is the number of elements followed by the size of each."
                    },
                    {
                        "id": 4,
                        "text": "Why might `calloc` be slightly slower than `malloc`?",
                        "options": [
                            "It uses more electricity",
                            "It has to perform the extra step of zeroing out the memory",
                            "It only works on certain CPUs",
                            "It uses the hard drive"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Setting every single bit to zero takes extra processor cycles compared to just reserving the address as malloc does."
                    },
                    {
                        "id": 5,
                        "text": "Does `calloc` require the `<stdlib.h>` header?",
                        "options": [
                            "Yes",
                            "No",
                            "Only for float arrays",
                            "Only on Linux"
                        ],
                        "correctAnswer": 0,
                        "explanation": "Like all standard DMA functions, calloc is defined in the standard library header."
                    }
                ]
            },
            {
                "id": "c31",
                "title": "Lesson 31: realloc() function",
                "duration": "45 mins",
                "content": "What if you allocated space for 5 items, but later realize you need 10? Instead of freeing and starting over, you use `realloc` to **resize** the existing block.\n\n---\n\n## 1. Syntax and Safety\n\n```c\nvoid* realloc(void *ptr, size_t new_size);\n```\n- **ptr**: The original memory address.\n- **new_size**: The new total size required.\n\n> [!CAUTION]\n> **The NULL Trap**: If `realloc` fails, it returns `NULL`, but the original memory is **still allocated**. If you assign the result directly to your original pointer (`ptr = realloc(ptr, size)`), and it fails, you lose the address of your data forever!\n\n---\n\n## 2. Why the Pointer Changes? \n\nWhen you ask for more space, three things can happen:\n1.  **In-Place Expansion**: If there's free space right after your block, the address stays the same.\n2.  **Relocation**: If something else is blocking the path, C finds a **new large spot**, copies your data there, and frees the old spot automatically. Your pointer address **changes**.\n3.  **Shrinking**: If you ask for less space, the tail end is returned to the OS, and the base address usually stays the same.\n\n---\n\n## 3.  The Professional \"Re-Allocation\" Pattern\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *arr = malloc(2 * sizeof(int));\n    arr[0] = 10; arr[1] = 20;\n\n    // Resize for 4 integers safely\n    int *temp = realloc(arr, 4 * sizeof(int));\n    \n    if (temp == NULL) {\n        free(arr); // Clean up original before exiting\n        return 1;\n    }\n    \n    arr = temp; // Only update if successful\n    arr[2] = 30; arr[3] = 40;\n\n    for(int i=0; i<4; i++) printf(\"%d \", arr[i]);\n\n    free(arr);\n    return 0;\n}\n```\n\n### How it Works?\n> **Copying**: If relocation happens, `realloc` handles the byte-by-byte copy of your old data to the new location. You don't have to do it manually.\n> **Fragmentation**: Frequently calling `realloc` can lead to heap fragmentation. It's often better to double the size (e.g., 2 -> 4 -> 8) rather than increasing by 1 each time.\n\n### Expected Output\n```text\n10 20 30 40 \n```\n\n---\n\n## Key Takeaways\n- **Safety**: Always use a `temp` pointer for the return value.\n- **Efficiency**: It is the only way to grow or shrink memory without a manual copy-and-delete.\n- **Address**: Never assume the address will stay the same after a `realloc` call.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What is the purpose of `realloc()`?",
                        "options": [
                            "To read data from a file",
                            "To change the size of an existing dynamically allocated block",
                            "To reset a pointer to NULL",
                            "To allocate memory on the Stack"
                        ],
                        "correctAnswer": 1,
                        "explanation": "realloc (re-allocation) is used to increase or decrease the size of memory previously allocated on the heap."
                    },
                    {
                        "id": 2,
                        "text": "What happens to the existing data in a block when it is resized via `realloc`?",
                        "options": [
                            "It is deleted",
                            "It is moved to the hard drive",
                            "It is preserved (up to the lesser of the new and old sizes)",
                            "It is encrypted"
                        ],
                        "correctAnswer": 2,
                        "explanation": "C guarantees that your existing data remains intact after a realloc call, even if the block is moved to a new memory address."
                    },
                    {
                        "id": 3,
                        "text": "Why should you use a temporary pointer with `realloc`?",
                        "options": [
                            "To make the code look professional",
                            "To prevent memory leaks if realloc returns NULL",
                            "Because realloc cannot return the same pointer",
                            "Temporary pointers are faster"
                        ],
                        "correctAnswer": 1,
                        "explanation": "If realloc fails, it returns NULL. If you assign that NULL to your original pointer, you lose the address of your original data, creating a leak."
                    },
                    {
                        "id": 4,
                        "text": "If `realloc(ptr, 0)` is called, what is the effect?",
                        "options": [
                            "Nothing happens",
                            "The program crashes",
                            "It is equivalent to calling free(ptr)",
                            "It doubles the memory size"
                        ],
                        "correctAnswer": 2,
                        "explanation": "Reducing the size to 0 is generally treated as a request to free the memory block."
                    },
                    {
                        "id": 5,
                        "text": "Does `realloc` automatically free the old block if it moves the data to a new address?",
                        "options": [
                            "Yes",
                            "No",
                            "Only if the user asks",
                            "Only on Windows"
                        ],
                        "correctAnswer": 0,
                        "explanation": "Yes, if relocation is necessary, C handles the copying and the freeing of the old memory location for you."
                    }
                ]
            },
            {
                "id": "c32",
                "title": "Lesson 32: DMA Best Practices",
                "duration": "40 mins",
                "content": "Dynamic Memory Allocation gives you great power, but with great power comes great responsibility. Professional C development requires a disciplined approach to memory safety.\n\n---\n\n## 1. The \"Never Assume\" Rule\n\nMemory is limited. `malloc`, `calloc`, and `realloc` can fail if the system is out of RAM. Always check for `NULL` before using the pointer.\n\n### Dangerous Code\n```c\nint *p = malloc(1000 * sizeof(int));\np[0] = 5; // CRASH! if malloc failed\n```\n\n### Professional Code\n```c\nint *p = malloc(1000 * sizeof(int));\nif (p == NULL) {\n    fprintf(stderr, \"Critical Error: Out of Memory\\n\");\n    exit(1);\n}\np[0] = 5; // Safe\n```\n\n---\n\n## 2. Buffer Overflows: The Silent Killer\n\nA **Buffer Overflow** occurs when you write data beyond the boundaries of your allocated block. This can overwrite other variables, corrupt the program's stack, or create massive security vulnerabilities.\n\n```c\nint *arr = malloc(5 * sizeof(int));\nfor(int i = 0; i <= 5; i++) { // ️ BUG: Loop runs 6 times\n    arr[i] = i; // Overwrites memory at index 5!\n}\n```\n> [!CAUTION]\n> C does NOT check array boundaries for you. You must be extremely precise with your loop conditions.\n\n---\n\n## 3. Dangling Pointers & Double Free\n\n- **Dangling Pointer**: A pointer that points to memory that has just been freed.\n- **Double Free**: Freeing the same memory twice. This usually crashes the program immediately.\n\n### ️ The \"NULLify\" Strategy\nAlways set your pointer to `NULL` immediately after freeing it. This prevents both accidental use and accidental double-frees.\n```c\nfree(ptr);\nptr = NULL; \n\n// Safely calling free(NULL) does nothing and causes no error.\nfree(ptr); //  Safe double-call\n```\n\n---\n\n## 4. The Professional Memory Checklist \n\n- [ ] **Check for NULL**: Every allocation must have an `if (p == NULL)` check.\n- [ ] **Match Alloc/Free**: Every `malloc` must have a corresponding `free`.\n- [ ] **Initialize**: Remember that `malloc` memory starts with garbage values.\n- [ ] **Valgrind**: Use tools like Valgrind to scan your binary for leaks.\n\n---\n\n## Key Takeaways\n- **Safety**: Manual memory management is where most C bugs occur.\n- **Precision**: Be careful with array indices (`size-1`).\n- **Tooling**: Use memory debuggers during development.\n- **Discipline**: A master C programmer spends as much time on safety as on logic.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What is a 'Memory Leak'?",
                        "options": [
                            "A hole in the computer's motherboard",
                            "When memory is allocated but never freed, becoming unusable",
                            "When a variable's value changes randomly",
                            "When the hard drive runs out of space"
                        ],
                        "correctAnswer": 1,
                        "explanation": "A memory leak happens when heap memory is 'lost' because the program no longer has a pointer to it but hasn't freed it."
                    },
                    {
                        "id": 2,
                        "text": "What is a 'Dangling Pointer'?",
                        "options": [
                            "A pointer that points to address 0",
                            "A pointer that points to memory that has already been freed",
                            "A pointer that hasn't been used yet",
                            "A pointer to a function"
                        ],
                        "correctAnswer": 1,
                        "explanation": "After free() is called, the pointer still holds the old address. If you try to use it, you are accessing 'dead' memory."
                    },
                    {
                        "id": 3,
                        "text": "What should you do immediately after calling `free(ptr)` to stay safe?",
                        "options": [
                            "Delete the line of code",
                            "Set `ptr = NULL;`",
                            "Restart the computer",
                            "Call malloc again"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Setting the pointer to NULL ensures that if you accidentally try to use it later, the program will crash cleanly rather than causing hard-to-find memory bugs."
                    },
                    {
                        "id": 4,
                        "text": "What happens if you 'Double Free' (call free twice on the same pointer)?",
                        "options": [
                            "Nothing, it's safer",
                            "The computer restarts",
                            "It typically causes a program crash or security vulnerability",
                            "It frees the memory twice as fast"
                        ],
                        "correctAnswer": 2,
                        "explanation": "Double freeing corrupts the heap management structures and is a severe bug that leads to crashes or security exploits."
                    },
                    {
                        "id": 5,
                        "text": "Which tool is commonly used to find memory leaks in C programs?",
                        "options": [
                            "Photoshop",
                            "Valgrind",
                            "Excel",
                            "Slack"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Valgrind is a powerful industry-standard tool for monitoring memory usage and detecting leaks and errors in C/C++."
                    }
                ]
            }
        ],
        "problems": [
            {
                "id": "c-l6-p1",
                "title": "Dynamic Array Allocation",
                "difficulty": "easy",
                "description": "Read an integer `n` from the user, allocate an array of `n` integers using `malloc`, fill it with numbers 1 to `n`, and print them. Finally, free the memory.",
                "starter_code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n, *arr;\n    // Read n\n    // Allocate memory\n    // Fill and print\n    // Free memory\n    return 0;\n}",
                "test_cases": [
                    {
                        "stdin": "3",
                        "expected_output": "1 2 3"
                    }
                ]
            },
            {
                "id": "c-l6-p2",
                "title": "Sum of N Numbers (DMA)",
                "difficulty": "easy",
                "description": "Allocate memory for `n` floats using `malloc`. Read `n` floats and print their sum with 2 decimal places.",
                "starter_code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n;\n    float *ptr, sum = 0;\n    // Read n\n    // Allocate memory\n    // Read elements and calculate sum\n    // Print sum and free memory\n    return 0;\n}",
                "test_cases": [
                    {
                        "stdin": "3\n1.5 2.5 3.0",
                        "expected_output": "7.00"
                    }
                ]
            },
            {
                "id": "c-l6-p3",
                "title": "Using calloc for Zero Initialization",
                "difficulty": "medium",
                "description": "Allocate an array of 5 integers using `calloc`. Print all elements (they should be 0).",
                "starter_code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *arr;\n    // Allocate with calloc\n    // Print all 5 elements\n    // Free memory\n    return 0;\n}",
                "test_cases": [
                    {
                        "stdin": "",
                        "expected_output": "0 0 0 0 0"
                    }
                ]
            },
            {
                "id": "c-l6-p4",
                "title": "Resizing Array with realloc",
                "difficulty": "medium",
                "description": "Initially allocate memory for 2 integers. Then resize it to 4 integers using `realloc`. Fill all 4 with values 10, 20, 30, 40 and print them.",
                "starter_code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *arr = malloc(2 * sizeof(int));\n    // Use realloc to resize to 4\n    // Fill and print\n    // Free memory\n    return 0;\n}",
                "test_cases": [
                    {
                        "stdin": "",
                        "expected_output": "10 20 30 40"
                    }
                ]
            },
            {
                "id": "c-l6-p5",
                "title": "Dynamic String concatenation",
                "difficulty": "hard",
                "description": "Read two strings, calculate their total length, allocate a new dynamic string of that size + 1, and concatenate them. Print the result and free the memory.",
                "starter_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    char s1[50], s2[50];\n    // Read s1 and s2\n    // Allocate dynamic memory for combined string\n    // Concatenate and print\n    // Free memory\n    return 0;\n}",
                "test_cases": [
                    {
                        "stdin": "Gen Spark",
                        "expected_output": "GenSpark"
                    }
                ]
            }
        ]
    },
    {
        "id": "c-l7",
        "title": "LEVEL 7: Structures & Files",
        "lessons": [
            {
                "id": "c33",
                "title": "Lesson 33: Structures & Unions",
                "duration": "45 mins",
                "content": "Until now, we have used arrays to store multiple items of the **same** type. But what if you want to store a student's name (string), roll number (int), and marks (float) together? For this, C provides **Structures** and **Unions**.\n\n---\n\n## 1. What is a Structure?\n\nA structure is a user-defined data type that allows you to group different types of related data into a single unit.\n\n### Syntax: Declaration\n```c\nstruct Student {\n    char name[50];\n    int roll;\n    float marks;\n};\n```\n\n---\n\n## 2. Strategic Concept: Memory Padding & Alignment \n\nHave you ever wondered why a struct with a `char` (1 byte) and an `int` (4 bytes) sometimes takes **8 bytes** instead of 5? This is due to **Memory Padding**.\n\n- **Alignment**: CPUs access memory faster if variables are at addresses that are multiples of their size.\n- **Padding**: The compiler inserts \"empty bytes\" between members to align them correctly.\n\n> [!TIP]\n> **Pro-Tip**: To save memory, arrange your struct members from **largest to smallest** to minimize padding.\n\n---\n\n## 3. Unions: The Memory Efficient Alternative\n\nIn a **Union**, all members share the same starting memory address. It can only hold one value at a time.\n\n```c\nunion Secret {\n    int code;\n    char key[4];\n};\n```\n\n| Feature | Structure | Union |\n| :--- | :--- | :--- |\n| **Memory** | Sum of members (+ padding) | Size of largest member |\n| **Access** | All members at once | Only one at a time |\n| **Use Case** | Complex objects (Student) | Memory-constrained systems |\n\n---\n\n## 4.  Practical Example: Nested Structures\n\n```c\n#include <stdio.h>\n\ntypedef struct {\n    int x, y;\n} Point;\n\ntypedef struct {\n    Point start;\n    Point end;\n} Line;\n\nint main() {\n    Line L = {{0, 0}, {10, 10}};\n    printf(\"Line from (%d,%d) to (%d,%d)\", L.start.x, L.start.y, L.end.x, L.end.y);\n    return 0;\n}\n```\n\n### Expected Output\n```text\nLine from (0,0) to (10,10)\n```\n\n### How it Works\n1.  **Nested Access**: Notice how we use `L.start.x` to traverse through two levels of structures.\n2.  **Initialization**: We used nested curly braces `{ { } , { } }` to initialize the inner points.\n\n---\n\n## Key Takeaways\n- **Padding**: Structs are often larger than the sum of their parts for CPU speed.\n- **Unions**: Shared memory; useful for hardware registers or saving RAM.\n- **Organization**: Use `typedef` (Lesson 35) with structs for cleaner code.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What is the primary purpose of a structure in C?",
                        "options": [
                            "To store only integers",
                            "To group related data of different types",
                            "To make the program run faster",
                            "To replace the main function"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Structures allow you to group variables of different data types (like int, char, float) under a single name."
                    },
                    {
                        "id": 2,
                        "text": "Which operator is used to access members of a structure?",
                        "options": [
                            "& (Address-of)",
                            "* (Dereference)",
                            ". (Dot operator)",
                            "-> (Arrow operator) - for pointers only"
                        ],
                        "correctAnswer": 2,
                        "explanation": "The dot operator (.) is used to access members of a structure variable."
                    },
                    {
                        "id": 3,
                        "text": "What is the correct syntax to declare a structure for a 'Point' with x and y coordinates?",
                        "options": [
                            "struct Point { int x, y; }",
                            "struct Point { int x; int y; };",
                            "Point { int x; int y; }",
                            "struct Point ( int x, y )"
                        ],
                        "correctAnswer": 1,
                        "explanation": "A structure is declared using the `struct` keyword, followed by curly braces and a trailing semicolon."
                    },
                    {
                        "id": 4,
                        "text": "What is the main difference between a struct and a union in terms of memory?",
                        "options": [
                            "Structs share memory, Unions use separate memory",
                            "Unions share the same memory location for all members, Structs use separate memory for each",
                            "Unions are always larger",
                            "There is no difference"
                        ],
                        "correctAnswer": 1,
                        "explanation": "In a Union, all members share the exact same starting memory address, while each struct member has its own address."
                    },
                    {
                        "id": 5,
                        "text": "In a union with an `int` (4 bytes) and a `char` (1 byte), what is the total size of the union?",
                        "options": [
                            "5 bytes",
                            "1 byte",
                            "4 bytes",
                            "8 bytes"
                        ],
                        "correctAnswer": 2,
                        "explanation": "A Union's size is equal to the size of its largest member. In this case, 4 bytes."
                    }
                ]
            },
            {
                "id": "c34",
                "title": "Lesson 34: File Handling",
                "duration": "50 mins",
                "content": "Normally, when a program ends, all its data is lost from RAM. To save data permanently, we must write it to files on the hard drive. C provides a powerful set of functions for **File I/O**.\n\n---\n\n## 1. The FILE Pointer & Opening Modes\n\nAll file operations are handled through a `FILE` pointer. Professional code always checks if the file opened successfully.\n\n```c\nFILE *fp = fopen(\"config.bin\", \"wb\"); // Open for writing in BINARY mode\nif (fp == NULL) {\n    perror(\"Error opening file\");\n    return 1;\n}\n```\n\n### Binary vs. Text Mode\n- **Text Mode (`\"r\"`, `\"w\"`)**: Handles translations (like newline `\\n` to `\\r\\n` on Windows). Best for human-readable files.\n- **Binary Mode (`\"rb\"`, `\"wb\"`)**: No translations. Every byte is saved exactly as it is. Best for images, databases, and custom file formats.\n\n---\n\n## 2. Advanced: File Positioning \n\nSometimes you don't want to read a file from the start. You might want to jump to the middle or the end. C provides three functions for this:\n\n- **`fseek(fp, offset, origin)`**: Moves the file pointer.\n  - `SEEK_SET`: Beginning of file.\n  - `SEEK_CUR`: Current position.\n  - `SEEK_END`: End of file.\n- **`ftell(fp)`**: Returns the current position (in bytes from the start).\n- **`rewind(fp)`**: Sets the position back to the very beginning.\n\n---\n\n## 3.  Practical Example: Writing & Jumping\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *fp = fopen(\"test.txt\", \"w+\");\n    if (fp == NULL) return 1;\n\n    fputs(\"ABCDE\", fp); // File contains ABCDE\n    \n    // Jump back 2 bytes from the current position\n    fseek(fp, -2, SEEK_CUR);\n    \n    char c = fgetc(fp);\n    printf(\"Character at position: %c\", c);\n\n    fclose(fp);\n    return 0;\n}\n```\n\n### Expected Output\n```text\nCharacter at position: D\n```\n\n### How it Works\n1.  **`w+` mode**: Allows both reading and writing.\n2.  **`fseek(fp, -2, SEEK_CUR)`**: After writing \"ABCDE\", the pointer is at position 5. We jump back 2 bytes to position 3 (the letter 'D').\n3.  **`fgetc`**: Reads a single character from the new position.\n\n---\n\n## Key Takeaways\n- **Binary Mode**: Crucial for non-text data.\n- **fseek**: Allows \"Random Access\" to any part of a file.\n- **Robustness**: Always use `perror` and `NULL` checks when dealing with files.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Which header file is required for file handling in C?",
                        "options": [
                            "<stdlib.h>",
                            "<stdio.h>",
                            "<file.h>",
                            "<string.h>"
                        ],
                        "correctAnswer": 1,
                        "explanation": "<stdio.h> contains the FILE type and functions like fopen, fclose, etc."
                    },
                    {
                        "id": 2,
                        "text": "What does the 'a' mode in `fopen` stand for?",
                        "options": [
                            "Automatic",
                            "Append",
                            "All-access",
                            "Array"
                        ],
                        "correctAnswer": 1,
                        "explanation": "The 'a' mode opens a file for appending, meaning new data is added to the end without deleting existing content."
                    },
                    {
                        "id": 3,
                        "text": "What happens if `fopen` cannot open a file?",
                        "options": [
                            "The program crashes",
                            "It returns NULL",
                            "The computer restarts",
                            "It deletes the file"
                        ],
                        "correctAnswer": 1,
                        "explanation": "If a file cannot be opened (e.g., file not found in 'r' mode), `fopen` returns NULL. You should always check for this."
                    },
                    {
                        "id": 4,
                        "text": "What is the primary difference between `w` and `a` modes?",
                        "options": [
                            "w reads, a writes",
                            "w overwrites the file, a adds to the end",
                            "a is faster than w",
                            "w creates a file, a does not"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Write mode ('w') erases the file content if it exists, while Append ('a') preserves it and adds data to the end."
                    },
                    {
                        "id": 5,
                        "text": "Why is it critical to call `fclose()`?",
                        "options": [
                            "To make the file hidden",
                            "To ensure all data is correctly saved and resources are released",
                            "To delete the temporary buffer",
                            "It is optional in modern C"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Closing a file flushes buffers to disk and frees the memory used by the FILE structure."
                    }
                ]
            },
            {
                "id": "c35",
                "title": "Lesson 35: Enums in C",
                "duration": "30 mins",
                "content": "An **Enumeration (enum)** is a user-defined data type that consists of named integer constants. It makes code more readable and easier to maintain by replacing magic numbers with descriptive names.\n\n---\n\n## 1. What is an Enum?\n\nIf you have a set of related values (like days of the week or menu options), instead of using `int day = 0; // what is 0?`, you use enums.\n\n```c\nenum Day { SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY };\n\nenum Day today = MONDAY;\n```\nBy default, `SUNDAY` is 0, `MONDAY` is 1, and so on.\n\n---\n\n## 2. Custom Values & Syntax\n\nYou can override the default values. If you set one value, the subsequent ones increment from there.\n\n```c\nenum Status { \n    PENDING = 1,  // 1\n    ACTIVE,       // 2\n    COMPLETED = 10, // 10\n    FAILED        // 11\n};\n```\n\n---\n\n## 3. Enum vs #define\n\nWhy use `enum` instead of `#define`?\n- **Scope**: Enums follow block scope rules; `#define` is global.\n- **Type Checking**: Enums are a distinct type, which helps some compilers catch errors.\n- **Debugging**: Debuggers can show the name (e.g., `MONDAY`) instead of just the number (1).\n\n---\n\n## 4.  Practical Example: Menu System\n\n```c\n#include <stdio.h>\n\nenum Menu { EXIT, START, SETTINGS, HELP };\n\nint main() {\n    int choice = START;\n\n    switch(choice) {\n        case START: printf(\"Game Starting...\\n\"); break;\n        case EXIT: printf(\"Goodbye!\\n\"); break;\n        default: printf(\"Invalid Choice\\n\");\n    }\n    return 0;\n}\n```\n\n### How it Works?\n> **Readability**: `case START` is much clearer than `case 1`.\n> **Maintenance**: If you add a new menu item, you only update the `enum` definition, and the numbers adjust automatically.\n\n---\n\n## Key Takeaways\n- **Integers under the hood**: Enums are basically named integers.\n- **Readability**: Use them for states, options, and categories.\n- **Sequential**: Values increment by default, saving manual assignment.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What is the default integer value of the first member in an enum if not specified?",
                        "options": [
                            "1",
                            "0",
                            "-1",
                            "Random"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Enums in C are zero-indexed by default."
                    },
                    {
                        "id": 2,
                        "text": "If `enum Color { RED=5, GREEN, BLUE };`, what is the value of `BLUE`?",
                        "options": [
                            "2",
                            "6",
                            "7",
                            "0"
                        ],
                        "correctAnswer": 2,
                        "explanation": "Starting from RED=5, GREEN becomes 6 and BLUE becomes 7."
                    },
                    {
                        "id": 3,
                        "text": "Can an enum member across different enums have the same name?",
                        "options": [
                            "Yes",
                            "No, it causes a name collision",
                            "Only if they have the same value",
                            "Only in different files"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Enum member names must be unique within the same scope."
                    }
                ]
            }
        ],
        "problems": [
            {
                "id": "c-l7-p1",
                "title": "Student Information System",
                "difficulty": "easy",
                "description": "Define a struct `Student` with `name`, `roll_no`, and `marks`. Read data for one student and print it.",
                "starter_code": "#include <stdio.h>\n\nstruct Student {\n    char name[50];\n    int roll_no;\n    float marks;\n};\n\nint main() {\n    struct Student s;\n    // Read name, roll_no, marks\n    // Print them\n    return 0;\n}",
                "test_cases": [
                    {
                        "stdin": "Alice 101 85.5",
                        "expected_output": "Name: Alice, Roll: 101, Marks: 85.50"
                    }
                ]
            },
            {
                "id": "c-l7-p2",
                "title": "Rectangle Area using Structs",
                "difficulty": "easy",
                "description": "Define a struct `Rectangle` with `length` and `width`. Write a function `float calculateArea(struct Rectangle r)` and use it to print the area.",
                "starter_code": "#include <stdio.h>\n\nstruct Rectangle {\n    float length;\n    float width;\n};\n\n// float calculateArea(struct Rectangle r)\n\nint main() {\n    struct Rectangle rect;\n    // Read length and width\n    // Calculate and print area\n    return 0;\n}",
                "test_cases": [
                    {
                        "stdin": "5.0 4.0",
                        "expected_output": "20.00"
                    }
                ]
            },
            {
                "id": "c-l7-p3",
                "title": "Write to File",
                "difficulty": "medium",
                "description": "Write a program that takes a string from the user and writes it to a file named 'output.txt'.",
                "starter_code": "#include <stdio.h>\n\nint main() {\n    char str[100];\n    FILE *fp;\n    // Read string\n    // Open output.txt for writing\n    // Write string and close file\n    return 0;\n}",
                "test_cases": [
                    {
                        "stdin": "Hello File I/O",
                        "expected_output": "Data written successfully"
                    }
                ]
            },
            {
                "id": "c-l7-p4",
                "title": "Read from File",
                "difficulty": "medium",
                "description": "Write a program that reads the first 10 characters from a file named 'input.txt' and prints them.",
                "starter_code": "#include <stdio.h>\n\nint main() {\n    char buffer[11];\n    FILE *fp;\n    // Open input.txt for reading\n    // Read 10 chars\n    // Print buffer\n    return 0;\n}",
                "test_cases": [
                    {
                        "stdin": "",
                        "expected_output": "abcdefghij"
                    }
                ]
            },
            {
                "id": "c-l7-p5",
                "title": "Complex Number Addition",
                "difficulty": "hard",
                "description": "Use a struct `Complex` to store `real` and `imag` parts. Write a function to add two complex numbers and print the result in 'a + bi' format.",
                "starter_code": "#include <stdio.h>\n\ntypedef struct {\n    float real;\n    float imag;\n} Complex;\n\n// Complex add(Complex c1, Complex c2)\n\nint main() {\n    Complex n1, n2, result;\n    // Read n1 and n2\n    // Add and print result\n    return 0;\n}",
                "test_cases": [
                    {
                        "stdin": "1.5 2.5 2.5 1.5",
                        "expected_output": "4.00 + 4.00i"
                    }
                ]
            }
        ]
    },
    {
        "id": "c-l8",
        "title": "LEVEL 8: Advanced Concepts",
        "lessons": [
            {
                "id": "c36",
                "title": "Lesson 36: Preprocessor & Storage Classes",
                "duration": "40 mins",
                "content": "Before compilation and during execution, C uses two powerful systems to manage code and memory: the **Preprocessor** and **Storage Classes**.\n\n---\n\n## 1. Strategic Tool: Conditional Compilation ️\n\nProfessional developers use conditional directives to make code that works on different operating systems (Windows, Linux, Mac) or to include \"Debug Mode\" features.\n\n```c\n#define DEBUG_MODE\n\n#ifdef DEBUG_MODE\n    printf(\"Debug: Memory allocated at %p\\n\", ptr);\n#endif\n```\n- `#ifdef` / `#ifndef`: Check if a macro is defined.\n- `#else` / `#elif`: Handle alternative conditions.\n- `#endif`: Required to close the block.\n\n---\n\n## 2. Predefined Macros \n\nC provides built-in macros that help with logging and error reporting:\n- `__FILE__`: The name of the current file (string).\n- `__LINE__`: The current line number (integer).\n- `__DATE__`: The date of compilation.\n\n```c\nprintf(\"Error in file %s at line %d\", __FILE__, __LINE__);\n```\n\n---\n\n## 3. Storage Classes: A Summary\n\nStorage classes define the **lifetime** and **scope** of a variable.\n\n| Class | Lifetime | Visibility | Use Case |\n| :--- | :--- | :--- | :--- |\n| **auto** | Function end | Local | Default for all local variables |\n| **static** | Program end | Local | Preserve value between function calls |\n| **extern** | Program end | Global | Share variable across multiple `.c` files |\n| **register** | Function end | Local | Hint to store in CPU for extreme speed |\n\n---\n\n## 4.  Practical Example: Static and Macros\n\n```c\n#include <stdio.h>\n\n#define LOG_MSG(m) printf(\"LOG: %s\\n\", m)\n\nvoid tracker() {\n    static int count = 0;\n    count++;\n    printf(\"Visit #%d\\n\", count);\n}\n\nint main() {\n    LOG_MSG(\"System Started\");\n    tracker(); // Visit #1\n    tracker(); // Visit #2\n    return 0;\n}\n```\n\n### How it Works?\n> **Macros**: `LOG_MSG` is a \"function-like macro.\" It saves typing and is faster than a function call because there is no stack overhead.\n> **Static**: The variable `count` is initialized to `0` only once. It lives in the **Data Segment** of memory, not the Stack.\n\n### Expected Output\n```text\nLOG: System Started\nVisit #1\nVisit #2\n```\n\n---\n\n## Key Takeaways\n- **Preprocessor**: Use it for Header Guards, Macros, and cross-platform logic.\n- **Storage**: `static` is your best friend for maintaining state without global variables.\n- **Logging**: Use `__FILE__` and `__LINE__` for professional debugging.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What symbol do all preprocessor directives start with?",
                        "options": [
                            "&",
                            "$",
                            "#",
                            "@"
                        ],
                        "correctAnswer": 2,
                        "explanation": "All preprocessor commands (directives) like #include and #define start with a hash (#) symbol."
                    },
                    {
                        "id": 2,
                        "text": "Do preprocessor directives like `#define MAX 100` end with a semicolon?",
                        "options": [
                            "Yes, always",
                            "Only if it's a number",
                            "No, never",
                            "Only on Windows"
                        ],
                        "correctAnswer": 2,
                        "explanation": "Preprocessor directives are handled before the C compiler runs and do not follow C statement syntax."
                    }
                ]
            },
            {
                "id": "c37",
                "title": "Lesson 37: Advanced C Features",
                "duration": "45 mins",
                "content": "As we reach the end of the curriculum, let's explore the final pieces of the puzzle: low-level bit manipulation and integrated project building.\n\n---\n\n## 1. Typedef & The Arrow Operator (->)\n\nProfessional C code uses `typedef` to clean up declarations and the **Arrow Operator (`->`)** to access members through pointers.\n\n```c\ntypedef struct {\n    int id;\n    char name[20];\n} User;\n\nUser *u = malloc(sizeof(User));\nu->id = 1; // Correct way to access member via pointer\n```\n\n---\n\n## 2. Bitwise Operators: Control the Bits \n\nIn systems programming, you often need to manipulate individual bits. C provides operators for this:\n\n| Operator | Meaning | Example (Binary) |\n| :--- | :--- | :--- |\n| `&` | AND | `5 & 1` (0101 & 0001 = 0001) |\n| `|` | OR | `5 | 1` (0101 | 0001 = 0101) |\n| `^` | XOR | `5 ^ 1` (0101 ^ 0001 = 0100) |\n| `<<` | Left Shift | `1 << 2` (0001 becomes 0100 = 4) |\n\n---\n\n## 3. Professional Error Handling\n\nAlways use `perror()` and exit codes for robust software.\n```c\nif (fopen(\"file.txt\", \"r\") == NULL) {\n    perror(\"Error\");\n    exit(EXIT_FAILURE);\n}\n```\n\n---\n\n## 4. Capstone Project: Simple Phonebook\n\nThis script integrates everything you've learned: `struct`, `typedef`, `DMA`, and `File I/O`.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    char name[50];\n    char phone[15];\n} Contact;\n\nint main() {\n    // 1. Dynamic Allocation\n    Contact *entry = malloc(sizeof(Contact));\n    if (entry == NULL) return 1;\n\n    strcpy(entry->name, \"Alice\");\n    strcpy(entry->phone, \"123-456\");\n\n    // 2. File Persistence\n    FILE *fp = fopen(\"phonebook.txt\", \"w\");\n    if (fp != NULL) {\n        fprintf(fp, \"%s: %s\", entry->name, entry->phone);\n        fclose(fp);\n        printf(\"Contact saved successfully!\\n\");\n    }\n\n    free(entry); // 3. Memory Cleanup\n    return 0;\n}\n```\n\n### How it Works? (The Big Picture)\n> **Memory Manipulation**: We used `malloc` to reserve space only when needed. This is how large databases manage millions of records without wasting RAM.\n> **Data Organization**: `typedef struct` allowed us to treat a name and phone number as a single object called a `Contact`.\n> **Persistence**: The use of `FILE` functions ensures that even if you turn off the computer, \"Alice\" is still in our phonebook.\n> **Ownership**: By calling `free(entry)`, we officially returned the memory to the OS, preventing a memory leak.\n\n### Expected Output\n```text\nContact saved successfully!\n(File \"phonebook.txt\" created and populated)\n```\n\n---\n\n## Key Takeaways\n- **Integration**: Real apps are built by combining all these concepts.\n- **Bits**: Use Bitwise operators for hardware-level control.\n- **Discipline**: Professionalism in C is about memory safety and error checking.\n- **Graduation**: You are now ready for the Final Exam!",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What is the purpose of the `typedef` keyword?",
                        "options": [
                            "To define a new variable",
                            "To create an alias for an existing data type",
                            "To type-cast a variable",
                            "To create a loop"
                        ],
                        "correctAnswer": 1,
                        "explanation": "typedef (Type Definition) allows you to create a shortcut or descriptive name for complex types."
                    },
                    {
                        "id": 2,
                        "text": "Which bitwise operator is used to 'Shift' bits to the left?",
                        "options": [
                            ">> (Right Shift)",
                            "<< (Left Shift)",
                            "^ (XOR)",
                            "~ (NOT)"
                        ],
                        "correctAnswer": 1,
                        "explanation": "The << operator shifts all bits to the left by a specified number of positions, effectively multiplying the number by 2 for each shift."
                    },
                    {
                        "id": 3,
                        "text": "Which operator is used to access a structure member through a pointer?",
                        "options": [
                            ". (Dot)",
                            "-> (Arrow)",
                            "* (Asterisk)",
                            "& (Ampersand)"
                        ],
                        "correctAnswer": 1,
                        "explanation": "The arrow operator (->) is used specifically for pointers to structures. `ptr->member` is shorthand for `(*ptr).member`."
                    },
                    {
                        "id": 4,
                        "text": "What does `perror()` do?",
                        "options": [
                            "It crashes the program",
                            "It prints a human-readable description of the last system error",
                            "It deletes temporary files",
                            "It checks for syntax errors"
                        ],
                        "correctAnswer": 1,
                        "explanation": "perror stands for 'print error'. It looks at the global 'errno' variable and prints a descriptive message like 'File not found'."
                    },
                    {
                        "id": 5,
                        "text": "Which standard library defines `exit()` and `EXIT_FAILURE`?",
                        "options": [
                            "<stdio.h>",
                            "<string.h>",
                            "<stdlib.h>",
                            "<math.h>"
                        ],
                        "correctAnswer": 2,
                        "explanation": "The standard library (<stdlib.h>) contains the tools for process control and general utility functions."
                    }
                ]
            },
            {
                "id": "c38",
                "title": "Lesson 38: Const Correctness",
                "duration": "30 mins",
                "content": "The `const` keyword is one of the most important tools for writing safe, bug-free C code. It tells the compiler (and other developers) that a value should not change.\n\n---\n\n## 1. Constant Variables\n\nWhen a variable is marked `const`, any attempt to modify it will result in a compiler error.\n\n```c\nconst int MAX_USERS = 100;\n// MAX_USERS = 120; // ERROR!\n```\n\n---\n\n## 2. Pointers & Const: The Confusion\n\nThere are two main ways to use `const` with pointers, and they mean very different things:\n\n### 🅰️ Pointer to Const\nThe **data** cannot be changed through this pointer.\n```c\nconst int *ptr = &val;\n// *ptr = 10; // ERROR!\nptr = &other; // OK: Pointer can move\n```\n\n### 🅱️ Const Pointer\nThe **pointer** itself cannot change its address.\n```c\nint *const ptr = &val;\n*ptr = 10; // OK: Data can change\n// ptr = &other; // ERROR!\n```\n\n---\n\n## 3. Why Use Const?\n\n- **Safety**: Prevents accidental modification of data.\n- **Readability**: Communicates intent (e.g., \"this function only reads this array, it won't change it\").\n- **Optimization**: Helps the compiler make better assumptions about your data.\n\n---\n\n## 4.  Practical Example: Safe Functions\n\n```c\n#include <stdio.h>\n\n// const here ensures the function won't mess with our string\nvoid printMessage(const char *msg) {\n    printf(\"Message: %s\\n\", msg);\n    // msg[0] = 'X'; // This would trigger an error\n}\n\nint main() {\n    printMessage(\"Hello C!\");\n    return 0;\n}\n```\n\n---\n\n## Key Takeaways\n- **Read from right to left**: `int const *` (pointer to a const int), `int * const` (const pointer to an int).\n- **Function parameters**: Use `const` for input-only parameters to protect caller data.\n- **Optimization**: Const can lead to smaller, faster binaries.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What does `const int *ptr` mean?",
                        "options": [
                            "The pointer cannot be changed",
                            "The data pointed to cannot be changed",
                            "Both are constant",
                            "Nothing is constant"
                        ],
                        "correctAnswer": 1,
                        "explanation": "`const int *ptr` is a pointer to a constant integer. You can change the pointer but not the data."
                    },
                    {
                        "id": 2,
                        "text": "Which declaration makes the pointer itself constant?",
                        "options": [
                            "const int *p",
                            "int const *p",
                            "int *const p",
                            "const *int p"
                        ],
                        "correctAnswer": 2,
                        "explanation": "`int *const p` follows the rule that `const` applies to what is on its left. Here, it is the pointer `*`."
                    }
                ]
            },
            {
                "id": "c39",
                "title": "Lesson 39: Command Line Arguments",
                "duration": "35 mins",
                "content": "Most professional C programs (like `ls`, `gcc`, or `git`) take input from the terminal. In C, we handle this using `argc` and `argv` in the `main` function.\n\n---\n\n## 1. The main() Signature\n\nUntil now, we used `int main()`. To accept terminal input, we use:\n```c\nint main(int argc, char *argv[]) \n```\n- **`argc` (Argument Count)**: Number of strings passed (including the program name).\n- **`argv` (Argument Vector)**: An array of strings containing the arguments.\n\n---\n\n## 2. How it works in the Terminal\n\nIf you run `./program hello 123`:\n- `argc` = 3\n- `argv[0]` = \"./program\" (Always the executable name)\n- `argv[1]` = \"hello\"\n- `argv[2]` = \"123\"\n\n---\n\n## 3.  Practical Example: Terminal Adder\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc < 3) {\n        printf(\"Usage: %s num1 num2\\n\", argv[0]);\n        return 1;\n    }\n\n    int a = atoi(argv[1]); // Convert string to int\n    int b = atoi(argv[2]);\n\n    printf(\"Total: %d\\n\", a + b);\n    return 0;\n}\n```\n\n### Critical Tips\n- **Validation**: Always check `argc` before accessing `argv` to avoid segmentation faults.\n- **Conversion**: Arguments are always strings. Use `atoi()` (ASCII to Integer) or `atof()` for math.\n\n---\n\n## Key Takeaways\n- **argv[0]**: Program identity.\n- **Flexibility**: CLIs allow automation and scripting without manual input.\n- **Safety**: Never assume the user provided the right number of arguments.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "What is the value of `argv[0]`?",
                        "options": [
                            "The first user argument",
                            "The name of the program",
                            "The number of arguments",
                            "NULL"
                        ],
                        "correctAnswer": 1,
                        "explanation": "argv[0] always contains the path or name used to execute the program."
                    },
                    {
                        "id": 2,
                        "text": "If you run `a.exe 1 2 3`, what is `argc`?",
                        "options": [
                            "3",
                            "4",
                            "1",
                            "5"
                        ],
                        "correctAnswer": 1,
                        "explanation": "argc includes the program name + 3 arguments = 4."
                    }
                ]
            },
            {
                "id": "c40",
                "title": "Lesson 40: Error Handling in C",
                "duration": "40 mins",
                "content": "C does not have `try/catch`. Instead, it uses **return codes** and a global variable called **`errno`**. Handling errors gracefully is what separates amateur code from industrial-grade software.\n\n---\n\n## 1. Return Values\n\nMost C functions return a special value on failure:\n- `fopen` returns `NULL`.\n- `malloc` returns `NULL`.\n- `main` returns `1` or non-zero to indicate failure to the OS.\n\n---\n\n## 2. The `errno` Variable\n\nWhen a system call fails, it sets a global integer called `errno`. You can find the specific cause (e.g., \"File not found\" vs \"Permission denied\").\n\n```c\n#include <errno.h>\n#include <string.h>\n\nif (failure) {\n    printf(\"Error code: %d\\n\", errno);\n    printf(\"Meaning: %s\\n\", strerror(errno));\n}\n```\n\n---\n\n## 3. `perror()` - The Shortcut\n\nThe `perror(\"string\")` function prints your custom message, followed by the system error description. It's the standard for console errors.\n\n```c\nFILE *fp = fopen(\"ghost.txt\", \"r\");\nif (fp == NULL) {\n    perror(\"Critical Error\"); // Output: Critical Error: No such file or directory\n}\n```\n\n---\n\n## 4. Common Runtime Errors\n\n- **Segmentation Fault**: Accessing memory you don't own (usually a bad pointer).\n- **Stack Overflow**: Too many nested function calls (infinite recursion).\n- **Memory Leak**: Forgetting to `free` what you `malloc`.\n\n---\n\n## Key Takeaways\n- **Check Everything**: Never assume a file opened or memory was allocated.\n- **perror**: Use it for quick, descriptive logs.\n- **Documentation**: Document what your function returns on failure.",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Which global variable stores the error code of the last failing system call?",
                        "options": [
                            "err",
                            "errno",
                            "error_code",
                            "status"
                        ],
                        "correctAnswer": 1,
                        "explanation": "errno is defined in <errno.h> and is automatically set by system functions."
                    },
                    {
                        "id": 2,
                        "text": "What does `strerror(errno)` return?",
                        "options": [
                            "An integer",
                            "A pointer to an error message string",
                            "Nothing",
                            "A boolean"
                        ],
                        "correctAnswer": 1,
                        "explanation": "strerror converts the numeric errno into a human-readable string like 'Permission denied'."
                    }
                ]
            }
        ],
        "problems": [
            {
                "id": "c-l8-p1",
                "title": "Macro for Maximum",
                "difficulty": "easy",
                "description": "Define a macro `MAX(a, b)` that returns the maximum of two numbers. Use it in `main` to compare two user inputs.",
                "starter_code": "#include <stdio.h>\n\n// Define MAX macro\n\nint main() {\n    int x, y;\n    // Read x and y\n    // Print MAX(x, y)\n    return 0;\n}",
                "test_cases": [
                    {
                        "stdin": "15 25",
                        "expected_output": "25"
                    }
                ]
            },
            {
                "id": "c-l8-p2",
                "title": "Static Counter",
                "difficulty": "easy",
                "description": "Write a function `void countCalls()` that uses a `static` variable to keep track of how many times it has been called. Print 'Call #1', 'Call #2', etc.",
                "starter_code": "#include <stdio.h>\n\nvoid countCalls() {\n    // Use static variable\n}\n\nint main() {\n    countCalls();\n    countCalls();\n    countCalls();\n    return 0;\n}",
                "test_cases": [
                    {
                        "stdin": "",
                        "expected_output": "Call #1\nCall #2\nCall #3"
                    }
                ]
            },
            {
                "id": "c-l8-p3",
                "title": "Bitwise Even Check",
                "difficulty": "medium",
                "description": "Use the bitwise AND operator (`&`) to check if a number is even or odd. Print 'Even' or 'Odd'.",
                "starter_code": "#include <stdio.h>\n\nint main() {\n    int n;\n    // Read n\n    // Check using (n & 1)\n    return 0;\n}",
                "test_cases": [
                    {
                        "stdin": "4",
                        "expected_output": "Even"
                    },
                    {
                        "stdin": "7",
                        "expected_output": "Odd"
                    }
                ]
            },
            {
                "id": "c-l8-p4",
                "title": "Command Line Addition",
                "difficulty": "medium",
                "description": "Write a program that takes two numbers as command line arguments and prints their sum. If arguments are missing, print 'Usage: ./prog n1 n2'.",
                "starter_code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    // Check argc\n    // Convert argv[1], argv[2] to int and sum\n    return 0;\n}",
                "test_cases": [
                    {
                        "stdin": "10 20",
                        "expected_output": "30"
                    }
                ]
            },
            {
                "id": "c-l8-p5",
                "title": "Typedef for Points",
                "difficulty": "hard",
                "description": "Use `typedef` to create a struct `Point` with `x` and `y`. Write a function `float distance(Point p1, Point p2)` to calculate the distance between two points.",
                "starter_code": "#include <stdio.h>\n#include <math.h>\n\ntypedef struct {\n    float x, y;\n} Point;\n\n// float distance(Point p1, Point p2)\n\nint main() {\n    Point a = {0, 0}, b;\n    // Read b.x and b.y\n    // Print distance with 2 decimal places\n    return 0;\n}",
                "test_cases": [
                    {
                        "stdin": "3 4",
                        "expected_output": "5.00"
                    }
                ]
            }
        ]
    },
    {
        "id": "c-l9",
        "title": "LEVEL 9: Final Assessment",
        "lessons": [
            {
                "id": "c41",
                "title": "Lesson 41: Final C Assessment",
                "duration": "60 mins",
                "content": "**Congratulations!** You have reached the final milestone of the C Programming Masterclass.\n\nThis final lesson is a comprehensive review of everything you have learned, from basic variables to advanced file handling and dynamic memory management.\n\n---\n\n## What this Assessment Means\n\nBy passing this final quiz, you demonstrate proficiency in:\n1.  **Fundamental C Syntax**: Data types, operators, and control flow.\n2.  **Modular Programming**: Using functions and managing variable scope.\n3.  **Data Structures**: Working with arrays, strings, and the powerful `struct` system.\n4.  **Memory Mastery**: Understanding pointers and manual memory allocation (DMA).\n5.  **Systems Thinking**: Handling files and preprocessor directives.\n\n---\n\n## Exam Instructions\n\n- The exam consists of **20 comprehensive questions**.\n- You must achieve a score of **70% or higher** (14 correct answers) to pass.\n- If you pass, you will successfully complete the course.\n\n---\n\n## Ready to Graduate?\n\nTake a deep breath, review your notes if needed, and click the button below to start your final assessment.\n\n**Good luck! We are rooting for you.**",
                "quizQuestions": [
                    {
                        "id": 1,
                        "text": "Why do professional developers use a temporary pointer when calling `realloc()`?",
                        "options": [
                            "To make the code run faster",
                            "To prevent a memory leak if `realloc` returns NULL",
                            "Because `realloc` requires two pointers",
                            "To clear the garbage values"
                        ],
                        "correctAnswer": 1,
                        "explanation": "If `realloc` fails and returns NULL, assigning it directly to the original pointer would lose the address of the existing memory, causing a leak."
                    },
                    {
                        "id": 2,
                        "text": "What is 'Memory Padding' in C structures?",
                        "options": [
                            "Extra memory added to the end of the file",
                            "Empty bytes inserted by the compiler to align members for CPU efficiency",
                            "A way to encrypt data in a struct",
                            "Deleting unused variables automatically"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Compilers insert padding bytes to ensure that structure members are aligned with memory boundaries that the CPU can access efficiently."
                    },
                    {
                        "id": 3,
                        "text": "Which `fseek` origin constant is used to move the pointer relative to the current position?",
                        "options": [
                            "SEEK_SET",
                            "SEEK_END",
                            "SEEK_CUR",
                            "SEEK_START"
                        ],
                        "correctAnswer": 2,
                        "explanation": "SEEK_CUR is used in `fseek` to specify that the offset is relative to the current file pointer position."
                    },
                    {
                        "id": 4,
                        "text": "What is a 'Dangling Pointer'?",
                        "options": [
                            "A pointer that points to NULL",
                            "A pointer that points to memory that has already been freed",
                            "A pointer that hasn't been initialized yet",
                            "A pointer used in a loop"
                        ],
                        "correctAnswer": 1,
                        "explanation": "A dangling pointer occurs after `free()` is called if the pointer is not set to NULL; it still holds the address of 'dead' memory."
                    },
                    {
                        "id": 5,
                        "text": "Which preprocessor directive is most commonly used as a 'Header Guard'?",
                        "options": [
                            "#include",
                            "#define",
                            "#ifndef...#define...#endif",
                            "#pragma once (only)"
                        ],
                        "correctAnswer": 2,
                        "explanation": "The #ifndef pattern is the standard, cross-platform way to prevent multiple inclusions of the same header file."
                    },
                    {
                        "id": 6,
                        "text": "Which memory segment stores local variables and function call information?",
                        "options": [
                            "Heap",
                            "Data Segment",
                            "Stack",
                            "Text Segment"
                        ],
                        "correctAnswer": 2,
                        "explanation": "The Stack is responsible for automatic memory management of local variables and 'frames' for function calls."
                    },
                    {
                        "id": 7,
                        "text": "What is the difference between `malloc` and `calloc`?",
                        "options": [
                            "malloc is faster; calloc initializes memory to zero",
                            "calloc is only for arrays of floats",
                            "malloc handles files, calloc handles RAM",
                            "There is no difference"
                        ],
                        "correctAnswer": 0,
                        "explanation": "malloc leaves garbage values in the memory, while calloc explicitly writes zeros to every bit, which is safer but slightly slower."
                    },
                    {
                        "id": 8,
                        "text": "Which bitwise operator is used to 'turn on' a specific bit (set it to 1) without changing others?",
                        "options": [
                            "& (AND)",
                            "| (OR)",
                            "^ (XOR)",
                            "~ (NOT)"
                        ],
                        "correctAnswer": 1,
                        "explanation": "The OR operator (|) is used to set specific bits. Any bit ORed with 1 becomes 1."
                    },
                    {
                        "id": 9,
                        "text": "Which storage class should you use to make a variable 'remember' its value between function calls without using global variables?",
                        "options": [
                            "auto",
                            "extern",
                            "static",
                            "register"
                        ],
                        "correctAnswer": 2,
                        "explanation": "A `static` local variable is initialized once and persists in the Data Segment for the entire duration of the program."
                    },
                    {
                        "id": 10,
                        "text": "What happens if you call `free()` on a NULL pointer?",
                        "options": [
                            "The program crashes",
                            "It causes a memory leak",
                            "Nothing; it is a safe operation in standard C",
                            "It restarts the computer"
                        ],
                        "correctAnswer": 2,
                        "explanation": "Standard C guarantees that calling `free(NULL)` does absolutely nothing and is perfectly safe. This is why 'NULLifying' pointers after freeing them is a best practice."
                    },
                    {
                        "id": 11,
                        "text": "What is the output of the following code snippet?\n\n```c\nint a = 5;\nint *p = &a;\nprintf(\"%d\", (*p)++);\nprintf(\"%d\", a);\n```",
                        "options": [
                            "55",
                            "56",
                            "66",
                            "65"
                        ],
                        "correctAnswer": 1,
                        "explanation": "(*p)++ is a post-increment of the value. It prints the current value (5) first, then increments 'a' to 6."
                    },
                    {
                        "id": 12,
                        "text": "What does this code print?\n\n```c\nchar str[] = \"Genspark\";\nprintf(\"%zu\", sizeof(str));\n```",
                        "options": [
                            "8",
                            "9",
                            "4",
                            "1"
                        ],
                        "correctAnswer": 1,
                        "explanation": "sizeof includes the hidden null terminator '\\0' at the end of the string literal."
                    },
                    {
                        "id": 13,
                        "text": "Analyze this code. What is wrong with it?\n\n```c\nvoid count() {\n    static int x = 0;\n    x++;\n    printf(\"%d\", x);\n}\n```",
                        "options": [
                            "Nothing, it correctly counts calls",
                            "x will be reset to 0 every call",
                            "static variables cannot be initialized",
                            "It will cause a link error"
                        ],
                        "correctAnswer": 0,
                        "explanation": "This is correct C code. Static variables are initialized once and retain their value between calls."
                    },
                    {
                        "id": 14,
                        "text": "Output of: `printf(\"%d\", 5 | 2);`",
                        "options": [
                            "7",
                            "5",
                            "2",
                            "1"
                        ],
                        "correctAnswer": 0,
                        "explanation": "5 is 101, 2 is 010. 101 | 010 = 111, which is 7."
                    },
                    {
                        "id": 15,
                        "text": "What is the result of `1 << 3`?",
                        "options": [
                            "3",
                            "4",
                            "8",
                            "1"
                        ],
                        "correctAnswer": 2,
                        "explanation": "Shifting 1 left by 3 bits: 0001 -> 1000, which is 8."
                    },
                    {
                        "id": 16,
                        "text": "Analyze for bugs: `int *ptr = malloc(sizeof(int)); *ptr = 10; return;`",
                        "options": [
                            "Syntax error",
                            "Memory Leak",
                            "Segmentation Fault",
                            "Dangling Pointer"
                        ],
                        "correctAnswer": 1,
                        "explanation": "The memory was allocated via malloc but never freed before the function returns, causing a leak."
                    },
                    {
                        "id": 17,
                        "text": "Bug detection: `char *s; strcpy(s, \"Hi\");`",
                        "options": [
                            "Buffer Overflow",
                            "Uninitialized Pointer",
                            "Memory Leak",
                            "Format String Error"
                        ],
                        "correctAnswer": 1,
                        "explanation": "The pointer 's' is declared but doesn't point to any allocated memory, leading to undefined behavior."
                    },
                    {
                        "id": 18,
                        "text": "Identify the risk: `void f() { f(); }`",
                        "options": [
                            "Memory Leak",
                            "Stack Overflow",
                            "Arithmetic Overflow",
                            "Infinite Loop (only)"
                        ],
                        "correctAnswer": 1,
                        "explanation": "Infinite recursion without a base case will eventually exhaust the stack memory."
                    },
                    {
                        "id": 19,
                        "text": "Which access method is correct for `struct Node *n;`?",
                        "options": [
                            "n.value",
                            "n->value",
                            "n(value)",
                            "*n->value"
                        ],
                        "correctAnswer": 1,
                        "explanation": "For pointers to structures, the 'arrow' operator (->) must be used."
                    },
                    {
                        "id": 20,
                        "text": "Final Analysis: Is C a compiled or interpreted language?",
                        "options": [
                            "Interpreted",
                            "Compiled",
                            "Both",
                            "Neither"
                        ],
                        "correctAnswer": 1,
                        "explanation": "C is a compiled language; source code is translated into machine-readable binaries before execution."
                    }
                ]
            }
        ],
        "problems": [
            {
                "id": "c-l9-p1",
                "title": "Linked List Node",
                "difficulty": "medium",
                "description": "Define a struct `Node` for a singly linked list. Allocate a node dynamically, set its data to 10 and next to NULL. Print the data.",
                "starter_code": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node *next;\n};\n\nint main() {\n    // Allocate node\n    // Set values and print data\n    // Free memory\n    return 0;\n}",
                "test_cases": [
                    {
                        "stdin": "",
                        "expected_output": "10"
                    }
                ]
            },
            {
                "id": "c-l9-p2",
                "title": "Stack using Array",
                "difficulty": "medium",
                "description": "Implement a simple stack with `push` and `pop` operations using an array of size 5. Support one push and one pop.",
                "starter_code": "#include <stdio.h>\n\nint stack[5];\nint top = -1;\n\nvoid push(int val) { /* logic */ }\nint pop() { /* logic */ }\n\nint main() {\n    push(100);\n    printf(\"%d\", pop());\n    return 0;\n}",
                "test_cases": [
                    {
                        "stdin": "",
                        "expected_output": "100"
                    }
                ]
            },
            {
                "id": "c-l9-p3",
                "title": "Bubble Sort",
                "difficulty": "hard",
                "description": "Implement Bubble Sort to sort an array of 5 integers in ascending order.",
                "starter_code": "#include <stdio.h>\n\nint main() {\n    int arr[5];\n    // Read 5 elements\n    // Sort using Bubble Sort\n    // Print sorted array\n    return 0;\n}",
                "test_cases": [
                    {
                        "stdin": "5 4 3 2 1",
                        "expected_output": "1 2 3 4 5"
                    }
                ]
            },
            {
                "id": "c-l9-p4",
                "title": "Queue Basics",
                "difficulty": "medium",
                "description": "Implement a basic Queue with `enqueue` and `dequeue`. Support one of each.",
                "starter_code": "#include <stdio.h>\n\nint queue[5];\nint front = 0, rear = 0;\n\nvoid enqueue(int val) { /* logic */ }\nint dequeue() { /* logic */ }\n\nint main() {\n    enqueue(50);\n    printf(\"%d\", dequeue());\n    return 0;\n}",
                "test_cases": [
                    {
                        "stdin": "",
                        "expected_output": "50"
                    }
                ]
            },
            {
                "id": "c-l9-p5",
                "title": "Recursive Binary Search",
                "difficulty": "hard",
                "description": "Implement binary search recursively on a sorted array of 5 integers. Print index of target or -1.",
                "starter_code": "#include <stdio.h>\n\nint binarySearch(int arr[], int l, int r, int x) {\n    // Recursive implementation\n}\n\nint main() {\n    int arr[5] = {10, 20, 30, 40, 50};\n    int x;\n    // Read target x\n    // Print index or -1\n    return 0;\n}",
                "test_cases": [
                    {
                        "stdin": "30",
                        "expected_output": "2"
                    },
                    {
                        "stdin": "25",
                        "expected_output": "-1"
                    }
                ]
            }
        ]
    }
]